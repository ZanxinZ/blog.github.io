[{"content":"较为标准的版本（多人协作） master 分支：用于存放稳定的生产环境代码，每个合并到master的提交通常都对应一个发布版本。\ndevelop 分支：用于源代码功能集成\nfeature分支：基于develop 分支，拉出新分支来开发，开发过程中，需要经常切回develop分支pull最新更改（可能来自其他同事），然后切回feature分支做 git merge develop；开发完成之后提起 Merge Request （也叫 Pull Request）\nrelease1.1.0分支：要发布时，基于 develop 分支来拉出\n当develop分支达到稳定状态时，会通过release分支将代码合并到master分支。（放到 master 上即代表发包完成，并且可以从master上拿这个包去发布给官方平台）\nbug 修复：\ndevelop 阶段：在develop分支或相关feature 分支上修复 release 阶段，则基于 release 拉出 hotfix分支上修复bug，修复后合入 release 并且事后将修改同步到 develop 分支。 如果已经上线（已经由 release 提交到master中），则基于 master 分支的最新 release 去拉出hotfix分支上修复bug，然后合并回 master 和 develop。 master(main)分支的主要作用是：\n代表生产环境的代码，包含已经部署到生产环境的稳定版本 是项目的官方发布历史，每个合并到master的提交通常都对应一个发布版本 需要保持高度稳定，确保任何时候都可以从这个分支部署到生产环境 通常设有保护措施，不允许直接提交，而是通过合并release或hotfix分支的方式更新 在Git流工作流中，master分支与develop分支共同工作：\ndevelop分支用于集成开发中的功能 release 代表产品的不同版本 当develop分支达到稳定状态时，会通过release分支将代码合并到master分支 对于生产环境中发现的紧急问题，会从master分支创建hotfix分支进行修复，然后同时合并回master和develop分支 非标准版本（两三个人的协作时候可以） develop 分支作为源代码管理\nfeature 分支开发功能，完成后合入 develop 分支\n产品版本各个功能开发完成后，直接将 develop 分支的代码拿去打包提交审核。\n产品版本节点使用 tag 标记。例如 v1.1.2。\n","permalink":"https://wowios.com/post/develop/gitwork/","summary":"\u003ch3 id=\"较为标准的版本多人协作\"\u003e较为标准的版本（多人协作）\u003c/h3\u003e\n\u003cp\u003emaster 分支：用于存放稳定的生产环境代码，每个合并到master的提交通常都对应一个发布版本。\u003c/p\u003e\n\u003cp\u003edevelop 分支：用于源代码功能集成\u003c/p\u003e\n\u003cp\u003efeature分支：基于develop 分支，拉出新分支来开发，开发过程中，需要经常切回develop分支pull最新更改（可能来自其他同事），然后切回feature分支做 git merge develop；开发完成之后提起 Merge Request （也叫 Pull Request）\u003c/p\u003e\n\u003cp\u003erelease1.1.0分支：要发布时，基于 develop 分支来拉出\u003c/p\u003e\n\u003cp\u003e当develop分支达到稳定状态时，会通过release分支将代码合并到master分支。（放到 master 上即代表发包完成，并且可以从master上拿这个包去发布给官方平台）\u003c/p\u003e\n\u003cp\u003ebug 修复：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edevelop 阶段：在develop分支或相关feature 分支上修复\u003c/li\u003e\n\u003cli\u003erelease 阶段，则基于 release 拉出 hotfix分支上修复bug，修复后合入 release 并且事后将修改同步到 develop 分支。\u003c/li\u003e\n\u003cli\u003e如果已经上线（已经由 release 提交到master中），则基于 master 分支的最新 release 去拉出hotfix分支上修复bug，然后合并回 master 和 develop。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003emaster(main)分支的主要作用是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e代表生产环境的代码，包含已经部署到生产环境的稳定版本\u003c/li\u003e\n\u003cli\u003e是项目的官方发布历史，每个合并到master的提交通常都对应一个发布版本\u003c/li\u003e\n\u003cli\u003e需要保持高度稳定，确保任何时候都可以从这个分支部署到生产环境\u003c/li\u003e\n\u003cli\u003e通常设有保护措施，不允许直接提交，而是通过合并release或hotfix分支的方式更新\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在Git流工作流中，master分支与develop分支共同工作：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edevelop分支用于集成开发中的功能\u003c/li\u003e\n\u003cli\u003erelease 代表产品的不同版本\u003c/li\u003e\n\u003cli\u003e当develop分支达到稳定状态时，会通过release分支将代码合并到master分支\u003c/li\u003e\n\u003cli\u003e对于生产环境中发现的紧急问题，会从master分支创建hotfix分支进行修复，然后同时合并回master和develop分支\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"非标准版本两三个人的协作时候可以\"\u003e非标准版本（两三个人的协作时候可以）\u003c/h3\u003e\n\u003cp\u003edevelop 分支作为源代码管理\u003c/p\u003e\n\u003cp\u003efeature 分支开发功能，完成后合入 develop 分支\u003c/p\u003e\n\u003cp\u003e产品版本各个功能开发完成后，直接将 develop 分支的代码拿去打包提交审核。\u003c/p\u003e\n\u003cp\u003e产品版本节点使用 tag 标记。例如 v1.1.2。\u003c/p\u003e","title":"Git 分支管理"},{"content":"注册cell 的时候，是 XX 类型和 YY identifier。 一个 XX 可以对应多个 YY。\ncollectionView.register(MyFirstCell.self, forCellWithReuseIdentifier: \u0026#34;FirstCell\u0026#34;) collectionView.register(MySecondCell.self, forCellWithReuseIdentifier: \u0026#34;SecondCell\u0026#34;) 应用场景：同一个 UICollectionView 可以有多种 cell，例如有一个额外的带有 ➕ 的 cell，用于向 UICollectionView 添加新的元素。\n","permalink":"https://wowios.com/post/ios/uicollectionview/","summary":"\u003cp\u003e注册cell 的时候，是 XX 类型和 YY identifier。\n一个 XX 可以对应多个 YY。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecollectionView.register(MyFirstCell.\u003cspan style=\"color:#66d9ef\"\u003eself\u003c/span\u003e, forCellWithReuseIdentifier: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;FirstCell\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecollectionView.register(MySecondCell.\u003cspan style=\"color:#66d9ef\"\u003eself\u003c/span\u003e, forCellWithReuseIdentifier: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;SecondCell\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e应用场景：同一个 UICollectionView 可以有多种 cell，例如有一个额外的带有 ➕ 的 cell，用于向 UICollectionView 添加新的元素。\u003c/p\u003e","title":"UICollectionView"},{"content":"问题: 定时器最好设置为 NSRunLoopCommonModes 在 iOS 中，界面滑动时 RunLoop 会切换到 UITrackingRunLoopMode，而默认情况下 NSTimer 运行在 NSDefaultRunLoopMode，导致滑动时 NSTimer 无法触发或与主线程争夺资源，引发性能下降甚至卡顿。\n原因\nNSTimer 未被正确配置到适当的 RunLoop 模式中，导致滑动和定时器事件无法同时被处理。\n解决方法\n将 NSTimer 添加到 NSRunLoopCommonModes，使其在滑动模式下也能正常触发：\nNSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(timerFired) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; swift 实现\nlet timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in self.timerFired() } RunLoop.current.add(timer, forMode: .common) iOS 中的 RunLoop 使用 模式（Modes） 来区分和管理不同的事件集合。模式决定了 RunLoop 能够处理哪些事件，它们之间是互相独立的。在运行时，RunLoop 会根据当前的模式过滤事件。\n常见的 RunLoop 模式 NSDefaultRunLoopMode\n•\t描述: 默认模式，处理大多数普通任务。\n•\t用途: 用于处理常规的输入事件，例如用户交互、Timer 事件、网络事件等。\n•\t特点: 当用户滚动 UIScrollView 等组件时，RunLoop 会切换到其他模式，此模式的任务可能被暂停。\nUITrackingRunLoopMode\n•\t描述: 滑动追踪模式，用于处理与用户界面滑动相关的事件。\n•\t用途: 专门用来处理滚动视图（如 UIScrollView）滑动时的事件。\n•\t特点: 在用户交互（如滑动滚动视图）期间，RunLoop 会切换到此模式，暂停其他模式的事件处理。\nNSRunLoopCommonModes\n•\t描述: 一种特殊的占位模式，允许事件共享到多个模式中。\n•\t用途: 将任务或事件标记为“常用模式”，以便在常见的 RunLoop 模式下都能运行（例如滑动和普通任务）。\n•\t特点: 包含了 NSDefaultRunLoopMode 和 UITrackingRunLoopMode 等多个模式。 •\t示例:\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; GSEventReceiveRunLoopMode\n•\t描述: 用于接收系统事件（如触摸事件）。\n•\t用途: 系统内部使用的模式，通常开发者不会直接接触。\nkCFRunLoopDefaultMode\n•\t描述: Core Foundation 中的默认模式，与 NSDefaultRunLoopMode 等价。\n•\t用途: 底层使用，用于管理普通事件。\nkCFRunLoopCommonModes\n•\t描述: Core Foundation 的通用模式，与 NSRunLoopCommonModes 等价。\n•\t用途: 底层使用，用于标记共享到多个模式的事件。\n自定义模式\n•\t描述: 开发者可以创建自定义的 RunLoop 模式，处理特定的任务集合。\n•\t用途: 在特殊场景下隔离某些事件，避免它们干扰其他任务。\n•\t示例:\nCFRunLoopAddCommonMode(CFRunLoopGetCurrent(), CFSTR(\u0026#34;MyCustomMode\u0026#34;)); 模式之间的特性 •\t互斥性: RunLoop 在同一时刻只能运行一种模式下的事件。切换模式时，会停止当前模式的事件处理。 •\t优先级: 滑动等高优先级事件会切换到 UITrackingRunLoopMode，暂停其他模式的事件处理。\n模式的使用场景\n•\tNSDefaultRunLoopMode: 适用于绝大多数常规任务。\n•\tUITrackingRunLoopMode: 适用于处理与用户界面滑动相关的任务，如滚动视图。\n•\tNSRunLoopCommonModes: 适用于需要同时在滑动和普通模式下运行的任务（如动画或高频更新的任务）。\nrunloop 特点： runloop 时常不会时间步数固定，有些事件需要做，所以定时器没有非常精准，理论上最小精度为0.1 毫秒。 不过由于受Runloop 的影响，会有50 ~ 100 毫秒的误差，所以，实际精度可以认为是0.1 秒 ","permalink":"https://wowios.com/post/ios-base/runloop/","summary":"\u003ch3 id=\"问题-定时器最好设置为-nsrunloopcommonmodes\"\u003e问题: 定时器最好设置为 NSRunLoopCommonModes\u003c/h3\u003e\n\u003cp\u003e在 iOS 中，界面滑动时 RunLoop 会切换到 UITrackingRunLoopMode，而默认情况下 NSTimer 运行在 NSDefaultRunLoopMode，导致滑动时 NSTimer 无法触发或与主线程争夺资源，引发性能下降甚至卡顿。\u003c/p\u003e\n\u003cp\u003e原因\u003c/p\u003e\n\u003cp\u003eNSTimer 未被正确配置到适当的 RunLoop 模式中，导致滑动和定时器事件无法同时被处理。\u003c/p\u003e\n\u003cp\u003e解决方法\u003c/p\u003e\n\u003cp\u003e将 NSTimer 添加到 NSRunLoopCommonModes，使其在滑动模式下也能正常触发：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-objc\" data-lang=\"objc\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eNSTimer \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003etimer \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [NSTimer scheduledTimerWithTimeInterval:\u003cspan style=\"color:#ae81ff\"\u003e0.1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                                  target:self\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                                selector:\u003cspan style=\"color:#66d9ef\"\u003e@selector\u003c/span\u003e(timerFired)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                                userInfo:nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                                 repeats:YES];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eswift 实现\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e timer = Timer.scheduledTimer(withTimeInterval: \u003cspan style=\"color:#ae81ff\"\u003e0.1\u003c/span\u003e, repeats: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e) { \u003cspan style=\"color:#66d9ef\"\u003e_\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eself\u003c/span\u003e.timerFired()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eRunLoop.current.add(timer, forMode: .common)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eiOS 中的 RunLoop 使用 模式（Modes） 来区分和管理不同的事件集合。模式决定了 RunLoop 能够处理哪些事件，它们之间是互相独立的。在运行时，RunLoop 会根据当前的模式过滤事件。\u003c/p\u003e\n\u003ch3 id=\"常见的-runloop-模式\"\u003e常见的 RunLoop 模式\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eNSDefaultRunLoopMode\u003c/p\u003e\n\u003cp\u003e•\t描述: 默认模式，处理大多数普通任务。\u003c/p\u003e\n\u003cp\u003e•\t用途: 用于处理常规的输入事件，例如用户交互、Timer 事件、网络事件等。\u003c/p\u003e","title":"Runloop"},{"content":" 1. 实例化阶段：init(coder:) 或 init(nibName:bundle:) 被调用 2. 加载视图阶段：loadView → viewDidLoad 3. 视图即将显示：viewWillAppear → viewWillLayoutSubviews 4. 视图完成布局：viewDidLayoutSubviews → viewDidAppear 5. 视图显示期间：viewWillLayoutSubviews/viewDidLayoutSubviews（根据需要多次调用） 6. 视图即将消失：viewWillDisappear 7. 视图已经消失：viewDidDisappear 8. 内存警告：didReceiveMemoryWarning（可能在任何时候发生） 9. 销毁阶段：deinit class LifecycleViewController: UIViewController { // 1. 初始化 override init(nibName: String?, bundle: Bundle?) { super.init(nibName: nibName, bundle: bundle) print(\u0026#34;1. 初始化完成\u0026#34;) } required init?(coder: NSCoder) { super.init(coder: coder) } // 2. 加载视图 override func loadView() { super.loadView() print(\u0026#34;2. loadView 被调用\u0026#34;) } // 3. 视图加载完成 override func viewDidLoad() { super.viewDidLoad() print(\u0026#34;3. viewDidLoad 被调用\u0026#34;) } // 4-5. 视图显示过程 override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) print(\u0026#34;4. viewWillAppear 被调用\u0026#34;) } override func viewWillLayoutSubviews() { super.viewWillLayoutSubviews() print(\u0026#34;5. viewWillLayoutSubviews 被调用\u0026#34;) } override func viewDidLayoutSubviews() { super.viewDidLayoutSubviews() print(\u0026#34;6. viewDidLayoutSubviews 被调用\u0026#34;) } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) print(\u0026#34;7. viewDidAppear 被调用\u0026#34;) } // 6-7. 视图消失过程 override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) print(\u0026#34;8. viewWillDisappear 被调用\u0026#34;) } override func viewDidDisappear(_ animated: Bool) { super.viewDidDisappear(animated) print(\u0026#34;9. viewDidDisappear 被调用\u0026#34;) } // 8. 内存警告 override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() print(\u0026#34;收到内存警告\u0026#34;) } // 9. 析构 deinit { print(\u0026#34;10. 视图控制器被销毁\u0026#34;) } } ","permalink":"https://wowios.com/post/ios-base/viewcontrollerlife/","summary":"\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e1. 实例化阶段\u003c/strong\u003e：init(coder:) 或 init(nibName:bundle:) 被调用\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2. 加载视图阶段\u003c/strong\u003e：loadView → viewDidLoad\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e3. 视图即将显示\u003c/strong\u003e：viewWillAppear → viewWillLayoutSubviews\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e4. 视图完成布局\u003c/strong\u003e：viewDidLayoutSubviews → viewDidAppear\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e5. 视图显示期间\u003c/strong\u003e：viewWillLayoutSubviews/viewDidLayoutSubviews（根据需要多次调用）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e6. 视图即将消失\u003c/strong\u003e：viewWillDisappear\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e7. 视图已经消失\u003c/strong\u003e：viewDidDisappear\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e8. 内存警告\u003c/strong\u003e：didReceiveMemoryWarning（可能在任何时候发生）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e9. 销毁阶段\u003c/strong\u003e：deinit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eLifecycleViewController\u003c/span\u003e: UIViewController {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 1. 初始化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e(nibName: String?, bundle: Bundle?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.\u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e(nibName: nibName, bundle: bundle)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;1. 初始化完成\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003erequired\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e?(coder: NSCoder) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.\u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e(coder: coder)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 2. 加载视图\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eloadView\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.loadView()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;2. loadView 被调用\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 3. 视图加载完成\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviewDidLoad\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.viewDidLoad()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;3. viewDidLoad 被调用\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 4-5. 视图显示过程\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviewWillAppear\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003e_\u003c/span\u003e animated: Bool) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.viewWillAppear(animated)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;4. viewWillAppear 被调用\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviewWillLayoutSubviews\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.viewWillLayoutSubviews()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;5. viewWillLayoutSubviews 被调用\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviewDidLayoutSubviews\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.viewDidLayoutSubviews()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;6. viewDidLayoutSubviews 被调用\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviewDidAppear\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003e_\u003c/span\u003e animated: Bool) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.viewDidAppear(animated)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;7. viewDidAppear 被调用\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 6-7. 视图消失过程\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviewWillDisappear\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003e_\u003c/span\u003e animated: Bool) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.viewWillDisappear(animated)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;8. viewWillDisappear 被调用\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviewDidDisappear\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003e_\u003c/span\u003e animated: Bool) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.viewDidDisappear(animated)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;9. viewDidDisappear 被调用\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 8. 内存警告\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eoverride\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edidReceiveMemoryWarning\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.didReceiveMemoryWarning()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;收到内存警告\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 9. 析构\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edeinit\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;10. 视图控制器被销毁\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"ViewController 生命周期"},{"content":"\n未运行（Not Running）：应用尚未启动或被系统终止 非活动（Inactive）：应用在前台运行但不接收事件，如来电或推送通知时 活动（Active）：应用在前台正常运行并可以接收事件 后台（Background）：应用在后台运行，可执行有限的任务 挂起（Suspended）：应用在后台但不执行代码，可能随时被系统终止 App 启动 (App Starts)\n•\t入口方法： application:didFinishLaunchingWithOptions •\t该方法是应用启动时的入口点。 •\t通常用来初始化应用程序，例如加载配置文件、设置窗口、配置依赖项等。 •\t根据是否有传入的 URL 参数，流程会有所不同： •\t有 URL： 转入 application:openURL:sourceApplication:annotation: 处理 URL。 •\t无 URL： 继续进入活跃状态。\n应用进入前台 (Foreground Run Event Loop)\n•\t入口方法： applicationDidBecomeActive •\t应用进入前台并开始响应事件。 •\t此时，用户可以与应用正常交互，例如触摸、滑动等。\n中断事件 (Interruptions)\n•\t例如接听电话、跳转其他应用。 •\t入口方法： applicationWillResignActive •\t应用即将进入非活动状态（暂停交互）。 •\t适合在这里保存数据或暂停需要持续运行的任务。\n进入后台 (Background Run Loop)\n•\t入口方法： applicationDidEnterBackground •\t应用进入后台，此时需要确保应用资源的正确管理： •\t保存用户数据。 •\t如果需要继续后台运行，需设置 info.plist 或开启后台任务。 •\t如果应用无法在后台继续运行，则可能被系统暂停或终止。\n从后台返回前台\n•\t入口方法： applicationWillEnterForeground •\t应用即将重新进入前台，用户将再次与之交互。 •\t在这里可以恢复状态或刷新界面。\n应用终止 (App Terminate)\n•\t入口方法： applicationWillTerminate •\t当应用即将被系统终止时调用。 •\t适用于进行清理工作，例如保存重要数据。 •\t如果应用在后台运行时未被恢复，且资源紧张，系统可能直接杀掉应用。\n特别流程：\n•\t后台运行与终止判断： •\t如果应用支持后台运行，且 info.plist 配置了相应的权限，则系统会允许部分任务继续在后台完成。 •\t如果不支持，系统可能直接终止应用（Kill）。 总结： iOS 应用的生命周期方法提供了多个状态切换点，开发者可以利用这些方法处理启动、后台、前台、终止等情况。根据不同的用户行为（如按 Home 键、切换任务、接电话），应用需要正确处理状态变化，确保用户体验流畅和数据安全。\nApp 生命周期和 viewController 生命周期初学者可能会混淆，可以参考 viewController 生命周期\n","permalink":"https://wowios.com/post/ios-base/applife/","summary":"\u003cp\u003e\u003cimg alt=\"appStatus\" loading=\"lazy\" src=\"/post/ios-base/applife/appStatus.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e未运行（Not Running）\u003c/strong\u003e：应用尚未启动或被系统终止\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e非活动（Inactive）\u003c/strong\u003e：应用在前台运行但不接收事件，如来电或推送通知时\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e活动（Active）\u003c/strong\u003e：应用在前台正常运行并可以接收事件\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e后台（Background）\u003c/strong\u003e：应用在后台运行，可执行有限的任务\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e挂起（Suspended）\u003c/strong\u003e：应用在后台但不执行代码，可能随时被系统终止\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eApp 启动 (App Starts)\u003c/p\u003e\n\u003cp\u003e•\t入口方法： application:didFinishLaunchingWithOptions\n•\t该方法是应用启动时的入口点。\n•\t通常用来初始化应用程序，例如加载配置文件、设置窗口、配置依赖项等。\n•\t根据是否有传入的 URL 参数，流程会有所不同：\n•\t有 URL： 转入 application:openURL:sourceApplication:annotation: 处理 URL。\n•\t无 URL： 继续进入活跃状态。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e应用进入前台 (Foreground Run Event Loop)\u003c/p\u003e\n\u003cp\u003e•\t入口方法： applicationDidBecomeActive\n•\t应用进入前台并开始响应事件。\n•\t此时，用户可以与应用正常交互，例如触摸、滑动等。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e中断事件 (Interruptions)\u003c/p\u003e\n\u003cp\u003e•\t例如接听电话、跳转其他应用。\n•\t入口方法： applicationWillResignActive\n•\t应用即将进入非活动状态（暂停交互）。\n•\t适合在这里保存数据或暂停需要持续运行的任务。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e进入后台 (Background Run Loop)\u003c/p\u003e\n\u003cp\u003e•\t入口方法： applicationDidEnterBackground\n•\t应用进入后台，此时需要确保应用资源的正确管理：\n•\t保存用户数据。\n•\t如果需要继续后台运行，需设置 info.plist 或开启后台任务。\n•\t如果应用无法在后台继续运行，则可能被系统暂停或终止。\u003c/p\u003e","title":"App 生命周期"},{"content":"类和结构体的区别 计算属性 struct Rectangle { var width: Double var height: Double // 这是一个计算属性 var area: Double { get { return width * height } set { // 假设保持宽高比例不变 let ratio = width / height height = sqrt(newValue / ratio) width = height * ratio } } } 关联对象 Category 和 Extension 的区别 Category（分类）： 可以在不修改原类源代码的情况下给类添加方法 不能添加实例变量（存储属性），但可以使用关联对象 可以被添加到任何类中，包括没有源码的类 在运行时添加方法 可以有多个分类 Extension（扩展）： 只能在原类的实现文件（.m文件）中添加 可以添加实例变量和属性 必须在类的主实现文件中实现所有声明的方法 在编译时添加特性 只能有一个扩展 @interface MyClass () // Extension 1 @property (nonatomic, strong) NSString *property1; @end @interface MyClass () // Extension 2 @property (nonatomic, strong) NSString *property2; @end // 编译后相当于只有一个扩展 @interface MyClass () @property (nonatomic, strong) NSString *property1; @property (nonatomic, strong) NSString *property2; @end OC 可以动态添加属性或方法，但开销较大、类型安全性差、降低代码可维护性和可读性，swift 中限制了这种方式。\n// 使用关联对象添加属性 objc_setAssociatedObject(self, @selector(dynamicProperty), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC); // 动态方法解析 + (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == @selector(dynamicMethod)) { class_addMethod([self class], sel, (IMP)dynamicMethodIMP, \u0026#34;v@:\u0026#34;); return YES; } return [super resolveInstanceMethod:sel]; } 日志场景 在添加日志的场景，swift 不直接使用方法交换、或动态添加方法的方式。\n1. 使用属性包装器（Property Wrappers）实现 @propertyWrapper struct Logged\u0026lt;T\u0026gt; { private var value: T private let label: String init(wrappedValue: T, label: String) { self.value = wrappedValue self.label = label } var wrappedValue: T { get { print(\u0026#34;\\(label) was accessed\u0026#34;) return value } set { print(\u0026#34;\\(label) is being set to \\(newValue)\u0026#34;) value = newValue } } } class Example { @Logged(label: \u0026#34;userName\u0026#34;) var userName: String = \u0026#34;default\u0026#34; } 优势：编译时生成，静态类型检查，运行时几乎没有额外开销。\n2.可使用代理模式或装饰器模式来实现方法拦截 protocol ServiceProtocol { func doSomething() } // 真实服务类 class RealService: ServiceProtocol { func doSomething() { print(\u0026#34;执行实际操作\u0026#34;) } } // 代理类 class LoggingProxy: ServiceProtocol { private let realService: ServiceProtocol init(_ service: ServiceProtocol) { self.realService = service } func doSomething() { print(\u0026#34;方法执行前的日志\u0026#34;) realService.doSomething() print(\u0026#34;方法执行后的日志\u0026#34;) } } 3. Mirror API 实现反射，动态获取实例对象的属性信息。 struct Person { let name: String let age: Int } let person = Person(name: \u0026#34;张三\u0026#34;, age: 30) let mirror = Mirror(reflecting: person) // 遍历所有属性 for case let (label?, value) in mirror.children { print(\u0026#34;\\(label): \\(value)\u0026#34;) } // 输出: // name: 张三 // age: 30 Mirror 的主要特点：\n只读访问：只能读取属性值，不能修改 类型安全：提供类型安全的反射机制 性能开销：相比直接访问属性，使用反射会有一定的性能开销 通常用于以下场景：\n调试工具的开发 对象序列化 日志记录系统 测试框架的开发 为什么要使用反射，而不使用直接访问的方式？ 反射可以忽略属性的类型，获得的是属性的键值对\u0026lt;名称，内容\u0026gt;，不用为每种对象编写重复代码。 以下特定场景必定需要用反射：\n处理未知类型：当需要处理在编译时不知道具体类型的对象时，反射可以帮助我们检查和操作这些对象\n通用序列化：编写能处理任意模型对象的JSON/XML序列化工具时，需要用反射来获取对象的属性。\n// 定义一个简单的模型 struct Person { let name: String let age: Int } // 使用Mirror API进行序列化 func serialize\u0026lt;T\u0026gt;(_ value: T) -\u0026gt; [String: Any] { var dict: [String: Any] = [:] let mirror = Mirror(reflecting: value) for child in mirror.children { if let label = child.label { dict[label] = child.value } } return dict } // 使用示例 let person = Person(name: \u0026#34;张三\u0026#34;, age: 25) let json = serialize(person) // 输出: [\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;age\u0026#34;: 25] // 总之，这种方式，配合泛型，可以处理不同类型的实例、不同类型的属性 框架开发：开发通用框架时，需要处理各种不同的类型，反射提供了统一的处理方式\nprotocol Validatable { func validate() -\u0026gt; Bool } @propertyWrapper struct Validated\u0026lt;T\u0026gt; { private var value: T private let validator: (T) -\u0026gt; Bool init(wrappedValue: T, validator: @escaping (T) -\u0026gt; Bool) { self.value = wrappedValue self.validator = validator } var wrappedValue: T { get { value } set { value = newValue } } var projectedValue: Validated\u0026lt;T\u0026gt; { self } } // 让Validated包装器实现Validatable协议 extension Validated: Validatable { func validate() -\u0026gt; Bool { return validator(value) } } class FormValidator { static func validateForm(_ form: Any) -\u0026gt; Bool { let mirror = Mirror(reflecting: form) for child in mirror.children { // 检查属性是否为Validated类型 if let validated = child.value as? Validatable { if !validated.validate() { return false } } } return true } } // 使用示例 struct UserForm { @Validated(validator: { !$0.isEmpty }) var username: String @Validated(validator: { $0.count \u0026gt;= 6 }) var password: String // 验证表单 func isValid() -\u0026gt; Bool { return FormValidator.validateForm(self) } } 这个框架的优势：统一处理不同类型的数据和验证规则\nFormValidator.validateForm 自动检查所有表单字段的验证状态 提供统一的验证接口 支持可扩展的验证规则 动态UI生成：根据数据模型动态生成UI时，可以通过反射来读取模型的结构。\n","permalink":"https://wowios.com/post/oc-summary/oc-summary/","summary":"\u003ch2 id=\"类和结构体的区别\"\u003e类和结构体的区别\u003c/h2\u003e\n\u003ch2 id=\"计算属性\"\u003e计算属性\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eRectangle\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e width: Double\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e height: Double\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 这是一个计算属性\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e area: Double {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eget\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e width \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e height\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eset\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 假设保持宽高比例不变\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e ratio = width \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e height\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            height = sqrt(newValue \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e ratio)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            width = height \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ratio\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"关联对象\"\u003e关联对象\u003c/h2\u003e\n\u003ch2 id=\"category-和-extension-的区别\"\u003eCategory 和 Extension 的区别\u003c/h2\u003e\n\u003ch3 id=\"category分类\"\u003eCategory（分类）：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e可以在不修改原类源代码的情况下给类添加方法\u003c/li\u003e\n\u003cli\u003e不能添加实例变量（存储属性），但可以使用关联对象\u003c/li\u003e\n\u003cli\u003e可以被添加到任何类中，包括没有源码的类\u003c/li\u003e\n\u003cli\u003e在\u003cstrong\u003e运行时\u003c/strong\u003e添加方法\u003c/li\u003e\n\u003cli\u003e可以有多个分类\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"extension扩展\"\u003eExtension（扩展）：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e只能在原类的实现文件（.m文件）中添加\u003c/li\u003e\n\u003cli\u003e可以添加实例变量和属性\u003c/li\u003e\n\u003cli\u003e必须在类的主实现文件中实现所有声明的方法\u003c/li\u003e\n\u003cli\u003e在\u003cstrong\u003e编译时\u003c/strong\u003e添加特性\u003c/li\u003e\n\u003cli\u003e只能有一个扩展\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-objc\" data-lang=\"objc\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e@interface\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMyClass\u003c/span\u003e ()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Extension 1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e@property\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003enonatomic\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003estrong\u003c/span\u003e) NSString \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eproperty1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e@end\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e@interface\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMyClass\u003c/span\u003e ()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Extension 2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e@property\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003enonatomic\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003estrong\u003c/span\u003e) NSString \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eproperty2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e@end\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 编译后相当于只有一个扩展\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e@interface\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMyClass\u003c/span\u003e ()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e@property\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003enonatomic\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003estrong\u003c/span\u003e) NSString \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eproperty1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e@property\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003enonatomic\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003estrong\u003c/span\u003e) NSString \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eproperty2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003e@end\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eOC 可以动态添加属性或方法，但开销较大、类型安全性差、降低代码可维护性和可读性，swift 中限制了这种方式。\u003c/p\u003e","title":"Oc Summary"},{"content":"《小速记》各部分功能介绍 主页面，各个功能入口\nToDo 功能\n新建 Todo 时，可设定 Todo 的表情 emoji 、时间段。 右滑删除，左滑完成 Todo，长按 Todo 可设定一个在几分钟后的系统通知推送（提醒这个 Todo）\n每日打卡\n可以新建任务，设定为每日打卡、每周打卡或每月打卡。 打卡任务有进度，任务完成后会将任务归档。\n数字记录器\n可以为某一件事情添加计数器，用于腐竹记忆生活中的琐碎数字。\n数据\nTodo、每日打卡、数字记录器是都作为任务，使用 CoreData 存放于本地。 对应的，有 ArchivedTodo、ArchivedDailyTask、ArchivedRecord 作为归档对象，在任务完成后作为记录存放于本地。\n演示\nApp 使用视频演示\n","permalink":"https://wowios.com/post/ios/checkthempicshow/","summary":"\u003ch3 id=\"小速记各部分功能介绍\"\u003e《小速记》各部分功能介绍\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e主页面，各个功能入口\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"../CheckThemPickShow/1.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eToDo 功能\u003c/p\u003e\n\u003cp\u003e新建 Todo 时，可设定 Todo 的表情 emoji 、时间段。\n右滑删除，左滑完成 Todo，长按 Todo 可设定一个在几分钟后的系统通知推送（提醒这个 Todo）\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"../CheckThemPickShow//2.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e每日打卡\u003c/p\u003e\n\u003cp\u003e可以新建任务，设定为每日打卡、每周打卡或每月打卡。\n打卡任务有进度，任务完成后会将任务归档。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"../CheckThemPickShow/4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"../CheckThemPickShow/3.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e数字记录器\u003c/p\u003e\n\u003cp\u003e可以为某一件事情添加计数器，用于腐竹记忆生活中的琐碎数字。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"../CheckThemPickShow//5.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e数据\u003c/p\u003e\n\u003cp\u003eTodo、每日打卡、数字记录器是都作为任务，使用 CoreData 存放于本地。\n对应的，有 ArchivedTodo、ArchivedDailyTask、ArchivedRecord 作为归档对象，在任务完成后作为记录存放于本地。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e演示\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.bilibili.com/video/BV1Vh4y1E7Gx/?vd_source=c24c919e207e47d8f84bb5082e08de26\"\u003eApp 使用视频演示\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"“小速记” App 介绍"},{"content":"跳转部分的实现 我需要从我的 HomeViewController 通过点击不同的 CollectionViewCell 跳至不同的 ViewController\n思路：\n首先是需要把目标 ViewController 存放起来，在点击 cell 时可以作为目的地进行 present 跳转。 因为我的多个不同的 ViewController 都继承自 UIViewController， 那么我想用它作为父类型存放在cell中。\n先把 Main storyboard 存为当前类的属性，以方便初始化各个 collectionView 然后使用 storyboard 自带的动态反射方法 instantiateViewController，通过字符串找到对应的 ViewController 在 dataSource 的实现中，将 cell 的属性绑定为对应的 controllerView 目标。 最后是 didTapCell 方法，是点击后的具体要做的动作，即跳转。这里的 target 类型是 UIController。 发现这样实现不了，原因是第 1 步中 MainChoiceCell 中的 targetController 不能是 weak，若为 weak 那么它在被赋值然后在函数结束时（closure 结束）会释放引用也就是恢复为 nil，所以正确的做法应该是把 weak 去掉。\n手指触碰 UICollectionViewCell 但未释放，这属于 Highlight UICollectionViewCell 底层来自 UIView。重写 highlight 的 willSet， 手指点在 UICollectionViewCell 区域会触发 highlight 置为 true ；手指不松开，移动到不属于 UICollectionViewCell 的区域，则会触发 highlight 置为 false。\noverride var isHighlighted: Bool { willSet { if newValue { UIView.animate(withDuration: 0.2, animations: { self.transform = CGAffineTransform(scaleX: 1.1, y: 1.1) }) } else { UIView.animate(withDuration: 0.2, animations: { self.transform = CGAffineTransform(scaleX: 1, y: 1) }) } } } 实现了进入时扩大，离开时缩小，与 UITapGestureRecognizer 互相独立。使用 UITapGestureRecognizer 实现点击监听\ncell.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(didTapCell(_:)))) 对应的触发任务\n@objc func didTapCell(_ gesture: UITapGestureRecognizer) { guard let cell = gesture.view as? MainChoiceCell else { return } UIView.animate(withDuration: 0.2, delay: 0.2, animations: { cell.transform = CGAffineTransform(scaleX: 1, y: 1) }) DispatchQueue.main.asyncAfter(deadline: .now() + 0.2, execute: { if let target = cell.targetController{ self.present(target, animated: true) } }) } 使用 UITapGestureRecognizer 存在问题 点 cell 然后不松开，手指移到 cell 外边再移回来，它的 isHighlight 会再次被触发（正常），但此时 UITapGestureRecognizer 所发出的事件已经失效，即使此时松开手指，也不会执行触发任务（跳转到另一个 ViewController）。\n使用 didSelectedItemAt 可以解决问题 在 UICollectionView 的 delegate 中实现函数\nfunc collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) { let cell = collectionView.cellForItem(at: indexPath) as! MainChoiceCell UIView.animate(withDuration: 0.2, delay: 0.2, animations: { cell.transform = CGAffineTransform(scaleX: 1, y: 1) }) DispatchQueue.main.asyncAfter(deadline: .now() + 0.2, execute: { if let target = cell.targetController{ // 需要执行的动作 self.present(target, animated: true) } }) } ","permalink":"https://wowios.com/post/ios/viewcontrollertransform/","summary":"\u003ch2 id=\"跳转部分的实现\"\u003e跳转部分的实现\u003c/h2\u003e\n\u003cp\u003e我需要从我的 HomeViewController 通过点击不同的 CollectionViewCell 跳至不同的 ViewController\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%20UICollectionViewCell%20%E8%B7%B3%E8%BD%AC%E8%87%B3%E5%AF%B9%E5%BA%94%E7%9A%84%20UIViewController/Untitled.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%20UICollectionViewCell%20%E8%B7%B3%E8%BD%AC%E8%87%B3%E5%AF%B9%E5%BA%94%E7%9A%84%20UIViewController/Untitled%201.png\"\u003e\u003c/p\u003e\n\u003cp\u003e思路：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先是需要把目标 ViewController 存放起来，在点击 cell 时可以作为目的地进行 present 跳转。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e因为我的多个不同的 ViewController 都继承自 UIViewController， 那么我想用它作为父类型存放在cell中。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%20UICollectionViewCell%20%E8%B7%B3%E8%BD%AC%E8%87%B3%E5%AF%B9%E5%BA%94%E7%9A%84%20UIViewController/Untitled%202.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e先把 Main storyboard 存为当前类的属性，以方便初始化各个 collectionView\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%20UICollectionViewCell%20%E8%B7%B3%E8%BD%AC%E8%87%B3%E5%AF%B9%E5%BA%94%E7%9A%84%20UIViewController/Untitled%203.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e然后使用 storyboard 自带的动态反射方法 instantiateViewController，通过字符串找到对应的 ViewController\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%20UICollectionViewCell%20%E8%B7%B3%E8%BD%AC%E8%87%B3%E5%AF%B9%E5%BA%94%E7%9A%84%20UIViewController/Untitled%204.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 dataSource 的实现中，将 cell 的属性绑定为对应的 controllerView 目标。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%20UICollectionViewCell%20%E8%B7%B3%E8%BD%AC%E8%87%B3%E5%AF%B9%E5%BA%94%E7%9A%84%20UIViewController/Untitled%205.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e最后是 didTapCell 方法，是点击后的具体要做的动作，即跳转。这里的 target 类型是 UIController。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%20UICollectionViewCell%20%E8%B7%B3%E8%BD%AC%E8%87%B3%E5%AF%B9%E5%BA%94%E7%9A%84%20UIViewController/Untitled%206.png\"\u003e\u003c/p\u003e\n\u003cp\u003e发现这样实现不了，原因是第 1 步中 MainChoiceCell 中的 targetController 不能是 weak，若为 weak 那么它在被赋值然后在函数结束时（closure 结束）会释放引用也就是恢复为 nil，所以正确的做法应该是把 weak 去掉。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%20UICollectionViewCell%20%E8%B7%B3%E8%BD%AC%E8%87%B3%E5%AF%B9%E5%BA%94%E7%9A%84%20UIViewController/Untitled%207.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"手指触碰-uicollectionviewcell-但未释放这属于-highlight\"\u003e手指触碰 UICollectionViewCell 但未释放，这属于 Highlight\u003c/h2\u003e\n\u003cp\u003eUICollectionViewCell 底层来自 UIView。重写 highlight 的 willSet， 手指点在 UICollectionViewCell 区域会触发 highlight 置为 true ；手指不松开，移动到不属于 UICollectionViewCell 的区域，则会触发 highlight 置为 false。\u003c/p\u003e","title":"如何通过点击 UICollectionViewCell 跳转至对应的 UIViewController"},{"content":"需要用到的硬件 工控机本体这里称为 A， 一台可以连接 WiFi 或者可插入以太网网线的设备称为 B。 公网的接入端口线称为 C。 一个 Wifi 路由器D。 键盘与HDMI 显示器（用于命令行查看系统信息，可省略）、两条网线。 方法一：”不同网段“接法 软路由的 LAN 接 WiFi 的 WAN，连接 WiFi 的设备和直连软路由的设备不算是同一网段。\nWiFi 所在 192.168.1.x\n软路由所在 192.168.11.x\n关键步骤：\n以太网连接，从 C 上接一条网线到 A 的 eth1 端口。D 的 WAN 网口和 A 的 eth0 用网线连接。 使用设备 B，连接 WiFi，然后登入后台管理页面，网址一般在 WiFi 路由器背后有写明。 设备B 需要关键一步：设置为 自动 IP 分配，那么才可以在 B 上访问到 192.168.11.1\n关键配置：\n登入D 的 后台页面（依据不同品牌而定，我这里是 192.168.1.1）。WiFi 路由器 D 的设置，需要设置为 自动获得 IP 地址，拔掉 WiFi 的电源，重启，它会通过A、公网 C 自动获得 IP。这时，连接到该 WiFi 的设备就可以通过 192.168.11.1 进入软路由的管理页面了。\n进入 软路由系统的管理页面，在 openclash 中填入订阅地址，保存设置然后启动 clash 服务，即可。\n方法二：同一网段的接法 软路由与 WiFi 之间使用 LAN，连接 WiFi 的设备和直连软路由的设备属于同一网段。\n修改为交换机模式 AP mode\n设置本 WiFi 配置页面的 IP 地址，网段和软路由那边的保持一致。\n关闭 DHCP，使得路由器不作为子网网关\n这样一来，连接到 WiFi 的设备既可以访问 192.168.11.1 的软路由管理页面，也可以访问原本 WiFi 的管理页面。后续的 open clash 配置和方法一的一样。\n实际运行效果：两台播放 1080P 视频的设备同时使用，CPU 占用率也不高，可以看出来这个 N4000 在日常个人多设备使用场景下基本是够用的 ","permalink":"https://wowios.com/post/tool/wrt/setnetwork/","summary":"\u003ch3 id=\"需要用到的硬件\"\u003e需要用到的硬件\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e工控机本体这里称为 A，\u003c/li\u003e\n\u003cli\u003e一台可以连接 WiFi 或者可插入以太网网线的设备称为 B。\u003c/li\u003e\n\u003cli\u003e公网的接入端口线称为 C。\u003c/li\u003e\n\u003cli\u003e一个 Wifi 路由器D。\u003c/li\u003e\n\u003cli\u003e键盘与HDMI 显示器（用于命令行查看系统信息，可省略）、两条网线。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"方法一不同网段接法\"\u003e方法一：”不同网段“接法\u003c/h3\u003e\n\u003cp\u003e软路由的 LAN 接 WiFi 的 WAN，连接 WiFi 的设备和直连软路由的设备不算是同一网段。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../N4000%20%E5%9B%9B%E7%BD%91%E5%8F%A3%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BB%84%E7%BD%91/Untitled.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWiFi 所在 192.168.1.x\u003c/p\u003e\n\u003cp\u003e软路由所在 192.168.11.x\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e关键步骤：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e以太网连接，从 C 上接一条网线到 A 的 eth1 端口。D 的 WAN 网口和 A 的 eth0 用网线连接。\u003c/li\u003e\n\u003cli\u003e使用设备 B，连接 WiFi，然后登入后台管理页面，网址一般在 WiFi 路由器背后有写明。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e设备B 需要关键一步：设置为 自动 IP 分配，那么才可以在 B 上访问到 192.168.11.1\u003c/p\u003e\n\u003cp\u003e关键配置：\u003c/p\u003e\n\u003cp\u003e登入D 的 后台页面（依据不同品牌而定，我这里是 192.168.1.1）。WiFi 路由器 D 的设置，需要设置为 自动获得 IP 地址，拔掉 WiFi 的电源，重启，它会通过A、公网 C 自动获得 IP。这时，连接到该 WiFi 的设备就可以通过 192.168.11.1 进入软路由的管理页面了。\u003c/p\u003e","title":"N4000 四网口工控机组网"},{"content":"若域名有变动 需要修改三个地方\nworkflow 文件夹里 Github Acction 配置文件 Action.yml 中的 cname: config.yaml 中的 baseURL Github repository setting Pages ","permalink":"https://wowios.com/post/tool/usehugo/someproblem/","summary":"\u003ch2 id=\"若域名有变动\"\u003e若域名有变动\u003c/h2\u003e\n\u003cp\u003e需要修改三个地方\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eworkflow 文件夹里 Github Acction 配置文件 \u003ccode\u003eAction.yml\u003c/code\u003e 中的 \u003ccode\u003ecname:\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003econfig.yaml 中的 \u003ccode\u003ebaseURL\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eGithub repository setting \u003ccode\u003ePages\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"Hugo 的一些问题"},{"content":"安装 windows：确保有 hugo.exe 在工程目录下, 并且 .gitignore 里面写上 hugo.exe，即可 Mac：确保 hugo 已安装就可以 新建 一般，都在 post 文件夹下放 markdown 文件，使用不同文件夹来归类\nhugo new post/tool/useHugo/publishArticle.md\n书写 设定文章的 title, categories, tags 写入内容。标题大小从 ## 开始 本地预览 hugo server\n编译成 html，输出到 /docs （路径与 GitHub Action 对应） hugo\n到这里，就完成了写作\nGit Push 先 fetch，再 commit，再 push。\nGithub Page 需要重新填写域名 因为 Github Action 在执行的时候会把 master 分支中的 /docs 内所有内容拷贝到 main 分支，这里面不包括 CNAME 文件。所以在 repository 的 setting 的 pages 重新填写域名。（问题已经解决，在 workflow action.yml 中添加 cname: 1-1.link，所以如果域名有改动，需要在这修改）\n","permalink":"https://wowios.com/post/tool/usehugo/publisharticle/","summary":"\u003ch2 id=\"安装\"\u003e安装\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ewindows：确保有 hugo.exe 在工程目录下, 并且 .gitignore 里面写上 \u003ccode\u003ehugo.exe\u003c/code\u003e，即可\u003c/li\u003e\n\u003cli\u003eMac：确保 hugo 已安装就可以\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新建\"\u003e新建\u003c/h2\u003e\n\u003cp\u003e一般，都在 post 文件夹下放 markdown 文件，使用不同文件夹来归类\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003ehugo new post/tool/useHugo/publishArticle.md\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"书写\"\u003e书写\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e设定文章的 title, categories, tags\u003c/li\u003e\n\u003cli\u003e写入内容。标题大小从 \u003ccode\u003e##\u003c/code\u003e 开始\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"本地预览\"\u003e本地预览\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003ehugo server\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"编译成-html输出到-docs-路径与-github-action-对应\"\u003e编译成 html，输出到 /docs （路径与 GitHub Action 对应）\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003ehugo\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e到这里，就完成了写作\u003c/p\u003e\n\u003ch2 id=\"git-push\"\u003eGit Push\u003c/h2\u003e\n\u003cp\u003e先 fetch，再 commit，再 push。\u003c/p\u003e\n\u003ch3 id=\"github-page-需要重新填写域名\"\u003e\u003cdel\u003eGithub Page 需要重新填写域名\u003c/del\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cdel\u003e因为 Github Action 在执行的时候会把 master 分支中的 /docs 内所有内容拷贝到 main 分支，这里面不包括 CNAME 文件。所以在 repository 的 setting 的 pages 重新填写域名。\u003c/del\u003e\u003cstrong\u003e（问题已经解决，在 workflow \u003ccode\u003eaction.yml\u003c/code\u003e 中添加 \u003ccode\u003ecname: 1-1.link\u003c/code\u003e，所以如果域名有改动，需要在这修改）\u003c/strong\u003e\u003c/p\u003e","title":"Hugo 发布一篇文章的过程"},{"content":"Notion 批量文件导出，以 PFD格式 Notion 是一款 markdown 笔记软件，可以快速书写，多端同步，支持文件导出，十分方便。 我在 notion 中写了很多页面，有时要转移到别的地方保存，那么应该怎么做呢？\nnotion 支持导出的文件格式：PDF，HTML，MD 可是，这几种方法都有缺点。\nPDF：只能当前页面，导出所有子页面，需要升级 Pro HTML：多出了一些附带的文件，文件散乱，转移和浏览都不方便 MD：导出之后，图片和文本都分开，转移不方便，文件散乱 那么，有没有更简单的办法获取我自己写的许多页面，且保存为 PDF ？ 有的，步骤如下：\n在notion中包含子页面导出 markdown 使用 vs code 打开，使用插件 Markdown PDF 逐页导出。 具体操作步骤 下图可以看到我的一个页面包含了多个子页面。\n右上角三个点的按钮，选择 export\n导出 markdown\n会得到页面和子页面的目录结构\n使用 vscode 打开。\n安装插件 ”Markdown PDF“\n搜索 Markdown PDF， 点击安装 install。\n设置 ”auto convert when save “\n在插件库里可以看到已安装 Markdown PDF\n这样一来，打开一个 md 文件，ctrl + s，它就自动转换为 pdf 并输出到源路径了。\n当然，也可以自己设定输出的路径，方便批量管理。\n总结 到这里，就实现了 Notion 写作内容的固化和转移啦！\n","permalink":"https://wowios.com/post/tool/notion/notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/","summary":"\u003ch2 id=\"notion-批量文件导出以-pfd格式\"\u003eNotion 批量文件导出，以 PFD格式\u003c/h2\u003e\n\u003cp\u003eNotion 是一款 markdown 笔记软件，可以快速书写，多端同步，支持文件导出，十分方便。\n我在 notion 中写了很多页面，有时要转移到别的地方保存，那么应该怎么做呢？\u003c/p\u003e\n\u003ch3 id=\"notion-支持导出的文件格式pdfhtmlmd\"\u003enotion 支持导出的文件格式：PDF，HTML，MD\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled.png\"\u003e\u003c/p\u003e\n\u003cp\u003e可是，这几种方法都有缺点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePDF：只能当前页面，导出所有子页面，需要升级 Pro\u003c/li\u003e\n\u003cli\u003eHTML：多出了一些附带的文件，文件散乱，转移和浏览都不方便\u003c/li\u003e\n\u003cli\u003eMD：导出之后，图片和文本都分开，转移不方便，文件散乱\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"那么有没有更简单的办法获取我自己写的许多页面且保存为-pdf-\"\u003e那么，有没有更简单的办法获取我自己写的许多页面，且保存为 PDF ？\u003c/h3\u003e\n\u003cp\u003e有的，步骤如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在notion中包含子页面导出 markdown\u003c/li\u003e\n\u003cli\u003e使用 vs code 打开，使用插件 Markdown PDF 逐页导出。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"具体操作步骤\"\u003e具体操作步骤\u003c/h3\u003e\n\u003cp\u003e下图可以看到我的一个页面包含了多个子页面。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e右上角三个点的按钮，选择 export\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled2.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e导出 markdown\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled3.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e会得到页面和子页面的目录结构\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled5.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e使用 vscode 打开。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e安装插件 ”Markdown PDF“\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled6.png\"\u003e\u003c/p\u003e\n\u003cp\u003e搜索 Markdown PDF， 点击安装 install。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled7.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e设置 ”auto convert when save “\u003c/p\u003e\n\u003cp\u003e在插件库里可以看到已安装 Markdown PDF\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled8.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"../Notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/Untitled9.png\"\u003e\u003c/p\u003e\n\u003cp\u003e这样一来，打开一个 md 文件，ctrl + s，它就自动转换为 pdf 并输出到源路径了。\u003c/p\u003e","title":"Notion文件导出"},{"content":"多线程 Java 多线程编程笔记 🔗\n","permalink":"https://wowios.com/post/language/java/java/","summary":"\u003ch2 id=\"多线程\"\u003e多线程\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://javadoc.wowios.com\"\u003eJava 多线程编程笔记 🔗\u003c/a\u003e\u003c/p\u003e","title":"Java"},{"content":"\n1998.01 | 广东 | 硕士研究生\n电话: 13757116490 | 邮箱: cinuni@outlook.com | Github: https://github.com/ZanxinZ\n工作经历 2024.06.24-2024.11.06 北京猫眼微影科技有限公司 iOS软件前端开发 教育经历 2017\u0026ndash;2021 中国计量大学（本科）自动化专业 2021\u0026ndash;2024 中国计量大学（研究生）电子信息专业 技术栈 iOS Swift | Objective-C | 数据结构与算法 | 设计模式 | Git 协作 | Python\n项目经历 2024.11-至今 格言 App\n2022-2023 iOS App “小速记”\n可用于记录一些小计划。具有 ToDo、每日打卡、数字记录、统计功能。\n主要技术:\nCoreData管理各个对象信息 ｜ UIKit 原生实现 ｜ 支持简体中文、繁体、英文本地化\n2021.05 跨平台文件传输 AAcell\n负责后端 Java 开发，基于 SpringBoot 框架搭建 web 服务，实现文件传输、共享服务;\n多台不同系统的设备输入同一房间号和密码可以进入房间;\n使用拦截器配合 JWT (Json Web Token) 验证用户;\nSHA-256 摘要保存密码，在仅知道密文的情况下无法获取用户设置的源密码;\n使用 MySQL 数据库存放房间信息和用户发送的消息;\n各个房间的文件存放在固定文件夹;\n房间使用期限一周，过期将被完全销毁。\n2021.07 安卓平板点餐 App CakeTouch\n前台工作人员为客户记录每一个订单需要的商品，在确认订单之后，App连接蓝牙打印机打印出商品订单信息。\n2021.02 本科毕设 基于 Mask-RCNN 和双目视觉对快递包裹内物体的三维定位\nMask-RCNN 识别包裹内的物体种类和物体边缘，使用双目视觉测得物体的与相机的距离，从而得到每一个物体的三维坐标值，为后续机械臂抓取物体提供坐标信息。\n校园经历 2019.05 浙江省大学生机器人比赛，寻宝机器人组，二等奖 2019.11 大学生挑战杯，鸡枞根部切削机器人项目，国赛三等奖 2022.07 “兆易创新杯” 第十七届研究生电子设计竞赛，华东赛区团队二等奖 英语六级 CET-6 兴趣爱好 了解新的的技术和数码产品 制作 App 摄影 电影 古典音乐 游泳、保龄球、羽毛球、篮球 ","permalink":"https://wowios.com/about/","summary":"\u003cp\u003e\u003cimg alt=\"me\" loading=\"lazy\" src=\"/about/me.jpeg\"\u003e\u003c/p\u003e\n\u003cp\u003e1998.01 | 广东 | 硕士研究生\u003c/p\u003e\n\u003cp\u003e电话: 13757116490 | 邮箱: \u003ca href=\"mailto:cinuni@outlook.com\"\u003ecinuni@outlook.com\u003c/a\u003e | Github: \u003ca href=\"https://github.com/ZanxinZ\"\u003ehttps://github.com/ZanxinZ\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"工作经历\"\u003e工作经历\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e2024.06.24-2024.11.06 北京猫眼微影科技有限公司 iOS软件前端开发\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"教育经历\"\u003e教育经历\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e2017\u0026ndash;2021 中国计量大学（本科）自动化专业\u003c/li\u003e\n\u003cli\u003e2021\u0026ndash;2024 中国计量大学（研究生）电子信息专业\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"技术栈\"\u003e技术栈\u003c/h3\u003e\n\u003cp\u003eiOS Swift | Objective-C | 数据结构与算法 | 设计模式 | Git 协作 | Python\u003c/p\u003e\n\u003ch3 id=\"项目经历\"\u003e项目经历\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e2024.11-至今 格言 App\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e2022-2023 iOS App \u003ca href=\"/post/ios/checkthempicshow\"\u003e\u003cstrong\u003e“小速记”\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e可用于记录一些小计划。具有 ToDo、每日打卡、数字记录、统计功能。\u003c/p\u003e\n\u003cp\u003e主要技术:\u003c/p\u003e\n\u003cp\u003eCoreData管理各个对象信息 ｜ UIKit 原生实现 ｜ 支持简体中文、繁体、英文本地化\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e2021.05 跨平台文件传输 \u003cstrong\u003eAAcell\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e负责后端 Java 开发，基于 SpringBoot 框架搭建 web 服务，实现文件传输、共享服务;\u003c/p\u003e\n\u003cp\u003e多台不同系统的设备输入同一房间号和密码可以进入房间;\u003c/p\u003e\n\u003cp\u003e使用拦截器配合 JWT (Json Web Token) 验证用户;\u003c/p\u003e\n\u003cp\u003eSHA-256 摘要保存密码，在仅知道密文的情况下无法获取用户设置的源密码;\u003c/p\u003e","title":"简历"},{"content":"Creational Object Created Pattern\nFactory Method Provide the method for creating an instance in the superclass, and allow the subclass to choose the type of the instance.\n在父类中提供创建对象的方法，允许子类决定实例化对象的类型。\n具备的部分：生产者协议、产品协议，往后就可以根据需要来扩展每一种产品。\n具体的生产者比如 MongoCakeCreator 的存在是为了实现与产品相关的核心业务逻辑，而不仅仅是创建 MongoCake 实例。工厂方法将核心业务逻辑从具体产品类中分离出来。\n// Creator protocol CakeCreator { func createCake() -\u0026gt; Cake func doSomethingForCake(cake: Cake) -\u0026gt; Cake } // Product protocol Cake { func doWork() } // ConcreteCreator class MongoCakeCreator: CakeCreator { var cake: MongoCake? func createCake() -\u0026gt; Cake { var cake = MongoCake() doSomethingForCake(cake: cake) return cake } func doSomethingForCake(cake: Cake) -\u0026gt; Cake{ cake.doWork() cake.doWork() return cake } } // ConcreteCreator class ChocolateCakeCreator: CakeCreator { func createCake() -\u0026gt; Cake { var cake = ChocolateCake() doSomethingForCake(cake: cake) return cake } func doSomethingForCake(cake: Cake) -\u0026gt; Cake{ cake.doWork() return cake } } class MongoCake: Cake { func doWork() { print(\u0026#34;Add some mongo\u0026#34;) } } class ChocolateCake: Cake { func doWork() { print(\u0026#34;Add some chocolate\u0026#34;) } } // If we want to add a type of cake call \u0026#34;PinapleCake\u0026#34;, just need to // make it conform to Cake and add a creator that conform to the CakeCreator for the \u0026#34;PinapleCake\u0026#34; let cakeOne = MongoCakeCreator().createCake() Abstract Factory Base on the factory method, add an abstract factory. We can call the same abstract factory method to create different mode’s product. If we want to create another mode’s product, we need to change the concrete factory.\n基于工厂方法模式，我们添加了一个抽象工厂协议，其它具体的工厂来实现这个工厂协议。从而我们可以调用同一个抽象工厂方法来创建不同模式的相似产品（比如 WinButton 和 MacButton）。如果想要切换模式，我们需要切换到另外一种具体的工厂实现。\n// Abstract factory protocol GUIFactory { func createButton() -\u0026gt; Button func createCheckBox() -\u0026gt; CheckBox } // Concrete factory class WinGUIFactory: GUIFactory { func createButton() -\u0026gt; Button { var btn = WinButton() return btn } func createCheckBox() -\u0026gt; CheckBox { var box = WinCheckBox() return box } } // Concrete factory class MacGUIFactory: GUIFactory { func createButton() -\u0026gt; Button { var btn = MacButton() return btn } func createCheckBox() -\u0026gt; CheckBox { var box = MacCheckBox() return box } } // Abstract product protocol Button { func click() } // Abstract product protocol CheckBox { func render() } // Concrete product class WinButton: Button { func click() { print(\u0026#34;Win click button\u0026#34;) } } // Concrete product class WinCheckBox: CheckBox { func render() { print(\u0026#34;Here the win render checkBox\u0026#34;) } } // Concrete product class MacButton: Button { func click() { print(\u0026#34;Mac click button\u0026#34;) } } // Concrete product class MacCheckBox: CheckBox { func render() { print(\u0026#34;Here the mac render checkBox\u0026#34;) } } class App { var factory: GUIFactory init(factory: GUIFactory) { self.factory = factory } func someOperation() { var checkBox = factory.createCheckBox() checkBox.render() } } let factory = WinGUIFactory() let app = App(factory: factory) // The mode is choosen now, and the behavior in the app is specific. let button = app.factory.createButton(); button.click() app.someOperation() Builder Extracting the instance’s building code from the instance’s class, and put the code into a “Builder” object to do the build work. So we can build different complex instance by using different composition of the builder method. Besides, Add a “director” to manage the calling form client.\n将对象的构造代码从对象的产品类代码中抽离出来，将这些代码放置在一个名为 “生成器” 的独立对象中。 所以，我们可以通过在建造方法中使用不同的组合，来创建不同的复杂实例。并且，增加一个 “指挥者” 来管理那些来自外界客户对调用。\n// Director class HouseDirector{ var builder: HouseBuilder init (builder: HouseBuilder) { self.builder = builder } func changeBuilder(bulider: HouseBuilder) { self.builder = bulider } // The function \u0026#34;make\u0026#34; define the house must built by some componets. func make(type: String) { builder.reset() if type == \u0026#34;simple\u0026#34; { builder.buildA() } else { builder.buildB() builder.buildC() } } } // Builder protocol HouseBuilder { func reset() func buildA() func buildB() func buildC() } class Builder1: HouseBuilder { private var result: Product1? func reset() { result = Product1() } func buildA() { } func buildB() { } func buildC() { } func getResult() -\u0026gt; Product1? { return result } } class Builder2: HouseBuilder { private var result: Product2? func reset() { result = Product2() } func buildA() { } func buildB() { } func buildC() { } func getResult() -\u0026gt; Product2? { return result } } class Product1 { } class Product2 { } let b = Builder1() let director = HouseDirector(builder: b) director.make(type: \u0026#34;complex\u0026#34;) Singleton Singleton can solve two problem:\nKeep that one specific class have only one instance Provide a global access node for this instance Implementation:\nSet the default initializer as private to prevent other objects use it. Create a static func that will call the default initializer if the single instance is null, then this class will have this only one instance. 单例模式解决了可以解决两个问题：\n保证某个类只有一个实例 为这个实例提供全局的访问节点 实现：\n将默认的构造函数设置为私有，让其它对象无法访问。 新建一个静态函数，在这个函数内进行判断，若单例对象为空，则调用私有的构造函数来创建实例对象，实例只被创建一次。 class FileAccess { private static var obj: FileAccess? = nil private init(){ } public static func getInstance() { if obj == nil { obj = FileAccess() } } } let firstAccess = FileAccess.getInstance() let secondAccess = FileAccess.getInstance() // These two access are reference to a same instance. Prototype When we want to clone the instance itself, it may create some dependencies between the client and the original class, it will make the code be more complex. So we use “prototype” to compound the clone operation into the original class itself. And the clone operation will be easily.\n当我们想要完全复制一个对象它本身时，很可能会在调用者和源类之间产生一些复杂当耦合关系。所以我们使用“原型”模式，将对象克隆操作整合在对象当源类之中。这样一来，克隆操作由特定的类自身决定，调用变得简洁。\n// Prototype protocol StorePrototype{ func clone() -\u0026gt; Store } // Concrete Prototype class Store: StorePrototype { var area: [Int] = [0, 0] init(store: StorePrototype) { if let s = store as? Store { self.area = s.area } } init() {} func clone() -\u0026gt; Store { return Store(store: self) } } // Sub Concrete Prototype class BookStore: Store { var bookSelfCount = 0 init(bookStore: StorePrototype) { super.init(store: bookStore) if let s = bookStore as? BookStore { self.bookSelfCount = s.bookSelfCount } } override init() { super.init() } override func clone() -\u0026gt; Store { return BookStore(bookStore: self) } } // Sub Concrete Prototype class FlowerStore: Store { var flowers = [\u0026#34;Sun Flower\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Lily\u0026#34;] init(flowerStore: StorePrototype) { super.init(store: flowerStore) if let s = flowerStore as? FlowerStore { self.flowers = s.flowers } } override init() { super.init() } override func clone() -\u0026gt; Store { return FlowerStore(flowerStore: self) } } let store = Store() let obj = FlowerStore() let copyStore = store.clone() let copyObj = obj.clone() // Now it did the deep copy. It copy the whole instance \u0026#34;store\u0026#34; to \u0026#34;copyStore\u0026#34;, and copy the whole instace \u0026#34;obj\u0026#34; to copyObj. Structural Adapter A class called ‘A’ needs to disguise as another class called ‘B’, create a new adapter to extend the target class B and then insert the class A into the adapter, override the methods from the class B in the adapter. So we can use the adapter which has new features from A, just like we are using class B(The adapter extends from class B).\n类 A 想要适配类 B，首先使用一个适配器继承类 B ，把类 A 注入适配器，在适配器里面重写需 要模仿的类 B 的方法。最后，在需要用 A 替换 B 的地方，传递一个适配器即可，因为它既具有 A 的性质，又具有 B 的方法，它继承自 B ，可以当作 B 来调用。\nclass Bike { var name = \u0026#34;deafult\u0026#34; func go() { print(\u0026#34;Bike Go\u0026#34;) } func addWheel() { print(\u0026#34;Add wheel for\\(name)\u0026#34;) } } class WaterBike { var weight = 0 func floating() { print(\u0026#34;The water bike floating on the water\u0026#34;) } } // now the water bike adapt the bike, inherit the target(Bike) that be disguised. class WaterBikeAdapter: Bike { var waterBike: WaterBike? init(waterBike: WaterBike) { self.waterBike = waterBike // inject the waterBike(which want to disguise as other) } override func go() { print(\u0026#34;Now it\u0026#39;s the water bike go\u0026#34;) } } func someThingGo(bike: Bike) { bike.go() } // This mode make the \u0026#34;WaterBike\u0026#34; to disguise as a \u0026#34;Bike\u0026#34; let waterBikeAdapter = WaterBikeAdapter(waterBike: WaterBike()) // The adapter has a waterBike and has the method of bike. someThingGo(bike: waterBikeAdapter) // Now it can use as a bike. Bridge It depart one class or some closing class into two independent layer, the abstract and the implementation. The concrete class A contains an abstract interface B, and this interface can be implement in different ways. The A relies on the interface B not the concrete class. We inject different concrete class（has implemented interface B） for A or subclass of A, so we can get an instance of A or subclass with different functionality.\n桥接模式将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构。实体类 A 包含有接口 B，这个接口可以通过不同的方式来实现。实体类 A 依赖于接口 B 而不是具体的类。 我们使用不同的实现了接口 B 的实体类注入到 A 类实体或者 A类的子类的实体中，从而可以得到具有不同功能的 A 实体 或者 A 子类实体。\n// Abstract interface protocol Device { func isEnable() -\u0026gt; Bool func enable() func disable() func getVolume() -\u0026gt; Int func setVolume(_ volumn: Int) func getChannel() -\u0026gt; Int func setChannel(_ channel: Int) } // Concrete class that contains the interface class Remote { var device: Device init(_ device: Device) { self.device = device } func togglePower() { if device.isEnable() { device.disable() } else { device.enable() } } func volumeUp() { device.setVolume(device.getVolume() + 1) } func voluomeDown() { device.setVolume(device.getVolume() - 1) } func channelUp() { device.setChannel(device.getChannel() + 1) } func channelDown() { device.setChannel(device.getChannel() - 1) } } // Sub class class AdvanceRemote: Remote { override init(_ device: Device) { super.init(device) } func mute() { device.setVolume(0) } } // Specific implementation of the interface class TV: Device { private var displaySize = (1080, 960) private var on: Bool = false private var volume = 0 private var channel = 0 func isEnable() -\u0026gt; Bool { return on } func enable() { self.on = true } func disable() { self.on = false } func getVolume() -\u0026gt; Int { return volume } func setVolume(_ volumn: Int) { self.volume = volumn } func getChannel() -\u0026gt; Int { return channel } func setChannel(_ channel: Int) { self.channel = channel } } // Specific implementation of the interface class Radio: Device { private var on: Bool = false private var volume = 0 private var channel = 0 func isEnable() -\u0026gt; Bool { return on } func enable() { on = true } func disable() { on = false } func getVolume() -\u0026gt; Int { return volume } func setVolume(_ volumn: Int) { self.volume = volumn } func getChannel() -\u0026gt; Int { return channel } func setChannel(_ channel: Int) { self.channel = channel } } let tv = TV() // create a TV let remote = AdvanceRemote(tv) // inject a concrete Device to the remote. remote.togglePower() remote.channelUp() remote.volumeUp() remote.mute() let radio = Radio() let remoteForRadio = Remote(radio) remoteForRadio.channelUp() remoteForRadio.togglePower() Composite We want to make the client using the Container or Leafs in a same calling way, so we set the leaf and the container that implement the same interface (Component). And the Container contains some children. In this way we create a model like tree, the client can treat every node similarly.\n为了使客户端能够使用相同的方式调用 “容器” 和 “叶子”，我们让容器和叶子都去实现同一个接口 “组件”。并且容器中包含有一些子的容器。通过这种方式，我们可以创建一个类似于一棵树的模型，客户端对每个结点使用相同的对待方式。\n// interface protocol Component { func execute() } class Leaf: Component { func execute() { print(\u0026#34;I\u0026#39;m leaf\u0026#34;) } } class SubLeaf: Leaf { override func execute() { print(\u0026#34;I\u0026#39;m sub leaf\u0026#34;) } } // Composite class Containner:Component { private var children: [Component] = [] func add(c: Component) { children.append(c) } func remove(c: Component) { } func execute() { for item in children { item.execute() } } } // We treat the leaf and the containner as the same type of node. let leaf = Leaf() let leafTwo = Leaf() let subLeaf = SubLeaf() let c = Containner() c.add(c: leaf) c.add(c: leafTwo) let root = Containner() root.add(c: c) root.add(c: subLeaf) c.execute() root.execute() Decorator The components and decorators are departed, we can add new components and decorators freely. And we can make different compositions(with different decorations) to be different products.\n组件模块和装饰器是分开的，我们可以自由地添加组件和装饰器。我们也可使用不同的组合形式（基于不同装饰方式），来得到不同的产品。\n// Base interface between classes. protocol Component { var text: String? { get set} func execute() } // Concrete Component class Bike: Component { var text: String? func execute() { text = \u0026#34;bike\u0026#34; } } // Concrete Component class Moto: Component { var text: String? func execute() { text = \u0026#34;moto\u0026#34; } } // Base Decorator class BaseDecorator: Component { var text: String? private var c: Component func execute() { c.execute() if let t = c.text { text = \u0026#34;\u0026lt;\u0026#34; + t + \u0026#34;\u0026gt;\u0026#34; // Here the text is the property of the current concrete decorator. } else { text = \u0026#34;\u0026lt;\u0026gt;\u0026#34; } } func getText() -\u0026gt; String { if let s = text { return s } else { return \u0026#34;\u0026#34; } } func setText(_ str: String?) { text = str } func getC() -\u0026gt; Component { return c } // inject an instance init(_ c: Component) { self.c = c } } // Concrete Decorator class PaintDecorator: BaseDecorator { override func execute() { super.execute() extra() } func extra() { let s = getText() setText(\u0026#34;(Paint)\\(s)(Paint)\u0026#34;) } } // Concrete Decorator class AttachTagDecorator: BaseDecorator { override func execute() { super.execute() extra() } func extra() { let s = getText() setText(\u0026#34;(Tag)\\(s)(Tag)\u0026#34;) } } let a = Bike() let tag = AttachTagDecorator(a) let paint = PaintDecorator(tag) paint.execute() // (Paint)\u0026lt;(Tag)\u0026lt;bike\u0026gt;(Tag)\u0026gt;(Paint) print(paint.getText()) let b = Moto() let bpaint = PaintDecorator(b) let bTag = AttachTagDecorator(bpaint) bTag.execute() // (Tag)\u0026lt;(Paint)\u0026lt;moto\u0026gt;(Paint)\u0026gt;(Tag) print(bTag.getText()) Facade The sub-system has many objects and we want to decoupling them with the client’s calling, so we set a class Facade and use its instance to interact with the sub-system. The Facade just like an inter-media.\n一个子系统有许多对象，而我们想要将这些对象与客户端调用解耦合，所以我们设置一个 “外观” 类，使用外观类的实例来与子系统交互。这个外观类实例就像一个处于中间的媒介。\n// Sub-System objects class VideoFile { } class BitwiseNot { } class CvtColor { } class Transformer { } // Facade class VideoConverter { func convert() -\u0026gt; File { var videoFile = VideoFile() var bitwiseNot = BitwiseNot() var cvtColor = CvtColor() var transformer = Transformer() var file = File() return file } } class File { } let converter = VideoConverter() var file = converter.convert() Flyweight The flyweight is to make the memory can load more objects. An object may have some properties that is repeating, and it take many memory space, we move these properties into another class(called Flyweight), and the original class just hold a reference of the Flyweight instance.\n享元可以使内存能加载更多的对象。一个对象可能会拥有一些重复的、占用空间大的属性，我们将这些属性移到另外的一个类中（这个类称为享元），然后原来的类就只是持有一个享元实例的引用。\n// Client class Game { var bullets: [Bullet] = [] var factory: Factory func creatBullet(_ count: Int) { for i in 0..\u0026lt;count { var b = Bullet(id: i, position: [Int.random(in: 0...20), Int.random(in: 0...20)], paint: factory.getBulletPaint(sign: BulletPaint.sign)) bullets.append(b) } } init() { factory = Factory() } } // Context class Bullet { var id: Int var position: [Int] = [0, 0] var paint: BulletPaint init(id: Int, position: [Int], paint: BulletPaint) { self.id = id self.position = position self.paint = paint } } // Flyweight class BulletPaint { var picture: String? static var sign = 0 func changePicture(picture: String) { self.picture = picture BulletPaint.sign += 1 } } // Flyweight Factory class Factory { private var stuff: [BulletPaint] = [] func getBulletPaint(sign: Int) -\u0026gt; BulletPaint { if stuff.count \u0026lt;= sign || stuff[sign] == nil { var paint = BulletPaint() stuff.append(paint) return paint } return stuff[sign] } } var game = Game() game.creatBullet(100) Proxy A class Proxy and a class Service both conform to the same protocol ServiceInterface, and Proxy want to give some of its method to done by Service, so Proxy just keep a reference of Service and call the Service when Proxy it want to solve some problem.\n一个名为 “代理” 的类和一个名为 “服务” 的类都遵守同一个名为 “服务接口” 的协议， 然后代理想要把它的一些方法交给服务去做，进而代理只是持有服务的一个引用，然后在需要解决问题的时候，调用代理来解决。\n// Service Interface protocol Work { func manageStuff() func dispatchSalary() } // Proxy class Boss: Work { var manager: Manager? init(manager: Manager) { } func manageStuff() { manager?.manageStuff() } func dispatchSalary() { manager?.dispatchSalary() } } // Service class Manager: Work { func manageStuff() { } func dispatchSalary() { } } let manager = Manager() let boss = Boss(manager: manager) boss.dispatchSalary() // In fact, it\u0026#39;s the manager whom dispatch the salary. Delegate We move some detail method from class A to class B (delegation), and the B can do some detail by the inputed A’s reference.\n我们 A 中实现具体功能的方法移动到 B 中，B 为受委托对象，B 中的方法都是需要输入一个 A 的引用，从而才能让 B 替 A 做一些具体且复杂的操作。相当于 A 把复杂的操作委派给 B 来完成。\nClass Game has a GameDelegation in it. Then input the Game instance to the Delegation instance, and the delegation can do some detailed work that may be previously done by the Game instance. So it‘s called delegate model.\n类 game 拥有一个 GameDelegation . 接着输入 Game 实例到 Delegation 的实例，这个委派者可以做一些本来应该由 Game 的实例来完成的细节的事情。这样的模式称为委派模式。\n// Delegation protocol Delegation { func gameDidStart(_ game: Game) func game(_ game: Game) func gameDidEnd(_ game: Game) } // Game protocol Game { var delegation: Delegation? { get set } func play() } // Concrete Deleagtion class SnakeTracker: Delegation { func gameDidStart(_ game: Game) { } func game(_ game: Game) { // do something } func gameDidEnd(_ game: Game) { } } // Concrete Game class SnakeGame: Game { var delegation: Delegation? init(_ delegation: Delegation) { self.delegation = delegation } func play() { delegation!.gameDidStart(self) delegation!.game(self) delegation!.gameDidEnd(self) } } let gameTracker = SnakeTracker() let game = SnakeGame(gameTracker) game.play() // It\u0026#39;s the func of the game, but the detail work is done by the delegation. Behavioral Chain of Responsibility We set a chain of responsibility. Then it t allow the solver solve the request or sends the request to the next another solver. As the diagram shown below, the handler is one solver of the chain.\n我们设定了一条责任链，然后它允许处理者选择处理请求或者将请求发送给下一个其它的处理者。下图中，handler 是责任链上的一个处理者。\n// Problem wait to be solve class Request { var priority: Int var s: String init(p: Int, s: String) { priority = p self.s = s } } // Handler protocol Thought { func solve(r: Request) } // Base handler class People: Thought { var next: People? func setNext(next: People) { self.next = next } func solve(r: Request) { if let n = next { n.solve(r: r) } else { print(\u0026#34;No people want to solve\u0026#34;) } } } // Concrete handler class Guard: People { override func solve(r: Request) { if r.priority \u0026lt; 2 { print(\u0026#34;Just be sovled by Guard [\\(r.s)]\u0026#34;) print(r.s) } else { super.solve(r: r) } } } // Concrete handler class Commander: People { override func solve(r: Request) { if r.priority \u0026lt; 4 { print(\u0026#34;Commander solve [\\(r.s)]\u0026#34;) } else { super.solve(r: r) } } } // Concrete handler class Leader: People { override func solve(r: Request) { if r.priority \u0026lt; 10 { print(\u0026#34;Leader come and solve [\\(r.s)]\u0026#34;) } else { super.solve(r: r) } } } let g = Guard() let c = Commander() let l = Leader() g.setNext(next: c) c.setNext(next: l) let r = Request(p: 9, s: \u0026#34;Let us in\u0026#34;) g.solve(r: r) Command Create receiver, then create command and link it to the receiver if needed, then create sender and link it to the specific command. The command mode extract the command from the business, and set a sender and receiver. The sender send message to receiver by calling the command, but not call the receiver directly.\n创建接收者，然后创建命令并且在有需要的时候把它连接到接收者，然后创建发送者并且把它连接到命令。命令模式从业务中抽出命令的部分，然后设置一个发送者和接收者。发送者通过调用命令向接受者发送信息，而不是直接调用接收者。\n// Message class TableInfo { var tableNo: Int? init(tableNo: Int) { self.tableNo = tableNo } } // Receiver class Cooker { func cookMeal(info: TableInfo) { print(\u0026#34;Cook meal for: \\(info.tableNo!)\u0026#34;) } func sayHello(info: TableInfo) { print(\u0026#34;Say hello to: \\(info.tableNo!)\u0026#34;) } func reheatFood(info: TableInfo) { print(\u0026#34;Reheat food for: \\(info.tableNo!)\u0026#34;) } } // Command protocol Command { func execute(info: TableInfo) } // Concrete Command class ServeCommand: Command { var cooker: Cooker? init(cooker: Cooker) { self.cooker = cooker } func execute(info: TableInfo) { cooker?.sayHello(info: info) cooker?.cookMeal(info: info) } } // Sender class Waiter { var command: Command init(command: Command) { self.command = command } func executeCommand(info: TableInfo) { self.command.execute(info: info) } } let cooker = Cooker() let command = ServeCommand(cooker: cooker) let waiter = Waiter(command: command) waiter.executeCommand(info: TableInfo(tableNo: 4)) // Print: // Say hello to: 4 // Cook meal for: 4 Iterator The idea of the iterator is to extract the traversal behavior into an independent iterator object. The collection has some elements, and we use the iterator to get each element step by step.\n迭代器的主要思想是将遍历行为抽取为单独的迭代器对象。\n// Element in the collection class Node { var info: String = \u0026#34;\u0026#34; init(_ s: String) { self.info = s } } // Iterator protocol Iterator { func hasNext() -\u0026gt; Bool func getNext() -\u0026gt; Node } // Concrete iterator class PositiveIterator: Iterator { var collection: Collection var curIndex = 0 init(_ c: Collection) { self.collection = c } func hasNext() -\u0026gt; Bool { if curIndex \u0026lt; collection.nodes.count { return true } else { return false } } func getNext() -\u0026gt; Node { var node = collection.nodes[curIndex] curIndex += 1 return node } } // Concrete iterator class RevertIerator: Iterator { var collection: Collection var curIndex = 0 init(_ c: Collection) { self.collection = c self.curIndex = collection.nodes.count - 1 } func hasNext() -\u0026gt; Bool { if curIndex \u0026gt;= 0{ return true } else { return false } } func getNext() -\u0026gt; Node { var node = collection.nodes[curIndex] curIndex -= 1 return node } } // Collection protocol Collection { var nodes: [Node] { get set } func getIterator() -\u0026gt; Iterator func getRevertIterator() -\u0026gt; Iterator } // Concrete collecton class NodesCollection: Collection { var nodes: [Node] init() { self.nodes = [] } func append(_ n: Node) { nodes.append(n) } func getIterator() -\u0026gt; Iterator { return PositiveIterator(self) } func getRevertIterator() -\u0026gt; Iterator { return RevertIerator(self) } } let str = \u0026#34;hello world\u0026#34; let collection = NodesCollection() for s in str { collection.append(Node(String(s))) } var it = collection.getIterator() while (it.hasNext()) { var n = it.getNext() print(n.info, terminator: \u0026#34; \u0026#34;) } print() it = collection.getRevertIterator() while (it.hasNext()) { var n = it.getNext() print(n.info, terminator: \u0026#34;_\u0026#34;) } Mediator The mediator constrains the interaction between the component, the components can only notify the mediator and the mediator can manage the action of all the components it contains.\n中介者限制了组件之间的交互，组件只能通知中介一些指令，然后中介者管理它内部拥有的所有组件的数据操作与行为。\n// Component basic class class Component { var m: Mediator init(mediator: Mediator) { self.m = mediator m.notify(component: self) } } // Concrete component class Button: Component { func click() { m.notify(component: self) } } // Concrete component class CheckBox: Component { var check = false func isCheck() -\u0026gt; Bool { return check } } // Concrete component class PasswordText: Component { var text: String = \u0026#34;\u0026#34; func getText() -\u0026gt; String{ return text } } // Concrete component class UserNameText: Component { var text: String = \u0026#34;\u0026#34; func getText() -\u0026gt; String{ return text } } protocol Mediator { func notify(component: Component) } // Concrete mediator class LoginMediator: Mediator { var btnLogin: Button? var tickSavePassword: CheckBox? var password: PasswordText? var userName: UserNameText? func notify(component: Component) { if component is Button { var btn = component as! Button if self.btnLogin == nil { // self btn initialize self.btnLogin = btn return } if (canLogin(userName: userName?.getText(), password: password?.getText())) { print(\u0026#34;Login success\u0026#34;) if let wantSave = tickSavePassword?.isCheck() { // save the userName and password } } else { print(\u0026#34;Login failed\u0026#34;) } } else if component is CheckBox { var box = component as! CheckBox self.tickSavePassword = box } else if component is UserNameText { var userName = component as! UserNameText self.userName = userName } else if component is PasswordText { var password = component as! PasswordText self.password = password } } } // The function check whether the username and password match func canLogin(userName: String?, password: String?) -\u0026gt; Bool { if userName == nil || password == nil { return false } if let name = userName, let word = password{ if name == \u0026#34;hello\u0026#34; \u0026amp;\u0026amp; word == \u0026#34;Mike\u0026#34; { return true } else { return false } } return false } let mediator = LoginMediator() let userName = UserNameText(mediator: mediator) let password = PasswordText(mediator: mediator) let tickSavePassword = CheckBox(mediator: mediator) let btnLogin = Button(mediator: mediator) userName.text = \u0026#34;hello\u0026#34; password.text = \u0026#34;Mike\u0026#34; tickSavePassword.check = true btnLogin.click() Memento It allow to save or recover the object state before without expose the object’s implemented detail. The originator can create the snapshot of itself and can restore the snapshot when it need. The memento is a value object of the originator’s snapshot state, it’s built by the initializer and pass the information by only one time. The caretaker can only use the originator’s makeMemento() and restore().\n它允许在不暴露对象实现细节的情况下，保存和恢复对象之前的状态。原发器可以创建它自己的快照并且在需要的时候恢复快照到自身。备忘录是一个用于存放原发器快照状态的值对象，它只通过构造函数传递状态信息。负责人只可以使用原发器的 “创建快照” 和 “恢复状态” 的方法。\n// Originator protocol Animal { func getMemento() -\u0026gt; Memento } // Memento protocol Memento { func restore() } // Concrete originator class Dog: Animal { private var age: Int private var weight: Float private var legCount: Int init(age: Int, weight: Float, legCount: Int) { self.age = age self.weight = weight self.legCount = legCount } func getMemento() -\u0026gt; Memento { return DogData(dog: self, age: age, weight: weight, legCount: legCount) } func setAge(age: Int) { self.age = age } func setWeight(weight: Float) { self.weight = weight } func setLegCount(legCount: Int) { self.legCount = legCount } func info() -\u0026gt; String { return \u0026#34;age: \\(age) weight: \\(weight) legCount: \\(legCount)\u0026#34; } } // Concrete memento class DogData: Memento { private var age: Int private var weight: Float private var legCount: Int private var dog: Dog? init(dog: Dog, age: Int, weight: Float, legCount: Int) { self.dog = dog self.age = age self.weight = weight self.legCount = legCount } func restore() { dog?.setAge(age: age) dog?.setWeight(weight: weight) dog?.setLegCount(legCount: legCount) } } // CareTaker class Recored { var dog: Dog var history: [Memento] = [] init(dog: Dog) { self.dog = dog } func save() { var backup = dog.getMemento() history.append(backup) if (history.count \u0026gt; 10) { history.remove(at: 0) } } func undo() { if history.count \u0026lt;= 0 { return } var data = history[history.count - 1] data.restore() history.remove(at: history.count - 1) } } let dog = Dog(age: 2, weight: 15, legCount: 4) let record = Recored(dog: dog) record.save() print(dog.info()) dog.setAge(age: 4) dog.setWeight(weight: 20) print(dog.info()) record.undo() print(dog.info()) Observer The publisher has some subscribers reference, it can add subscriber, remove subscriber, and notify all subscriber.\n发布者持有一些订阅者的引用，它可以添加订阅者，也可以移除订阅者，或者是通知所有的订阅者。\nclass Message { var text: String = \u0026#34;\u0026#34; init(_ m: String) { self.text = m } } class Event { var text: String = \u0026#34;\u0026#34; init(_ e: String) { self.text = e } } // Subscriber protocol Listener { func update(message: Message) } // Publisher protocol Publisher { func subscribe(event: Event, listener: Listener) func remove(event: Event) func notify(event: Event, message: Message) func notifyAll(message: Message) } // Concrete listener class ListenerA: Listener { func update(message: Message) { print(\u0026#34;A do: \\(message.text)\u0026#34;) } } // Concrete listener class ListenerB: Listener { func update(message: Message) { print(\u0026#34;B do: \\(message.text)\u0026#34;) } } // Concrete publisher class ViewPublisher: Publisher { var listeners: [String: Listener] = [:] func subscribe(event: Event, listener: Listener) { listeners[event.text] = listener } func remove(event: Event) { listeners.removeValue(forKey: event.text) } func notify(event: Event, message: Message) { listeners[event.text]?.update(message: message) } func notifyAll(message: Message) { for item in listeners.values { item.update(message: message) } } } let publisher = ViewPublisher() let a = ListenerA() let b = ListenerB() publisher.subscribe(event: Event(\u0026#34;look\u0026#34;), listener: a) publisher.subscribe(event: Event(\u0026#34;find\u0026#34;), listener: b) publisher.notify(event: Event(\u0026#34;look\u0026#34;), message: Message(\u0026#34;Firstly, welcome.\u0026#34;)) print() publisher.notifyAll(message: Message(\u0026#34;Hello world!\u0026#34;)) print() publisher.remove(event: Event(\u0026#34;look\u0026#34;)) publisher.notifyAll(message: Message(\u0026#34;The end.\u0026#34;)) State The state mode enable the class to change its behavior when its inner state changed. The StateContext only do the switch work, and the detail work is done by State object. The context manage the statements in a high level, it can switch some different state when we need. The context inject a reference to the concrete state object to enable the state to delegate the detail work. 状态模式中，当类的状态改变时，类的行为随着改变。状态上下文类只执行状态切换工作，具体的工作细节交给状态对象去执行。上下文对象在一个较高的层次管理着自身的状态，它可以在我们有需要的时候切换不同的状态。上下文对象注入了一个自己的引用给状态对象，使得状态对象可以代理在切换状态时候的细节工作。\n// Abstract state class State { var context: Context? var name: String = \u0026#34;\u0026#34; init(context: Context?) { self.context = context } } // Concrete state class NewState: State { override init(context: Context?) { super.init(context: context) self.name = \u0026#34;New\u0026#34; } func start() { print(\u0026#34;Call start\u0026#34;) if self.name == \u0026#34;New\u0026#34; { context?.setState(state: RunnableState(context: context)) } else { print(\u0026#34;Can\u0026#39;t go to runnable\u0026#34;) } } } // Concrete state class RunnableState: State { override init(context: Context?) { super.init(context: context) self.name = \u0026#34;Runnable\u0026#34; } func getCpu() { if self.name == \u0026#34;Runnable\u0026#34; { context?.setState(state: RunningState(context: context)) } else { print(\u0026#34;Can\u0026#39;t go to running\u0026#34;) } } } // Concrete state class RunningState: State { override init(context: Context?) { super.init(context: context) self.name = \u0026#34;Running\u0026#34; } func suspend() { if self.name == \u0026#34;Running\u0026#34; { context?.setState(state: BlockState(context: context)) } } func stop() { if self.name == \u0026#34;Running\u0026#34; { context?.setState(state: DeadState(context: context)) } } } // Concrete state class BlockState: State { override init(context: Context?) { super.init(context: context) self.name = \u0026#34;Block\u0026#34; } func resume() { if name == \u0026#34;Block\u0026#34; { context?.setState(state: RunnableState(context: context)) } } } // Concrete state class DeadState: State { override init(context: Context?) { super.init(context: context) self.name = \u0026#34;Dead\u0026#34; } } // Thread Context class Context { private var state: State? init() { self.state = NewState(context: self) } func setState(state: State) { self.state = state } func getState() -\u0026gt; State? { return self.state } func start() { if let s = self.state as? NewState { s.start() } } func suspend() { if let s = self.state as? RunningState { s.suspend() } } func resume() { if let s = self.state as? BlockState { s.resume() } } func getCpu() { if let s = self.state as? RunnableState { s.getCpu() // It will switch to the running state. } } func stop() { if let s = self.state as? RunningState { s.stop() } } } let context = Context() context.start() // It will be runnable then. context.getCpu() // It will be running then. context.suspend() // It will be blocked then. context.resume() // It will be runnable then. context.getCpu() // It will be running then. context.stop() // It will be dead then. Strategy Strategy mode set some solution class, and each solution can be substituted by other solution easily. When we face different problem, we choose different solution to solve problem. The Problem class hold a reference of Strategy interface to use different strategy. 策略模式设定了一些算法类，每个算法类可以被其它算法类所替换。当我们面对不同的问题时，我们选择不同的策略来解决问题。“问题” 类持有 “策略”接口， 以便使用不同的策略。\nprotocol Strategy { func sort(_ nums: inout [Int]) -\u0026gt; [Int] } // Strategy A class SelectedSort: Strategy { func sort(_ nums: inout [Int]) -\u0026gt; [Int] { print(\u0026#34;Selected sort\u0026#34;) var len = nums.count if len \u0026lt;= 1 { return nums } for i in 0..\u0026lt;len { var minIndex = i for j in (i + 1)..\u0026lt;len { if nums[j] \u0026lt; nums[minIndex] { minIndex = j } } var tmp = nums[i] nums[i] = nums[minIndex] nums[minIndex] = tmp } return nums } } // Strategy B class InsertSort: Strategy { func sort(_ nums: inout [Int]) -\u0026gt; [Int] { print(\u0026#34;Insert sort\u0026#34;) var len = nums.count if len \u0026lt;= 1 { return nums } for i in 1..\u0026lt;len { var left = i - 1 while true { if left \u0026lt; 0 || nums[i] \u0026gt; nums[left] { var cover = i - 1 var t = nums[i] while cover \u0026gt; left { nums[cover + 1] = nums[cover] cover -= 1 } nums[left + 1] = t break } else { left -= 1 } } } return nums } } class Problem { private var strategy: Strategy init(strategy: Strategy) { self.strategy = strategy } func solve(_ nums: inout [Int]) -\u0026gt; [Int] { strategy.sort(\u0026amp;nums) } func changeStrategy(strategy: Strategy) { self.strategy = strategy } } var nums = [2, 6, 1, 5, 0, 3] var a = SelectedSort() var b = InsertSort() var problem = Problem(strategy: a) problem.solve(\u0026amp;nums) print(nums) nums.shuffle() print(nums) problem.changeStrategy(strategy: b) problem.solve(\u0026amp;nums) print(nums) Template Method The super class define an algorithm structure, and the subclass can override the method without changing the structure. Depart an algorithm into a series of step, and rewrite these step as method, then call these method in the template method.\n超类定义了一个算法框架，子类可以在不改动框架的情况下依据需要来重写方法。把算法拆分为一系列的步骤，把这些步骤写成方法，然后可以在模板方法中调用这些方法。\n// Abstract class class House { // Use final to prevent the subclass override the template method. final func build(){ makeRoot() makeWall() makeWindows() makeRoof() } func makeRoot() { print(\u0026#34;Use cement to construct root.\u0026#34;) } func makeWall() { print(\u0026#34;Add white wall\u0026#34;) } func makeWindows() { print(\u0026#34;Add window\u0026#34;) } func makeRoof() { print(\u0026#34;Add smooth roof\u0026#34;) } } // Concrete class A class EastenHouse: House { override func makeWall() { print(\u0026#34;Add red wall.\u0026#34;) } override func makeWindows() { print(\u0026#34;Add wooden windows.\u0026#34;) } override func makeRoof() { print(\u0026#34;Add wooden roof.\u0026#34;) } } // Concrete class B class WestenHouse: House { override func makeWindows() { print(\u0026#34;Add iron windows\u0026#34;) } override func makeRoof() { print(\u0026#34;Add cement roof\u0026#34;) } } let house = EastenHouse() house.build() let houseB = WestenHouse() houseB.build() Visitor Visitor mode can isolate the algorithm and the object which algorithm affect. (Depart the server and the visitor). It put the new behaviors into a Visitor class, then pass the existed object’s reference to the visitor to do the behaviors. It just visit the data of the object, but not change the original data.\n访问者模式可以隔离算法和被这个算法影响的对象（分离服务者和访问者）。它将新的行为放置在一个称为 “访问者” 的对象中，然后传递原有对象的引用来执行一些行为。它只是访问对象数据，而没有改变源数据。\nprotocol Visitor { func visit(d: Dog) func visit(c: Cat) func visit(h: Horse) } protocol Element { func accept(v: Visitor) } // Element A class Dog: Element { var name = \u0026#34;dog\u0026#34; var age = 0 func accept(v: Visitor) { v.visit(d: self) } } // Element B class Cat: Element { var name = \u0026#34;cat\u0026#34; var age = 1 func accept(v: Visitor) { v.visit(c: self) } } // Element C class Horse: Element { var name = \u0026#34;horse\u0026#34; var age = 2 func accept(v: Visitor) { v.visit(h: self) } } // Visitor 1 class NameVisitor: Visitor { func visit(d: Dog) { print(d.name) } func visit(c: Cat) { print(c.name) } func visit(h: Horse) { print(h.name) } } // Visitor 2 class AgeVisitor: Visitor { func visit(d: Dog) { print(\u0026#34;Dog age: \\(d.age)\u0026#34;) } func visit(c: Cat) { print(\u0026#34;Cat age: \\(c.age)\u0026#34;) } func visit(h: Horse) { print(\u0026#34;Horse age: \\(h.age)\u0026#34;) } } let dog = Dog() let cat = Cat() let horse = Horse() let nameVisitor = NameVisitor() let ageVisitor = AgeVisitor() dog.accept(v: nameVisitor) cat.accept(v: nameVisitor) horse.accept(v: nameVisitor) dog.accept(v: ageVisitor) cat.accept(v: ageVisitor) horse.accept(v: ageVisitor) 模式的特征与区别 结构型 适配器模式的目的是为了让类 A 去模仿类 B，从而在需要类 B 的地方可以直接使用类 A 替代，适配器C既具有 B 的属性，又看起来像是 B （因为适配器继承自类 B） 桥接模式是具体的类 A 中具有抽象接口 B，构造 A 的时候注入一个 B 的实体对象，那么可以在使用对象 A 的时候，可以调用接口 B 来实现对应功能，这样的类 A 是依赖于接口而不是具体的类。 桥接模式是两个类 A 与 B 之间，使用一个接口，由 B 实现， 注入 A。 组合模式是组件模块与容器（抽象接口）都实现同一接口，容器里面可以持有多个接口实例（由组件模块实例来注入），形成树状结构。 装饰器模式是组件与装饰器（抽象接口）都实现同一接口，装饰器里面持有一个接口实例（由组件模块实例来注入）， 装饰器对持有的实例添加附带功能。 委托模式（delegate）是让一个对象扮演另外一个对象的行为。委托对象暂时持有到另外对象的引用。在适当时间发消息给另外对象。 代理模式（proxy）比委托更为严格，若干对象实现同一接口。 行为型 责任链模式（chain of responsibility）模式中的每一个对象持有指向另一对象的引用 A（用于转移责任），询问当前对象，当前对象若有能力处理事务则处理，若没有能力处理事务则把事务移交给另外一个对象（引用 A 所指）处理。\n命令模式（command) 发送者和接收者使用命令进行间接沟通，常用于视图和控制器的分离（视图为发送者，控制器为接收者）。若与责任链结合，则为命令在传递给接收者的时候，是传递到接收者链上，从而寻求潜在的接收者。\n中介者模式（mediator）设置一个中介者来管理那些来自组件的调用，中介者拥有各个组件的引用，站在更高的层次上对组件进行管理。组件之间通过中介者来发生交互，而不是组件之间进行耦合。\n备忘录模式（memento），为原发器添加一个备忘录对象用于存放原发器的的状态信息，使用一个负责人对象来管理备忘录的增加与回滚，可以对原发器的版本进行控制。\n观察者模式（observer），发布者持有多个订阅者的引用，当有需要发布新消息时，准确地向每个订阅者发送信息。\n中介者和观察者很像，但是，中介者主要功能是消除一系列的组件之间的依赖，用于管理组件之间的调用，而观察者强调的是发布者向各个订阅的订阅者分发信息。\n状态模式（状态模式）与策略模式（strategy）关键区别：\n状态模式中的特定状态知道其它状态的存在，能从一个状态转移到另一状态。\n策略模式中某个策略不知道其它策略的存在。\n模版方法（template method) 中，超类定义了若干模板框架方法（固定的）和步骤方法，子类不能修改框架方法，只能重写步骤方法。模板方法中可以调用详细的步骤方法。工厂模式是模版方法的特殊形式。\n访问者（visitor) 将操作交给其它的类（访问者类），允许访问者进行访问。它是命令模式的加强版本。访问者模式中，业务在需要使用访问服务的时候，传递自己的引用给访问者，而代理模式和委托模式是将自身引用注入到受托付到对象中，移交自己的权利。\n","permalink":"https://wowios.com/post/design-pattern/all-design-pattern/","summary":"\u003ch2 id=\"creational\"\u003eCreational\u003c/h2\u003e\n\u003cp\u003eObject Created Pattern\u003c/p\u003e\n\u003ch3 id=\"factory-method\"\u003eFactory Method\u003c/h3\u003e\n\u003cp\u003eProvide the method for creating an instance in the superclass, and allow the subclass to choose the type of the instance.\u003c/p\u003e\n\u003cp\u003e在父类中提供创建对象的方法，允许子类决定实例化对象的类型。\u003c/p\u003e\n\u003cp\u003e具备的部分：生产者协议、产品协议，往后就可以根据需要来扩展每一种产品。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"factory\" loading=\"lazy\" src=\"../imgs/factory.png\"\u003e\u003c/p\u003e\n\u003cp\u003e具体的生产者比如 \u003ccode\u003eMongoCakeCreator\u003c/code\u003e 的存在是为了实现与产品相关的核心业务逻辑，而不仅仅是创建 \u003ccode\u003eMongoCake\u003c/code\u003e 实例。工厂方法将核心业务逻辑从具体产品类中分离出来。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// Creator\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eprotocol\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eCakeCreator\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecreateCake\u003c/span\u003e() -\u0026gt; Cake\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edoSomethingForCake\u003c/span\u003e(cake: Cake) -\u0026gt; Cake\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// Product\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eprotocol\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eCake\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edoWork\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// ConcreteCreator\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMongoCakeCreator\u003c/span\u003e: CakeCreator {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e cake: MongoCake?\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecreateCake\u003c/span\u003e() -\u0026gt; Cake {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e cake = MongoCake()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            doSomethingForCake(cake: cake)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e cake\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edoSomethingForCake\u003c/span\u003e(cake: Cake) -\u0026gt; Cake{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            cake.doWork()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            cake.doWork()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e cake\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// ConcreteCreator\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eChocolateCakeCreator\u003c/span\u003e: CakeCreator {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecreateCake\u003c/span\u003e() -\u0026gt; Cake {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e cake = ChocolateCake()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            doSomethingForCake(cake: cake)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e cake\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edoSomethingForCake\u003c/span\u003e(cake: Cake) -\u0026gt; Cake{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            cake.doWork()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e cake\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMongoCake\u003c/span\u003e: Cake {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edoWork\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Add some mongo\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eChocolateCake\u003c/span\u003e: Cake {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edoWork\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Add some chocolate\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// If we want to add a type of cake call \u0026#34;PinapleCake\u0026#34;, just need to \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// make it conform to Cake and add a creator that conform to the CakeCreator for the \u0026#34;PinapleCake\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e cakeOne = MongoCakeCreator().createCake()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"abstract-factory\"\u003eAbstract Factory\u003c/h3\u003e\n\u003cp\u003eBase on the factory method, add an abstract factory. We can call the same abstract factory method to create different mode’s product. If we want to create another mode’s product, we need to change the concrete factory.\u003c/p\u003e","title":"各种设计模式"},{"content":"Hey\n","permalink":"https://wowios.com/home/","summary":"\u003cp\u003eHey\u003c/p\u003e","title":"home"},{"content":"Unlike arithmetic operators in C, arithmetic operators in Swift don’t overflow by default. If want to overflow by default, use the overflow operation begin with ampersand (\u0026amp;). For example, the overflow addition operator (\u0026amp;+).\nIt’s so free to define custom infix, prefix, postfix and assignment operators, precedence and associativity values.\nBitwise Operators Here we use a function to pad 0 for the number’s print result.\nfunc pad(num: UInt8, count: Int) -\u0026gt; String { var str = String(num, radix: 2) var res: String = str for _ in 0..\u0026lt;(count - str.count) { res = \u0026#34;0\u0026#34; + res } return res } ~ NOT\n~1 is 0\n~0 is 1\n\u0026amp; AND\n1 \u0026amp; 1 is 1\n1 \u0026amp; 0 is 0\n0 * 0 is 0\n| OR\n1 | 1 is 1\n1 | 0 is 1\n0 | 0 is 0\n^ XOR\n1 ^ 1 is 0\n1 ^ 0 is 1\n0 ^ 0 is 0\nBitwise NOT Operator Use ~ to do NOT operation.\nvar a: UInt8 = 0b11111100 var b = ~a print(pad(num: b, count: 8)) // 00000011 UInt8 has 8 bits, and can store 0 to 255.\nBitwise AND Operator Use \u0026amp; to do AND operation.\nlet a: UInt8 = 0b11111100 let b: UInt8 = 0b00011010 let c = a \u0026amp; b print(pad(num: c, count: 8)) // 00011000 Bitwise OR Operator Use | to do OR operator.\nlet a: UInt8 = 0b11111100 let b: UInt8 = 0b00011010 let c = a | b print(pad(num: c, count: 8)) // 11111110 Bitwise XOR Operator Return a new number whose bits are set to 1 where the input bits are different and are set to 0 where the input bits are the same.\nlet a: UInt8 = 0b11111100 let b: UInt8 = 0b00011010 let c = a ^ b print(pad(num: c, count: 8)) // 11100110 Bitwise Left and Right Shift Operators Left shift (\u0026lt;\u0026lt;) move all bits in a number to the left.\nlet a: UInt8 = 0b00111100 let b = a \u0026lt;\u0026lt; 1 let c = a \u0026lt;\u0026lt; 2 print(pad(num: b, count: 8)) // 01111000 print(pad(num: c, count: 8)) // 11110000 Shifting of the Unsigned Integer It will place an zero at the left when right shift, and place an zero at the right when left shift.\nRight shift (\u0026gt;\u0026gt;) move all bits in a number to the right.\nlet a: UInt8 = 0b00111100 let b = a \u0026gt;\u0026gt; 1 let c = a \u0026gt;\u0026gt; 2 print(pad(num: b, count: 8)) // 00011110 print(pad(num: c, count: 8)) // 00001111 Use bit shifting to encode and decode values within other data types:\nlet pink: UInt32 = 0xCC6699 let redComponent = (pink \u0026amp; 0xFF0000) \u0026gt;\u0026gt; 16 let greenComponent = (pink \u0026amp; 0x00FF00) \u0026gt;\u0026gt; 8 let blueComponent = pink \u0026amp; 0x0000FF print(String(redComponent, radix: 16)) // cc print(String(greenComponent, radix: 16)) // 66 print(String(blueComponent, radix: 16)) // 99 // By AND operation and shifting, we get the three part of the \u0026#34;pink\u0026#34; color: R G B The CSS color value #CC6699 is written as 0xCC6699 in Swift’s hexadecimal number representation.\nShifting Behavior for Signed Integer In the 8-bit signed integer example:\nSigned Integer use its first bit to indicate whether the integer is positive or negative. (0 is positive, 1 is negative)\n00000100 is 4\n11111100 is -4, the first bit 1 indicate that the integer is negative, and the remain 7 bits is 124 means that 128 - 124 = -4\nSo the signed 8-bits can represent -128(10000000) to 127(01111111).\nTwo’s Complement Representation\nThe way it’s encoded above is known as a two’s complement representation. In this way it has several advantage.\nAdd -4 and -1, it add in binary rule and discard anything that overflow.\n(-4) + (-1) = 11\n11111100 + 11111111 = 11111011\narithmetic shift\nleft shift: an arithmetic shift = a logical shift. It will doubling the number.\nright shift: when shift signed integers to the right, apply same rules as for unsigned integers, but fill any empty bits on the left with the sign bit, rather than with a zero.\n11111110 \u0026gt;\u0026gt; 1 will be 11111111 01111110 \u0026gt;\u0026gt; 1 will be 00111111 In this way it ensures that the number will has the same sign after shifting. The shift will moves both positive and negative numbers closer to zero.\nOverflow Operators When the constant or variable can’t hold the value that too large or too small, Swift will raise an error.\n// The num get the max value of Int8 var num = Int8.max num += 1 // Here will a runtime-error. If we specifically want an overflow condition to truncate the number of available bits, we can use the overflow operators that begin with an ampersand (\u0026amp;).\nOverflow addition (\u0026amp;+) Overflow subtraction (\u0026amp;-) Overflow multiplication (\u0026amp;*) Value Overflow If we allow the number to overflow, it may overflows in both positive and negative direction.\nvar num: UInt8 = UInt8.max // It\u0026#39;s 11111111 (255) num = num \u0026amp;+ 2 print(pad(num: num, count: 8)) // 00000001 var n: UInt8 = 1 n = n \u0026amp;- 2 print(pad(num: n, count: 8)) // 11111111 The overflow operation can be apply to signed integer.\nvar signedNum: Int8 = Int8.min // -128 signedNum = signedNum \u0026amp;- 1 print(String(signedNum, radix: 2)) // 127 Precedence and Associativity From high to low:\n% / let a = 2 + 3 % 4 * 5 print(a) // 17 Left associative: calculate from left to right.\n/ % \u0026amp; \u0026amp;* | ^ \u0026amp;+ \u0026amp;- is as as? as! \u0026amp;\u0026amp; .\u0026amp; || .| .^ Right associative: calculate from right to left.\n?? :? = *= /= %= += -= \u0026laquo;= =\n\u0026amp;= |= ^= \u0026amp;*= \u0026amp;+= \u0026amp;-= \u0026amp;\u0026raquo;= \u0026amp;\u0026laquo;= .\u0026amp;= .|= .^= Isn’t associative:\n\u0026laquo; \u0026amp;\u0026laquo; \u0026amp;\u0026raquo; \u0026lt; \u0026lt;= =\n== != === !== ~= .\u0026lt; .\u0026lt;= .\u0026gt; .\u0026gt;= .== .!= ..\u0026lt; … Operator Methods Classes and structures can overloading the existing operators.\nstruct Vector2D { var x = 0.0, y = 0.0 } extension Vector2D { static func + (left: Vector2D, right: Vector2D) -\u0026gt; Vector2D{ return Vector2D(x: left.x + right.x, y: left.y + right.y) } } var a = Vector2D(x: 1.0, y: 2.0) var b = Vector2D(x: 3.0, y: 3.0) var c = a + b print(c) // Vector2D(x: 4.0, y: 5.0) Prefix and Postfix Operators extension Vector2D { static prefix func - (vector: Vector2D) -\u0026gt; Vector2D { return Vector2D(x: -vector.x, y: -vector.y) } } var x = Vector2D(x: 1.0, y: 2.0) var xx = -x print(xx) // Vector2D(x: -1.0, y: -2.0) Compound Assignment Operators +=\nextension Vector2D { static func += (left: inout Vector2D, right: Vector2D){ left = left + right } } var v = Vector2D(x: 1.0, y: 2.0) var w = Vector2D(x: 4.0, y: -3.0) v += w print(v) // Vector2D(x: 5.0, y: -1.0) Equivalence Operators ==\nOne way to make == be valid for enumeration or structure: Conform to the Equalble , it has provided method to do that.\nextension Vector2D: Equatable { } var one = Vector2D(x: 1.0, y: 2.0) var two = Vector2D(x: 1.0, y: 2.0) print(one == two) // true Another way is to implement the method in the extension.\nextension Vector2D: Equatable { static func == (left: Vector2D, right: Vector2D) -\u0026gt; Bool { return (left.x == right.x) \u0026amp;\u0026amp; (left.y == right.y) } } var one = Vector2D(x: 1.0, y: 2.0) var two = Vector2D(x: 1.0, y: 2.0) print(one == two) // true Custom Operators Prefix operator\nprefix operator +++ extension Vector2D { static prefix func +++ (vector: inout Vector2D) -\u0026gt; Vector2D { vector += vector return vector } } var some = Vector2D(x: 1.0, y: 2.0) +++some print(some) // Vector2D(x: 2.0, y: 4.0) Precedence for Custom Infix Operators Here we define a new custom infix operator call +-, which belongs to the precedence group AdditionPrecedence.\ninfix operator +-: AdditionPrecedence exthe tension Vector2D { static func +- (left: Vector2D, right: Vector2D) -\u0026gt; Vector2D{ return Vector2D(x: left.x + right.x, y: left.y - right.y) } } var a = Vector2D(x: 1.0, y: 2.0) var b = Vector2D(x: 2.0, y: 3.0) var c = a +- b print(c) // Vector2D(x: 3.0, y: -1.0) Don’t need to specify a precedence when defining a prefix or postfix operator. When apply both prefix and postfix to the same operand, the postfix operator is applied first.\nResult Builders If the code without result builder:\nprotocol Drawable { func draw() -\u0026gt; String } struct Line: Drawable { var elements: [Drawable] func draw() -\u0026gt; String{ return elements.map { $0.draw() }.joined(separator: \u0026#34;\u0026#34;) } } struct Text: Drawable { var content: String init(_ content: String) { self.content = content } func draw() -\u0026gt; String { return content } } struct Space: Drawable { func draw() -\u0026gt; String { return \u0026#34; \u0026#34; } } struct Star: Drawable { var length: Int func draw() -\u0026gt; String { return String(repeating: \u0026#34;*\u0026#34;, count: length) } } struct AllCaps: Drawable { var content: Drawable func draw() -\u0026gt; String { return content.draw().uppercased() } } let name: String? = \u0026#34;Mike\u0026#34; let drawing = Line(elements: [ Star(length: 3), Text(\u0026#34;Hello\u0026#34;), Space(), AllCaps(content: Text((name ?? \u0026#34;World\u0026#34;) + \u0026#34;!\u0026#34;)), Star(length: 3) ]) print(drawing.draw()) // ***Hello MIKE!*** The content in the AllCaps is awkward, if the content is complex, and have some extra conditions, it’s hard to write.\nSo we use the result builder to solve this problem.\n@resultBuilder struct DrawingBuilder { // It combines several components into a line static func buildBlock(_ components: Drawable...) -\u0026gt; Drawable{ return Line(elements: components) } static func buildEither(first: Drawable) -\u0026gt; Drawable{ return first } static func buildEither(second: Drawable) -\u0026gt; Drawable { return second } } func draw(@DrawingBuilder content: () -\u0026gt; Drawable) -\u0026gt; Drawable { return content() } func caps(@DrawingBuilder content: () -\u0026gt; Drawable) -\u0026gt; Drawable { return AllCaps(content: content()) } func makeGreeting(for name: String? = nil) -\u0026gt; Drawable { let greeting = draw { Star(length: 3) Text(\u0026#34;Hello\u0026#34;) Space() caps { if let name = name { Text(name + \u0026#34;!\u0026#34;) } else { Text(\u0026#34;World!\u0026#34;) } } Star(length: 2) } return greeting } let p = makeGreeting() print(p.draw()) // ***Hello WORLD!** let s = makeGreeting(for: \u0026#34;Amy\u0026#34;) print(s.draw()) // ***Hello AMY!** The Swift will transform the call to caps(_: ) into code like this:\nlet capsDrawing = caps { let partialDrawing: Drawable if let name = name { let text = Text(name + \u0026#34;!\u0026#34;) partialDrawing = DrawingBuilder.buildEither(first: text) } else { let text = Text(\u0026#34;World!\u0026#34;) partialDrawing = DrawingBuilder.buildEither(second: text) } return partialDrawing } Add support for writing for loops\nextension DrawingBuilder { static func buildArray(_ components: [Drawable]) -\u0026gt; Drawable { return Line(elements: components) } } let manyStars = draw { Text(\u0026#34;Stars:\u0026#34;) for length in 1...3 { Space() Stars(length: length) } } The result builder makes it easier and neater to organize the function blocks.\n","permalink":"https://wowios.com/post/language/swift/28advanced-operators/","summary":"\u003cp\u003eUnlike arithmetic operators in C, arithmetic operators in Swift don’t overflow by default. If want to overflow by default, use the overflow operation begin with ampersand (\u003ccode\u003e\u0026amp;\u003c/code\u003e). For example, the overflow addition operator (\u003ccode\u003e\u0026amp;+\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eIt’s so free to define custom infix, prefix, postfix and assignment operators, precedence and associativity values.\u003c/p\u003e\n\u003ch2 id=\"bitwise-operators\"\u003eBitwise Operators\u003c/h2\u003e\n\u003cp\u003eHere we use a function to pad 0 for the number’s print result.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epad\u003c/span\u003e(num: UInt8, count: Int) -\u0026gt; String {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e str = String(num, radix: \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e res: String = str\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003e_\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0.\u003c/span\u003e.\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e(count \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e str.count) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        res = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;0\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e res\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e  res\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e~\u003c/code\u003e NOT\u003c/p\u003e","title":"Advanced Operators"},{"content":"Access control restrict access to part of the code form code in other source files and modules. It enable us to hide the implement detail of the code, and to specify a preferred interface which that code can be accessed and used.\nSet access levels to individual types (classes, structures, enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types.\nProtocols can be restricted to a certain context, as can global constants, variable, and functions.\nWhen writing a single-target App, it has no need to specify explicit access control level at all.\nModules and Source Files Access control model is based on the concept of modules and source files.\nA module is single unit of code distribution (a framework or ) that can be imported by another module with import keyword.\nEach build target (app bundle or framework) is a separate module in Swift.\nIf an app’s code is grouped together as a stand-alone framework, everything in it will be part of a separate module.\nA source file always contains definition for multiple types, functions, and so on.\nAccess Levels Swift provides five access level for entities. These access levels are relative to the source file in which entity is defined, and also relative to the module that source file belongs to.\nOpen access and public access enable entities to be use within any source file from their defining module, and also in a source file from another module that imports the defining module. Internal access enables entities to be used within any source file from their defining, but not in any file outside of that module. File-private access restricts the use of an entity to its own defining source file. Private access restricts the use of an entity to the enclosing declaration, and extensions of that declaration that are in the same file. Open access only applies to classes and class members. It allows code outside the module to subclass and override, but public access can’t. Making a class as open indicate that using the class from other modules as a superclass.\nGuiding Principle of Access Levels No entity can be define in terms of another entity that has a lower(more restrictive) access level.\nA public variable can’t be defined as having an internal, file-private, or private type, because the type might not be available everywhere that the public variable is used. (higher access level can’t contain lower level in the variable) A function can’t have a higher access level than its parameter types and return type. Default Access Levels All entities have a default access level of internal, so in many case we don’t need to specify an explicit access level.\nAccess Level for Single-Target Apps The code in an app is self-contained and doesn’t need to be made available outside of the app’s module. The default internal already matches this requirement. And we can mark some part as file private or private to hide their implementation detail from other code within the app’s module.\nAccess Levels for Framework Use default access level of internal to hide the implementation, or marked as private or file private makes the framework’s code hidden\nAccess Levels for Unit Test Targets By default, only open or public can be access in other module. However, a unit test target can access any internal entity if use the attribute @testable to mark the import declaration.\nAccess Control Syntax public class SomePublicClass {} internal class SomeInternalClass {} fileprivate class SomeFilePrivateClass {} private class SomePrivateClass {} public var somePublicVariable = 0 internal let someInternalConstant = 0 fileprivate func someFilePrivateFunction() {} private func somePrivateFunction() {} class dog {} // implicitly internal let var a = 0 // implicitly internal Custom types public var name = \u0026#34;default\u0026#34; // explicitly public var age = 0 // implicitly internal fileprivate func run() {} // explicitly file-private private func eat() {} // explicitly private } class Cat { // implicitly internal var name = \u0026#34;\u0026#34; // implicitly internal fileprivate func sit() {} // explicitly file-private private func sleep() {} // explicitly private } fileprivate class Bear { // explicitly file-private func climb() {} // implicitly file-private private func stand() {} // explicitly private } private class Snake { // explicitly private func eat() {} // implicitly private } Tuple Types When compound tuple, it will get the minimum access level.\nIf we compound two tuple type, one with internal access and one with private access, the result will be private. A tuple type’s access level is determined automatically from the types that make up the tuple type, and can’t be specified explicitly.\nFunction Types The function’s access level must matches the access level of the return type.\nHere the tuple has the minimum access level (private), so the function should be marked as private.\nprivate func someFunc() -\u0026gt; (SomeInternalClass, SomePrivateClass) { } Enumeration Types Each cases will automatically receive the same access level as the enumeration it belongs to.\npublic enum Direction { case north // public case south // public case east case west } Raw values and associated values must have an access level at least as high as the enumeration’s level.\nThe access level of a nested type is the same as its containing type, unless the containing type is public (Nested type define within a public type have an automatic access level of internal implicitly).\nSubclassing A subclass can’t have higher access level than its superclass.\nFor classes that are defined in the same module, we can override any class member.\nFor classes that are defined in another module, we can override any open class member.\nAn override can make an inherited class member more accessible than its superclass version.\npublic class A { fileprivate func someMethod() { } } public class B: A { override internal func someMethod() { super.someMethod() // Because superclass A and subclass B are defined in the same source file, it\u0026#39;s valid for the method in B to call super.someMethod. } } It’s valid for a subclass member to call a superclass member that has lower access permission than the subclass member, as long as the call to the superclass’s member has the allowed access level context.\npublic class A { fileprivate func someMethod() { } } public class B: A { override internal func someMethod() { super.someMethod() } } // They are in the same source file, so the \u0026#34;B\u0026#34; can call the file-private method from the \u0026#34;A\u0026#34;. Constants, Variables, Properties, and Subscripts A private type can’t contain a property has more public access level.\nFor example, if a constant, variable, property, or subscript makes use of a private type, the constant, variable, property or subscript must also be marked as private:\nprivate var privateInstance = SomePrivateClass() Getters and Setters It automatically receive the same access level from the constant, variable, property, or subscript that it belongs to.\nAnd the setter and getter can be marked with a lower access level than the access level that get from the upper context. Use fileprivate(set), private(set), and internal(set) to mark a lower access level for the setter.\nstruct Track { private(set) var number = 0 // the setter can only be used inside the current structure. var value: String = \u0026#34;\u0026#34; { didSet { number += 1 } } } var track = Track() track.value = \u0026#34;I \u0026#34; track.value += \u0026#34;read \u0026#34; track.value += \u0026#34;books.\u0026#34; print(\u0026#34;Modify times: \\(track.number) String: \\(track.value)\u0026#34;) // Print: // Modify times: 3 String: I read books. Initializers Custom initializers can be assigned an access level less than or equal to the type that they initialize. However, A required initializer must have the same access level as the class it belongs to.\nThe type of an initializer’s parameters can’t be more private than the initializer’s own access level.\nDefault Initializers A default initializer has the same access level as the type it initializes, unless that type is public. If the type is public, the default initializer will be internal as default.\nfileprivate class Dog { // It\u0026#39;s default initializer is fileprivate var name: String? } fileprivate var dog = Dog() public class Cat { // It\u0026#39;s default initializer\u0026#39;s access level is internal var name: String? } var cat = Cat() If we want a no-argument initializer (in public type) be used in another module, we must explicitly provide a public no-argument initializer in the type definition. Because the init() will be internal in default.\npublic class Cat { internal var name: String? public init() { } } Default Member-wise Initializers for Structure Type Once the structure’s stored properties are private, the structure type will be considered as private. Likewise, The file-private has the same situation.\nAs with the default initializer above, if the structure is public, the initializer of it is internal in default. So if we want to use the no-argument initializer in other modules, we must write the The public init() implementation explicitly.\nProtocol The requirement in the protocol keep a same access level as the protocol.\nWe can’t set a protocol requirement to a different access level than the protocol it support. This ensures that all of the protocol’s requirement will be visible on any type that adopts the protocol.\nIf we define a public protocol, the protocol’s requirements require a public access level for those requirements when they’re implemented.\nProtocol Inheritance The sub-protocol have at most the same access level as the the super-protocol. For example a public protocol can’t inherit from an internal protocol.\nProtocol Conformance A type can conform a protocol with a lower access level than the type itself.\nFor example, if a type is public, but a protocol it conforms is internal, the type’s conformance to that protocol is also internal. And the type’s implementation of each protocol requirement must be at least internal.\nIf the protocol is with a private, the implementation should be at least file-private.\nprivate protocol Action { func run() func eat() } public class Pig: Action { // It\u0026#39;s not allowed, it must be declared as file-private because it matches a requirement in private. private func run() { print(\u0026#34;run\u0026#34;) } // It\u0026#39;s OK to mark it as fileprivate. fileprivate func eat() { print(\u0026#34;eat\u0026#34;) } } public class Goat: Action { // It\u0026#39;s internal in default func run() { } // Marked as public explicitly. public func eat() { } } Extensions If the extension extends a public or internal type, any new member in the extension will be an internal access level in default.\nIf the extension extends a file-private type, any new member in the extension will be a file-private access level in default.\nAlternatively, we can mark the extension with an access level to let the member inside extension to have new access level.\n// It can only accessed from the same file. fileprivate class Shape { var width: Int? var height: Int? } // It will be can only accessed inside the current context. private extension Shape { var area: Int { if let x = width , let y = height { return x * y } else { return 0 } } } We can’t provide an explicit access-level modifier for an extension if we’re using that extension to add protocol conformance.\n// It\u0026#39;s with internal access level in default.s protocol Calculator { func calcuArea() -\u0026gt; Int } fileprivate class Shape { var width: Int? var height: Int? } // Here the extension can\u0026#39;t explicit access-level modifier. extension Shape: Calculator{ func calcuArea() -\u0026gt; Int { if let x = width , let y = height { return x * y } else { return 0 } } } Private Members in Extensions We can:\nDeclare a private member in the original declaration, and access that member from extensions in the same file. Declare a private member in one extension, and access that member from another extension in the same file. Declare a private member in an extension, and access that member from the original declaration in the same file. Example:\nprotocol Printer { func printLegs() } struct Cat { private var leg = 4 } extension Cat: Printer { func printLegs() { print(leg) } } Generics It will be the minimum of the access level on the type parameter.\nType Aliases A type alias can have an access level less than or equal to the access level of the type it aliases.\n","permalink":"https://wowios.com/post/language/swift/27access-control/","summary":"\u003cp\u003eAccess control restrict access to part of the code form code in other source files and modules. It enable us to \u003cstrong\u003ehide the implement detail\u003c/strong\u003e of the code, and to \u003cstrong\u003especify a preferred interface\u003c/strong\u003e which that code can be accessed and used.\u003c/p\u003e\n\u003cp\u003eSet access levels to individual types (classes, structures, enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types.\u003c/p\u003e\n\u003cp\u003eProtocols can be restricted to a certain context, as can global constants, variable, and functions.\u003c/p\u003e","title":"Access Control"},{"content":"Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.\nHere we are talking about the situation that happen on a single thread.\nMemory Access var one = 1 // write access to the memory one is stored. print(\u0026#34;\\(one)\u0026#34;) // read access from the memory one is stored. The conflicting access to memory can occur when different part of the code are trying to access the same location in memory at the same time.\nCharacteristics of Memory Access A conflict occurs if two access that meet all of the following conditions:\nAt least one is a write access or a nonatomic access. They access the same location in memory. Their duration overlap. The different between a read and write access is obvious: a write access changes the location in memory, but a read access doesn’t.\nAn operation is atomic if it use only C atomic operation; otherwise it’s nonatomic.\nMost memory access is instantaneous.\nExample: all the read and write accesses in the code below are instantaneous\nfunc addOne(_ number: Int) -\u0026gt; Int { return number + 1 } var num = 2 num = addOne(num) print(num) The different way to access memory:\ninstantaneous access: as the code shown below. long-term access: other code can run after a long-term access but before it ends, which is call overlap. A long-term access can overlap with other long-term accesses and instantaneous access. The situation that overlap appear:\nin-out parameters in functions. mutating methods of a structure. Conflicting Access to In-Out Parameters A function has long-term write access to all of its in-out parameters. The write access for an in-out parameter starts after all of the non-in-out parameters have been evaluate and lasts for the entire duration of that function call. The in-out write access start in the same order as the parameter appear.\nLong-term write access to in-out parameter One consequence\nFor long-term write access, we can’t access the original variable that was passed as in-out, even if scoping rules and access control permit it.\nvar step = 1 func increment(_ number: inout Int) { // It want to read step and write number number += step // Here has a read and write overlap, the number and step refer to the same location in memory. } increment(\u0026amp;step) // Error conflicting access to \u0026#34;step\u0026#34; One way to solve the conflict above is to make a copy of step.\nvar copyOfStep = step // Copy from original. increment(\u0026amp;copyOfStep)// Call function with the copy. step = copyOfStep // Update the original. Another consequence\nPassing a single variable as the argument for multiple in-out parameter of the same function produces a conflict.\nfunc balance(_ x: inout Int, _ y: inout Int) { let sum = x + y x = sum / 2 y = sum / 2 } var a = 20 var b = 10 balance(\u0026amp;a, \u0026amp;b) // It\u0026#39;s Ok, there are two write access overlap in time but access different location. balance(\u0026amp;a, \u0026amp;a) // It\u0026#39;s conflict, it pass \u0026#34;a\u0026#34; to the two in-out parameter, there will be two write access overlap in time and memory. Conflicting Access to self in Methods A mutating method on a structure has write access to self for the duration of the method call.\nfunc balance(_ x: inout Int, _ y: inout Int) { var sum = x + y x = sum / 2 y = sum / 2 } struct Player { var name: String var health: Int var energy: Int static let maxHealth = 100 mutating func restorehealth() { health = Player.maxHealth // Here access the \u0026#34;self.health\u0026#34; } mutating func shareHealth(with teammate: inout Player) { balance(\u0026amp;teammate.health, \u0026amp;health) } } var oscar = Player(name: \u0026#34;Oscar\u0026#34;, health: 100, energy: 90) var maria = Player(name: \u0026#34;Maria\u0026#34;, health: 60, energy: 90) oscar.shareHealth(with: \u0026amp;maria) // It\u0026#39;s Ok, different write access to different memory. oscar.shareHealth(with: \u0026amp;oscar) // Error: conflicting accesses to the same memory (the memory that oscar\u0026#39;s health refer to). Conflicting Access to Properties Types like structures, tuples and enumerations are value type, mutating any piece of the value will mutate the whole value, meaning read or write access to one of the properties requires read or write access to the whole value.\nvar holly = Player(name: \u0026#34;Holly\u0026#34;, health: 10, energy: 10) balance(\u0026amp;holly.health, \u0026amp;holly.energy) // Error, \u0026#34;holly\u0026#34; refers to an entire value type, health an energy are two peice of that value, // the two in-out of the function can\u0026#39;t write accees to the overlap memory. However, if the holly in the above example is changed to a local variable instead of a global variable, it can be safe.\nfunc someFunc() { var holly = Player(name: \u0026#34;Holly\u0026#34;, health: 10, energy: 10) balance(\u0026amp;holly.health, \u0026amp;holly.energy) // The compiler can prove that memory access is safety because the two stored properties don\u0026#39;t interact in any way. } someFunc() // It\u0026#39;s OK. The overlapping access to properties of a structure isn’t always necessary to preserve memory safety. Exclusive access is a stricter requirement than memory safety.\nIt can prove that overlapping access to properties of a structure is safe if the following condition apply:\nAccessing only stored properties of an instance, not computed or class properties. The structure is a local variable, not a global variable. The structure is not capture by any closures, or its captured only by non-escaping closures. If the compiler can’t prove the access is safe, it doesn’t allow the access.\n","permalink":"https://wowios.com/post/language/swift/26memory-safety/","summary":"\u003cp\u003eMost of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.\u003c/p\u003e\n\u003cp\u003eHere we are talking about the situation that happen on a single thread.\u003c/p\u003e\n\u003ch2 id=\"memory-access\"\u003eMemory Access\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e one = \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e     \u003cspan style=\"color:#75715e\"\u003e// write access to the memory one is stored.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\\(\u003c/span\u003eone\u003cspan style=\"color:#e6db74\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// read access from the memory one is stored.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe conflicting access to memory can occur when different part of the code are trying to access the same location in memory at the same time.\u003c/p\u003e","title":"Memory Safty"},{"content":"Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.\nReference counting applies only to instance of classes.\nReference:\nstrong: retain the obj. (default) weak: don’t retain the object referred to, track the object referred to. unowned: don’t retain the object referred to, don’t tract the object referred to. How ARC Work Allocate a chunk of memory to store information about that instance\ntype of the instance values of any stored properties associated with that instance. To make sure that instance don’t disappear while they’re needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance.\nTo make this possible, whenever assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance. The “strong” reference keeps a firm hold on that instance, and doesn’t allow it to be deallocated for as long as that strong reference remains.\nARC in Action Here we define a class name Person. Then we define three variables of type Person?, they’re automatically initialized with a value of nil, and don’t currently reference a Person instance.\nclass Person { let name: String init(name: String) { self.name = name print(\u0026#34;Person build: \\(name)\u0026#34;) } deinit { print(\u0026#34;Person deallocated: \\(name)\u0026#34;) } } var p1: Person? var p2: Person? var p3: Person? And we can create a new Person instance and assign it one of these three variables.\np1 = Person(name: \u0026#34;Mile\u0026#34;) // Now it starts the initializor, and prints the content. // Print: Person build: Mile We can set other reference to p1\np2 = p1 // The assign of reference don\u0026#39;t call the initializer. p3 = p1 // now there are three strong reference to the single Person instance. If assign other two reference with nil, the instance still has one strong reference (p1), the instance isn’t deallocated.\np1 = nil p2 = nil // The instance isn\u0026#39;t deallocated yet. If the only one last reference is broken, the instance will be deallocated.\np3 = nil // Print: Person deallocated: Mile // Now the instacne has no reference, and it\u0026#39;s deallocated (When the instance is forgot by all of others, it will leave forever) Resolving Strong Reference Cycle Between Class Instance If two class instance hold a strong reference to each other, it’s called strong reference cycle. The solution of the strong reference cycle is to define the reference as weak or unowned.\nProblem In the function test(), the instance obj has a strong reference of type B, and the instance anotherObj has a strong reference of type A. Normally, after the obj and the anotherObj are assigned as nil, the instance A() and B() built should be recycle when the reference count is zero. But in fact, they are not be recycle (The de-initializer of them haven’t been called). They hold on the reference of each other and can not be deallocated by ARC.\nclass A { var b: B? deinit { print(\u0026#34;Deinit A\u0026#34;) } } class B { var a: A? deinit { print(\u0026#34;Deinit B\u0026#34;) } } var obj: A? = A() var anotherObj: B? = B() obj!.b = anotherObj anotherObj!.a = obj obj = nil anotherObj = nil // Two instance haven\u0026#39;t been deallocated yet. Solution Change the one of the strong reference to be weak reference.\nclass A { var b: B? deinit { print(\u0026#34;Deinit A\u0026#34;) } } class B { weak var a: A? deinit { print(\u0026#34;Deinit B\u0026#34;) } } // So with the code below, the instances of A and B will be deallocated. var obj: A? = A() var anotherObj: B? = B() obj!.b = anotherObj anotherObj!.a = obj obj = nil anotherObj = nil // Print: // Deinit A // Deinit B Solution with Unowned Reference Weak references must be typed as Optional; they do not retain the object referred to, but they track the object referred to, and revert to nil if that object goes out of existence. Unowned references do not retain the object referred to and do not track the object referred to, so it\u0026rsquo;s up to you to prevent that object from going out of existence or you may end up with a dangling pointer and a crash. class A { var b: B? deinit { print(\u0026#34;Deinit A\u0026#34;) } } class B { unowned var a: A? deinit { print(\u0026#34;Deinit B\u0026#34;) } } Unowned References and Implicitly Unwrapped Optional Properties class Country { let name: String var capitalCity: City! init(name: String, capitalName: String) { self.name = name self.capitalCity = City(name: capitalName, country: self) } } class City { let name: String unowned let country: Country init(name: String, country: Country) { self.name = name self.country = country } } // Now we can access the capital name of the country directly. var country = Country(name: \u0026#34;Canada\u0026#34;, capitalName: \u0026#34;Ottawa\u0026#34;) print(\u0026#34;\\(country.name) capital : \\(country.capitalCity.name)\u0026#34;) // Print: Canada capital : Ottawa Strong Reference Cycles for Closures When assign a closure to a property, we are assigning a reference to that closure. So if we use both strong references, the class instance and a closure will keep each other alive.\nThe more Elegant Solution: Closure Capture List Here the asHTML is a closure property rather than an instance method, we can replace the default value of it with a custom closure.\nclass HTMLElement { let name: String let text: String? // Using the lazy, makes the closure can use the \u0026#34;self\u0026#34; // The lazy property will not be accessed until //after initialization has been complete and \u0026#34;self\u0026#34; is konwn. lazy var asHTML: () -\u0026gt; String = { if let text = self.text { return \u0026#34;\u0026lt;\\(self.name)\u0026gt;\\(text)\u0026lt;/\\(self.name)\u0026gt;\u0026#34; } else { return \u0026#34;\u0026lt;\\(self.name)/\u0026gt;\u0026#34; } } init(name: String, text: String? = nil) { self.name = name self.text = text } deinit { print(\u0026#34;\\(name) is being deinitialized\u0026#34;) } } let heading = HTMLElement(name: \u0026#34;h1\u0026#34;) let defaultText = \u0026#34;Some default text\u0026#34; // Pass a custom closure to set the asHTML property. heading.asHTML = { return \u0026#34;\u0026lt;\\(heading.name)\u0026gt;\\(heading.text ?? defaultText)\u0026lt;/\\(heading.name)\u0026gt;\u0026#34; } print(heading.asHTML()) // \u0026lt;h1\u0026gt;Some default text\u0026lt;/h1\u0026gt; Test the strong reference circle.\nvar paragraph: HTMLElement? = HTMLElement(name: \u0026#34;p\u0026#34;, text: \u0026#34;Hello world!\u0026#34;) print(paragraph!.asHTML()) paragraph = nil // Now the instance that paragraph hasn\u0026#39;t beem deallocated (The meassage of deinit isn\u0026#39;t print), // because of the strong reference circle between the instance of HTMLElement and the closure . Resolving Strong Reference Cycles for Closures Solution: defining a capture list as part of the closure’s definition. Declare each captured reference to be a weak or unowned reference rather than a strong reference.\nA capture list defines the rules to use when capturing one or more reference types within the closure’s body.\nCapture list definition\nlazy var someClosure = { [unowned self, weak delegate = self.delegate] (index: Int, stringToProcess: String) -\u0026gt; String in // closure body goes here } // If the closure hasn\u0026#39;t specific parameter lazy var someClosure = { [unowned self, weak delegate = self.delegate] in // closure body goes here } Correct the HTMLElement by capture list [unowned self]\nclass HTMLElement { let name: String let text: String? lazy var asHTML: () -\u0026gt; String = { [unowned self] in if let text = self.text { return \u0026#34;\u0026lt;\\(self.name)\u0026gt;\\(text)\u0026lt;/\\(self.name)\u0026gt;\u0026#34; } else { return \u0026#34;\u0026lt;\\(self.name)/\u0026gt;\u0026#34; } } init(name: String, text: String? = nil) { self.name = name self.text = text } deinit { print(\u0026#34;\\(name) is being deinitialized\u0026#34;) } } var paragraph: HTMLElement? = HTMLElement(name: \u0026#34;p\u0026#34;, text: \u0026#34;Hello world!\u0026#34;) print(paragraph!.asHTML()) paragraph = nil // Print: // \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; // p is being deinitialized // Up to here, now the instance of type HTMLElement is deallocated. The relationship between the HTMLElement and closure is just like the hen and the egg. If they both hold the strong reference, it’s hard to say which one has the priority to destroy the hen. And with the capture list, the HTMLElement (hen) has a strong reference link to the closure, and the closure (egg) just have a unowned reference link to the hen.\n","permalink":"https://wowios.com/post/language/swift/25automatic-reference-counting/","summary":"\u003cp\u003eSwift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.\u003c/p\u003e\n\u003cp\u003eReference counting \u003cstrong\u003eapplies only to instance of classes.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eReference:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003estrong: retain the obj. (default)\u003c/li\u003e\n\u003cli\u003eweak:  don’t retain the object referred to, track the object referred to.\u003c/li\u003e\n\u003cli\u003eunowned: don’t retain the object referred to, don’t tract the object referred to.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-arc-work\"\u003eHow ARC Work\u003c/h2\u003e\n\u003cp\u003eAllocate a chunk of memory to store information about that instance\u003c/p\u003e","title":"Automatic Reference Counting"},{"content":"A function with an opaque type hides its return value’s type information. Hiding type information at some boundaries between a module and code that calls into the module. Unlike returning a value whose type is a protocol type, opaque type preserve type identity —the compile has access to the type information, but clients of the module don’t.\nThe Situation Here we have a Shape protocol.\nprotocol Shape { func draw() -\u0026gt; String } The struct Triangle conform to the Shape. Describe how to draw().\nstruct Triangle: Shape { var size: Int func draw() -\u0026gt; String { var result: [String] = [] for length in 1...size { result.append(String(repeating: \u0026#34;*\u0026#34;, count: length)) } return result.joined(separator: \u0026#34;\\n\u0026#34;) } } let smallTriangle = Triangle(size: 4) print(smallTriangle.draw()) // Print: // * // ** // *** // **** The struct FlippedShape conform to the Shape and it need an injection in a type of Shape.\nstruct FlippedShape\u0026lt;T: Shape\u0026gt;: Shape{ var shape: T func draw() -\u0026gt; String { let lines = shape.draw().split(separator: \u0026#34;\\n\u0026#34;) return lines.reversed().joined(separator: \u0026#34;\\n\u0026#34;) } } let filppingShape = FlippedShape\u0026lt;Triangle\u0026gt;(shape: smallTriangle) print(filppingShape.draw()) // Print: // **** // *** // ** // * The JoinedShape conform to the Shape and it need two injection in type of Shape. It use the generic type T and U.\nstruct JoinedShape\u0026lt;T: Shape, U: Shape\u0026gt;: Shape{ var top: T var bottom: U func draw() -\u0026gt; String { return top.draw() + \u0026#34;\\n\u0026#34; + bottom.draw() } } let joinedShape = JoinedShape(top: smallTriangle, bottom: filppingShape) print(joinedShape.draw()) // Print: // * // ** // *** // **** // **** // *** // ** // * Returning an Opaque Type The opaque type like being the reverse of a generic type. In generic, the function return a type that depends on its caller:\nfunc max\u0026lt;T\u0026gt;(_ x: T, _ y: T) -\u0026gt; where T: Comparable {...} Use opaque type. It return a some type and don’t exposing the underlying type of that shape. It only focus on the return type, not the specific type.\nstruct Square: Shape { var size: Int func draw() -\u0026gt; String { let line = String(repeating: \u0026#34;*\u0026#34;, count: size) let result = Array\u0026lt;String\u0026gt;(repeating: line, count: size) count: \u0026lt;#T##Int#\u0026gt;) return result.joined(separator: \u0026#34;\\n\u0026#34;) } } func makeTrapezoid() -\u0026gt; some Shape { let top = Triangle(size: 2) let middle = Square(size: 2) let bottom = FlippedShape(shape: top) let trapezoid = JoinedShape(top: top, bottom: JoinedShape(top: middle, bottom: bottom)) return trapezoid } // Here we get a trapezoid, it\u0026#39;s something that conform to the Shape and we can only use it as shape, the client can\u0026#39;t access the underlying information of this shape. let trapezoid = makeTrapezoid() print(trapezoid.draw()) // Print: // * // ** // ** // ** // ** // * Combine Opaque Return Type with Generics. func flip\u0026lt;T: Shape\u0026gt;(_ shape: T) -\u0026gt; some Shape { return FlippedShape(shape: shape) } func join\u0026lt;T: Shape, U: Shape\u0026gt;(_ top: T, _ bottom: U) -\u0026gt; some Shape { return JoinedShape(top: top, bottom: bottom) } let opaqueJoinedTriangle = join(smallTriangle, flip(smallTriangle)) print(opaqueJoinedTriangle.draw()) // Print: // * // ** // *** // **** // **** // *** // ** // * All the possible opaque return in a function must have the same type.\n// Here is an example in error func invalidFlip\u0026lt;T: Shape\u0026gt;(_ shape: T) -\u0026gt; some Shape { if shape is Square { return shape } return FlippedShape(shape: shape) } One way to avoid return different type is to move this Square case into the FlippedShape implementation.\nstruct FlippedShape\u0026lt;T: Shape\u0026gt;: Shape{ var shape: T func draw() -\u0026gt; String { if shape is Square { return shape.draw() } let lines = shape.draw().split(separator: \u0026#34;\\n\u0026#34;) return lines.reversed().joined(separator: \u0026#34;\\n\u0026#34;) } } Using generics in an opaque return type.\nfunc repeatObj\u0026lt;T: Shape\u0026gt;(shape: T, count: Int) -\u0026gt; some Collection { return Array\u0026lt;T\u0026gt;(repeating: shape, count: count) } Differences Between Opaque Types and Protocol Types Using protocol type It can return different type that conform to Shape , it makes a much looser API than opaque return type make.\n// Protocol type func protoFlip\u0026lt;T: Shape\u0026gt;(_ shape: T) -\u0026gt; Shape { if shape is Square { return shape } return FlippedShape(shape: shape) } The less specific return type information means that the operation that depends on type information aren’t available on the return value.\nlet protoFlipTriangle = protoFlip(smallTriangle) let sameThing = protoFlip(smallTriangle) print(protoFlipTriangle == sameThing) // Error they are \u0026#39;Shape\u0026#39;, \u0026#39;Shape\u0026#39; has no func to check if they are equal, operator \u0026#39;==\u0026#39; cannot be applied to two \u0026#39;Shape\u0026#39; The opaque types preserve the identity of the underlying type.\nprotocol Container { associatedtype Item var count: Int { get } subscript(i: Int) -\u0026gt; Item { get } } extension Array: Container {} Here we:\ncan’t use Container as the return type of a function. Because the protocol has an associated type. And can’t use it as constraint in a generic return type. Because there isn’t enough information outside the function body to infer what the generic type needs to be. // Error: Protocol with associated types can\u0026#39;t be used as a return type. func makeProtocolContainer\u0026lt;T\u0026gt;(item: T) -\u0026gt; Container { return [item] } // Error: Not enough information to infer C, it has associate type func makeProtocolContainer\u0026lt;T, C: Container\u0026gt;(item: T) -\u0026gt; C { return [item] } Using the opaque type some Container as a return type. It means that the function return a container, but declines to specify the container’s type.\nfunc makeOpaqueContainer\u0026lt;T\u0026gt;(item: T) -\u0026gt; some Container { return [item] } let opaqueContainer = makeOpaqueContainer(item: 12) let twelve = opaqueContainer[0] print(type(of: twelve)) // Int ","permalink":"https://wowios.com/post/language/swift/24opaque-type/","summary":"\u003cp\u003eA function with an opaque type hides its return value’s type information. Hiding type information at some boundaries between a module and code that calls into the module. Unlike returning a value whose type is a protocol type, opaque type preserve type identity —the compile has access to the type information, but clients of the module don’t.\u003c/p\u003e\n\u003ch2 id=\"the-situation\"\u003eThe Situation\u003c/h2\u003e\n\u003cp\u003eHere we have a \u003ccode\u003eShape\u003c/code\u003e protocol.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprotocol\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eShape\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edraw\u003c/span\u003e() -\u0026gt; String\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe struct \u003ccode\u003eTriangle\u003c/code\u003e conform to the \u003ccode\u003eShape\u003c/code\u003e. Describe how to \u003ccode\u003edraw()\u003c/code\u003e.\u003c/p\u003e","title":"Opaque Type"},{"content":"Write code in a more abstract way. It make the code flexible and more reusable.\nArray and Dictionary types are both generic collections.\nThe Problem That Generics Solve If the code with no generics:\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) { let tmp = a a = b b = tmp } func swapTwoStrings(_ a: inout String, _ b: inout String) { let tmp = a a = b b = tmp } func swapTwoDoubles(_ a: inout Double, _ b: inout Double) { let tmp = a a = b b = tmp } // Use the function var aInt = 3, bInt = 4 var aString = \u0026#34;Mike\u0026#34;, bString = \u0026#34;Amy\u0026#34; var aDouble = 1.1, bDouble = 2.5 swapTwoInts(\u0026amp;aInt, \u0026amp;bInt) swapTwoStrings(\u0026amp;aString, \u0026amp;bString) swapTwoDoubles(\u0026amp;aDouble, \u0026amp;bDouble) print(aInt, bInt) print(aString, bString) print(aDouble, bDouble) // Print: // 4 3 // Amy Mike // 2.5 1.1 Once the code use generics:\n// The \u0026lt;T\u0026gt; means that this function will use a generic and the type is T. func swapTwoObj\u0026lt;T\u0026gt;(_ a: inout T, _ b: inout T) { let tmp = a a = b b = tmp } // Use the function var aInt = 3, bInt = 4 var aString = \u0026#34;Mike\u0026#34;, bString = \u0026#34;Amy\u0026#34; var aDouble = 1.1, bDouble = 2.5 swapTwoObj(\u0026amp;aInt, \u0026amp;bInt) swapTwoObj(\u0026amp;aString, \u0026amp;bString) swapTwoObj(\u0026amp;aDouble, \u0026amp;bDouble) print(aInt, bInt) print(aString, bString) print(aDouble, bDouble) // Print: // 4 3 // Amy Mike // 2.5 1.1 So the generics can clearly reduce the duplicated code when the code do the similar things.\nType Parameters We can define more than one generic types in the angle brackets.\nfunc swapTwoObj\u0026lt;T, C, D\u0026gt;(_ a: inout T, _ b: inout T, _ c: C, _ d: D) { let tmp = a a = b b = tmp } Generic Types The generics can be applied to classes, structures and enumerations.\nAn example that write a generic stack : First In First Out\nclass Stack\u0026lt;T\u0026gt; { var store: [T] = [] func push(_ element: T) { store.append(element) } func pop() -\u0026gt; T? { if store.count \u0026gt; 0 { var t = store[store.count - 1] store.remove(at: store.count - 1) return t } return nil } func isEmpty() -\u0026gt; Bool { return store.count \u0026lt;= 0 } } let stack = Stack\u0026lt;Int\u0026gt;() stack.push(4) stack.push(22) stack.push(6) while !stack.isEmpty() { if let e = stack.pop() { print(e) } else { print(\u0026#34;e is nil\u0026#34;) } } // Print: // 6 // 22 // 4 Extending a Genetic Type extension Stack { var topItem: T? { return store.isEmpty ? nil : store[store.count - 1] } } stack.push(5) stack.push(8) if let top = stack.topItem { print(top) // 8 } Type Constraints Here we constrain the genetic types that they should conform to the specific protocol.\nfunc someFunction\u0026lt;T: SomeClass, U: SomeProtocol\u0026gt;(someT: T, someU: U) { // function body goes here } Example:\nThe T: Equatable define that the T must conform to the Equatable protocol so that the T can be compared with ==.\nfunc findIndex\u0026lt;T: Equatable\u0026gt; (of target: T, in array: [T]) -\u0026gt; Int? { for (index, value) in array.enumerated() { if value == target { return index } } return nil } let strings = [\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;llama\u0026#34;, \u0026#34;parakeet\u0026#34;, \u0026#34;terrapin\u0026#34;] if let foundIndex = findIndex(of: \u0026#34;dog\u0026#34;, in: strings) { print(\u0026#34;Index: \\(foundIndex)\u0026#34;) } // Print: // Index: 1 Associated Type The actual type to use for that associated type isn’t specified until the protocol is adopted.\n// The conforming type must provide these three requirements. protocol Container { associatedtype Item // The actual type will be infered when the append method is implemented. mutating func append(_ item: Item) var count: Int { get } subscript(i: Int) -\u0026gt; Item { get } } The IntStack implementation\nstruct IntStack: Container { var items: [Int] = [] // It demonstrates the associatedtype. typealias Item = Int mutating func push(_ item: Int) { items.append(item) } mutating func pop() -\u0026gt; Int { return items.removeLast() } mutating func append(_ item: Int) { push(item) } var count: Int { items.count } subscript(i: Int) -\u0026gt; Int { items[i] } } The generic stack conform to the container.\nstruct Stack\u0026lt;Element\u0026gt;: Container { var items: [Element] = [] mutating func push(_ item: Element) { items.append(item) } mutating func pop() -\u0026gt; Element{ return items.removeLast() } // It implements the appen(_: ) requirement, Swift can therefore infer that Element is the associatedtype for the contaioner. mutating func append(_ item: Element) { push(item) } var count: Int { items.count } subscript(i: Int) -\u0026gt; Element { return items[i] } } Extending an Existing Type to Specify an Associated Type Swift’s Array type already provides append(_: ), count, subscript. This means that we can extend Array to conform the Container protocol.\nextension Array: Container {} Adding Constraints to an Associated Type protocol Container { associatedtype Item: Equatable // Here the Item conform to the Equatable is a constraints mutating func append(_ item: Item) var count: Int { get } subscript(i: Int) -\u0026gt; Item { get } } Using a Protocol in its Associated Type’s Constraints Here using the custom protocol SuffixableContainer in its constraints.\nprotocol SuffixableContainer: Container { // It defines an associatedtype named Suffix and its Item type must be the same as the container\u0026#39;s Item type. associatedtype Suffix: SuffixableContainer *where* Suffix.Item == Item // Use　the protocol suffixableContainer to constrain the associated type. func suffix(_ size: Int) -\u0026gt; Suffix } // The extension extension Stack: SuffixableContainer { // It implement the method, and Swift infer that Suffix is Stack. func suffix(_ size: Int) -\u0026gt; Stack{ var result = Stack() for index in (count - size)..\u0026lt;count { result.append(self[index]) } return result } } var stackOfInt = Stack\u0026lt;Int\u0026gt;() stackOfInt.push(3) stackOfInt.push(6) stackOfInt.push(9) let suffix = stackOfInt.suffix(2) print(suffix) // Print: // Stack\u0026lt;Int\u0026gt;(items: [6, 9]) Generic Where Clauses A generic where clause require that an associated type must conform to a certain protocol, or that the certain type parameters and associated types must be the same.\nfunc allItemMatch\u0026lt;C1: Container, C2: Container\u0026gt;(_ container: C1, _ anotherContainer: C2) -\u0026gt; Bool where C1.Item == C2.Item, C1.Item: Equatable { // Check if two container\u0026#39;s count equal. if container.count != anotherContainer.count { return false } // Check each item pairs to see if they are equivalent. for i in 0..\u0026lt;container.count { if container[i] != anotherContainer[i] { return false } } return true } We already extends the array with the code **extension** Array: Container {} before, now both the Stack\u0026lt;String\u0026gt; and Array are conform to the Container, so they can be the parameter for the method allItemMatch.\nvar stackOfStrings = Stack\u0026lt;String\u0026gt;() stackOfStrings.push(\u0026#34;uno\u0026#34;) stackOfStrings.push(\u0026#34;dos\u0026#34;) stackOfStrings.push(\u0026#34;tree\u0026#34;) var arrayOfStrings = [\u0026#34;uno\u0026#34;, \u0026#34;dos\u0026#34;, \u0026#34;tree\u0026#34;] // Now C1 is Stack\u0026lt;String\u0026gt; and C2 is Array if allItemMatch(stackOfStrings, arrayOfStrings) { print(\u0026#34;Matched\u0026#34;) } else { print(\u0026#34;Not match\u0026#34;) } Extension with a Generic Where Clause It means that the extension have some condition to be valid. If the stack whose elements aren’t equatable and it try to call the isTop(_ :) , it will trigger a compile-time error.\nvar stackOfStrings = Stack\u0026lt;String\u0026gt;() stackOfStrings.push(\u0026#34;uno\u0026#34;) stackOfStrings.push(\u0026#34;dos\u0026#34;) stackOfStrings.push(\u0026#34;tree\u0026#34;) // The extension only be vaild where the element conform to the Equatable protocol. extension Stack where Element: Equatable { func isTop(_ item: Element) -\u0026gt; Bool { guard let topItem = items.last else { return false } return topItem == item } } print(stackOfStrings.isTop(\u0026#34;tree\u0026#34;)) We can also use generic where clause with extension to a protocol.\nextension Container where Item: Equatable { func startWith(_ item: Item) -\u0026gt; Bool { return count \u0026gt;= 1 \u0026amp;\u0026amp; self[0] == item } } We can also constrain the extension’s generic type must be a specific type. Only when the condition is satisfied, the extension can be valid.\nextension Container where Item == Double { func average() -\u0026gt; Double { var sum = 0.0 for i in 0..\u0026lt;count { sum += self[i] } return sum / Double(count) } } print([11.2, 5.3, 3.2].average()) // 6.566666666666666 Contextual Where Clauses Use the condition to constrain only the method. These method only be available when the condition is satisfied.\nextension Container { func average() -\u0026gt; Double where Item == Int { var sum = 0.0 for i in 0..\u0026lt;count { sum += Double(self[i]) } return sum / Double(count) } func endsWith(_ item: Item) -\u0026gt; Bool where Item: Equatable{ return count \u0026gt;= 1 \u0026amp;\u0026amp; self[count - 1] == item } } The same behavior implemented in another way. Moving those requirement in different extensions.\nextension Container where Item == Int { func average() -\u0026gt; Double { var sum = 0.0 for index in 0..\u0026lt;count { sum += Double(self[index]) } return sum / Double(count) } } extension Container where Item: Equatable { func endsWith(_ item: Item) -\u0026gt; Bool { return count \u0026gt;= 1 \u0026amp;\u0026amp; self[count-1] == item } } Two way to do the where clause above have the same behavior. They activate the specific requirements when the condition is satisfied. However, the contextual where clause only need one extension, and the extensions’ generic where clause will require one extension for per requirement.\nAssociated Type with a Generic Where Clause Here we define the Iterator conform to the IteratorProtocol where the type Iterator.Element is the same as Item.\nprotocol Container { associatedtype Item mutating func append(_ item: Item) var count: Int { get } subscript(i: Int) -\u0026gt; Item { get } associatedtype Iterator: IteratorProtocol where Iterator.Element == Item func makeIterator() -\u0026gt; Iterator } We can add a constraint to an inherited associated type by including the generic where clause in the protocol declaration.\nprotocol ComparableContainer: Container where Item: Comparable {} Generic Subscripts Use the where to constrain.\nextension Container { subscript\u0026lt;Indices: Sequence\u0026gt;(indices: Indices) -\u0026gt; [Item] where Indices.Iterator.Element == Int{ var result: [Item] = [] for i in indices { result.append(self[i]) } return result } } ","permalink":"https://wowios.com/post/language/swift/23generics/","summary":"Define a class with template type \u003c!-- raw HTML omitted --\u003e, then should illustract the type when use the class.","title":"Generics"},{"content":"A process for querying and calling properties, methods, and subscripts on an optional that might currently be nil .Multiple queries can be chained together, and the chain fails gracefully if any link in the chain is nil .\nOptional Chaining as an Alternative to Forced Unwrapping ! force unwrapping triggers a runtime error when the optional is nil . Use the optional chaining to check if the optional value querying is succeed. the chain return optional value is nil , the optional chaining fail. the chain return optional contains a value, the optional chaining succeed. Force Unwrapping\nclass Person { var bag: Bag? } class Bag { var countOfPen = 1 } var p = Person() print(p.bag!.countOfPen) // It triggers a runtime-error because the \u0026#39;bag\u0026#39; is nil, it\u0026#39;s not graceful. // If the bag has a non-nil value, the code above will succeeds. Optional Chaining. Use the question mark in place of the exclamation point\nif let count = p.bag?.countOfPen { print(\u0026#34;The count of pen is \\(count).\u0026#34;) } else { print(\u0026#34;Unable to retrive the count.\u0026#34;) } // Print: Unable to retrive the count. The p.bag?.countOfPen will return a Int? although the countOfPen is Int , it’s a ‘optional chaining’.\n(In this querying chain the bag may be nil, the result of this chain may be nil so the result of the chain should be optional)\nOptional Chaining for Model Classes class Person { var bag: Bag? } class Bag { var pens: [Pen] = [] subscript(i: Int) -\u0026gt; Pen { get { pens[i] } set { pens[i] = newValue } } var countOfPen: Int { pens.count } var ink: Ink? } class Pen { var name: String init(name: String) { self.name = name } } class Ink { var weight: Int? var band: String? func tellBand() -\u0026gt; String? { if let band = band, let weight = weight { return \u0026#34;\\(band): \\(weight)\u0026#34; } else if band != nil { return band } else { return nil } } } Test the optional chaining.\nThe bag is nil and the ink is nil .\nvar p = Person() if let count = p.bag?.countOfPen { print(\u0026#34;The count of pen is \\(count).\u0026#34;) } else { print(\u0026#34;Unable to retrive the count.\u0026#34;) } if let band = p.bag?.ink?.tellBand() { print(\u0026#34;Get: \\(band)\u0026#34;) } else { print(\u0026#34;Unable to retrive the band\u0026#34;) } // Print: // Unable to retrive the count. // Unable to retrive the band The bag is non-nil and the ink is non-nil.\nvar p = Person() p.bag = Bag() p.bag?.pens.append(Pen(name: \u0026#34;Moni\u0026#34;)) if let count = p.bag?.countOfPen { print(\u0026#34;The count of pen is \\(count).\u0026#34;) p.bag?.ink = Ink() p.bag?.ink?.band = \u0026#34;Hero\u0026#34; p.bag?.ink?.weight = 40 } else { print(\u0026#34;Unable to retrive the count.\u0026#34;) } if let band = p.bag?.ink?.tellBand() { print(\u0026#34;Get: \\(band)\u0026#34;) } else { print(\u0026#34;Unable to retrive the band\u0026#34;) } // Print: // The count of pen is 1. // Get: Hero: 40 The chain interrupted when face nil.\nfunc createInk() -\u0026gt; Ink { print(\u0026#34;Create a ink\u0026#34;) let ink = Ink() ink.band = \u0026#34;Pi\u0026#34; return ink } var p = Person() p.bag?.ink = createInk() // The function isn\u0026#39;t called, because the bag is nil. Access the property by subscript.\nvar p = Person() p.bag = Bag() p.bag?.pens.append(Pen(name: \u0026#34;Hi\u0026#34;)) p.bag?.pens[0] = Pen(name: \u0026#34;Mi\u0026#34;) print(p.bag?[0].name) // Optional(\u0026#34;Mi\u0026#34;) // It access by subscript(i: Int) Linking Multiple Levels of Chaining When drill down the property through the optional chain, the result is only one level of optional, no matter how many levels of chaining are used.\nvar band = p.bag?.ink?.tellBand() // If the method is called successfully, the band will just be \u0026#39;String?\u0026#39; Chaining on Method with Optional Return Values var length = p.bag?.ink?.tellBand()?.count // The length is optional after the assignment. ","permalink":"https://wowios.com/post/language/swift/16optional-chaining/","summary":"\u003cp\u003eA process for querying and calling properties, methods, and subscripts on an optional that might currently be \u003ccode\u003enil\u003c/code\u003e .Multiple queries can be chained together, and the chain fails gracefully if any link in the chain is \u003ccode\u003enil\u003c/code\u003e .\u003c/p\u003e\n\u003ch2 id=\"optional-chaining-as-an-alternative-to-forced-unwrapping\"\u003eOptional Chaining as an Alternative to Forced Unwrapping\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e!\u003c/code\u003e force unwrapping triggers a runtime error when the optional is \u003ccode\u003enil\u003c/code\u003e .\u003c/li\u003e\n\u003cli\u003eUse the optional chaining to check if the optional value querying is succeed.\n\u003cul\u003e\n\u003cli\u003ethe chain return optional value is \u003ccode\u003enil\u003c/code\u003e , the optional chaining fail.\u003c/li\u003e\n\u003cli\u003ethe chain return optional contains a value, the optional chaining succeed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eForce Unwrapping\u003c/p\u003e","title":"Optional Chaining"},{"content":"A protocol defines a blueprint of methods, properties.\nCan be Adopted and implemented by:\nclass structure enumeration Syntax Definition\nprotocol SomeProtocol { func doSomething() } Being Conformed\nBy Struct\nstruct SomeStruct: FirstProtocol, AnotherProtocol { } By Class\nclass SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol { } Conforming Protocol The Dog and People both conform the DoSport protocol, so they have responsibility to implement all things from the protocol.\nprotocol DoSport { var strength: Int { get set} static var instanceCount: Int { get} func walk(distance: Int) } class Dog: DoSport { static var instanceCount: Int = 0 func walk(distance: Int) { print(\u0026#34;Walk \\(distance) with four leg\u0026#34;) } var strength: Int init(strength: Int) { self.strength = strength Dog.instanceCount += 1 } } class People: DoSport { static var instanceCount = 0 func walk(distance: Int) { print(\u0026#34;Walk \\(distance) with two leg\u0026#34;) } var strength: Int init(strength: Int) { self.strength = strength People.instanceCount += 1 } } var d = Dog(strength: 200) d.walk(distance: 4000) var p = People(strength: 1000) p.walk(distance: 1000) Mutating Method Requirements protocol Togglable { mutating func toggle() } The mutating keyword only used by structures and enumerations.\nInitializer Requirements protocol SomeProtocol { init(someParameter: Int) } Class Implementation\nThe required modifier ensures that all the subclass of the someClass must conform to the protocol and implement the method.\nclass SomeClass: SomeProtocol { required init(someParameter: Int) { } } Subclass Override Initializer and Conform to the Protocol\nprotocol Cuttable { init(someParameter: Int) } class Shape { init(someParameter: Int) { } } class Square: Shape, Cuttable { required override init(someParameter: Int) { super.init(someParameter: someParameter) } } Failable Initializer Requirements A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type. A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.\nProtocol as Types Using a protocol as type is sometimes called an existential type. So call “A type T conform to the protocol”.\nUse a protocol as a type:\nAs a parameter type or return type in a function, method, or initializer As the type of a constant, variable, or property As the type of items in an array, dictionary, or other container Example:\nUse the RandomNumberGenerator protocol as a type, the parameter that the initializer get should conform to the RandomNumberGenerator .\nprotocol RandomNumberGenerator { func random() -\u0026gt; Double } class Dice { let sides: Int let generator: RandomNumberGenerator init(sides: Int, generator: RandomNumberGenerator) { self.sides = sides self.generator = generator } func roll() -\u0026gt; Int { return Int(generator.random() * Double(sides)) + 1 } } class CustomGenerator: RandomNumberGenerator { func random() -\u0026gt; Double { return 3.0 } } // When the CustomGenerator() instance pass to the initialzer, it\u0026#39;s been upcasting. var dice = Dice(sides: 2, generator: CustomGenerator()) // Give it a generator. It\u0026#39;s a way to make generics. print(dice.roll()) // 7 Delegation A class has a delegation in itself and the delegation take the place of class to do other things. The delegation’s input is the class whom want to be delegated.\nExample: A snake and ladder game. The DiceGame is a protocol that require a Dice and a play() method. It’s the fundamental function of a DiceGame .\nThe DiceGameDelegate is a protocol that required some method to do the detail of the game, it defines how the game be played. It rely on the DiceGame . So here is the Delegation.\nThe SnakeAndLadders implements the DiceGame , and implements what to do in the play() method. It has a DiceGameDelegate to do delegate itself to do the detail things.\nclass Generator { func getNum() -\u0026gt; Int { Int.random(in: 1...6)} } class Dice { let sides: Int var generator: Generator init(sides: Int, generator: Generator) { self.sides = sides self.generator = generator } func roll() -\u0026gt; Int { return generator.getNum() } } protocol DiceGame { var dice: Dice{get} func play() } protocol DiceGameDelegate: AnyObject { func gameDidStart(_ game: DiceGame) func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) func gameDidEnd(_ game: DiceGame) } class SnakeAndLadders: DiceGame { let finalSquare = 25 let dice = Dice(sides: 6, generator: Generator()) var square = 0 var board: [Int] init() { board = Array(repeating: 0, count: finalSquare + 1) // Some point in the board have extra square buffer. board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02 board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08 } weak var delegate: DiceGameDelegate? func play() { square = 0 delegate?.gameDidStart(self) gameLoop: while square != finalSquare { let diceRoll = dice.roll() delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll) switch square + diceRoll { case finalSquare: break gameLoop // If the score(square + diceRoll) equal to max, the game end case let newSquare where newSquare \u0026gt; finalSquare: continue gameLoop // If the score(square + diceRoll) is greater than max, try again to get a diceRoll. default: square += diceRoll // If the score(square + diceRoll) is smaller than max, the game loop go on. square += board[square] } } delegate?.gameDidEnd(self) } } class DiceGameTracker: DiceGameDelegate { var numberOfTurn = 0 func gameDidStart(_ game: DiceGame) { numberOfTurn = 0 if game is SnakeAndLadders { print(\u0026#34;Start a new game of Snakes and Ladders\u0026#34;) } print(\u0026#34;Game use a \\(game.dice.sides)\u0026#34;) } func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) { numberOfTurn += 1 print(\u0026#34;Rolled a \\(diceRoll)\u0026#34;) } func gameDidEnd(_ game: DiceGame) { print(\u0026#34;The game lasted for \\(numberOfTurn) turns\u0026#34;) } } // The use of game and the delegation. let tracker = DiceGameTracker() // It\u0026#39;s a implementation of the DiceGameDelegate. let game = SnakeAndLadders() // It\u0026#39;s a implementation of the DiceGame. game.delegate = tracker game.play() Adding Protocol Conformance with an Extension We can extend an existing type to adopt and conform to a new protocol, even if we don’t have access to the source code for the existing type.\nprotocol TextOut { var textDesc: String { get } } extension Dice: TextOut { var textDesc: String { return \u0026#34;It\u0026#39;s a dice with \\(self.sides) sides\u0026#34; } } print(game.dice.textDesc) // Print: It\u0026#39;s a dice with 6 sides Conditionally Conforming to a Protocol Condition: Where the element conform the TextOut\nextension Array: TextOut where Element: TextOut { var textDesc: String { let itemAsText = self.map{$0.textDesc} // It\u0026#39;s a map // Join the map to be a string return \u0026#34;[\u0026#34; + itemAsText.joined(separator: \u0026#34;,\u0026#34;) + \u0026#34;]\u0026#34; } } let d6 = Dice(sides: 12, generator: Generator()) let d12 = Dice(sides: 12, generator: Generator()) let myDice = [d6, d12] print(myDice.textDesc) // [It\u0026#39;s a dice with 12 sides,It\u0026#39;s a dice with 12 sides] Declaring Protocol Adoption with an Extension Use the instance as a protocol. So it’s the protocol oriented programming.\nstruct Hamster { var name: String var textDesc: String { return \u0026#34;A Hamster \\(name)\u0026#34; } } extension Hamster: TextOut {} let h = Hamster(name: \u0026#34;HH\u0026#34;) let p: TextOut = h print(p.textDesc) Adopting a Protocol Using a Synthesized Implementation Swift can automatically provide the protocol conformance for Equatable , Hashable, and Comparable in many simple cases.\nSynthesized implementation of Equatable\nStructures that have only stored properties that conform to the Equatableprotocol Enumerations that have only associated types that conform to the Equatableprotocol Enumerations that have no associated types Synthesized implementation of Hashable .\nStructures that have only stored properties that conform to the Hashableprotocol Enumerations that have only associated types that conform to the Hashableprotocol Enumerations that have no associated types Example:\nOnce the structure or enumeration conform the Equatable , it can be compared by ==, and the structure of enumeration needn’t to implement that the protocol required.\nstruct Vector3D: Equatable { var x = 0.0, y = 0.0, z = 0.0 } let point = Vector3D(x: 2.0, y: 3.0, z: 4.0) let pointAnother = Vector3D(x: 2.0, y: 3.0, z: 4.0) if point == pointAnother { print(\u0026#34;Two vectors are equivalent\u0026#34;) } // Print: Two vectors are equivalent Comparable\nenum SkillLevel: Comparable { case beginner case intermediate case expert(stars: Int) } var levels = [SkillLevel.intermediate, SkillLevel.beginner, SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)] for level in levels.sorted() { print(level) } // Print: // beginner // intermediate // expert(stars: 3) // expert(stars: 5) Collection of Protocol Types A protocol can be used as the type to be stored in a collection such as an array or a dictionary.\nlet things: [TextOut] = [d6, d12, h] for thing in things { print(thing.textDesc) } // Print: // It\u0026#39;s a dice with 6 sides // It\u0026#39;s a dice with 12 sides // A Hamster HH Protocol Inheritance A protocol can inherit one or more other protocols.\nprotocol Storeable { func store() -\u0026gt; String } protocol Readable { } protocol Cleanable { } protocol BookShelf: Storeable, Readable, Cleanable { // Here the BookShelf will have the requirement from the protocols. } Class-Only Protocols We can limit protocol adoption to class types by adding the AnyObject protocol to a protocol’s inheritance list. It defines that the conforming type has a reference semantics rather than value semantics.\nprotocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol { } Protocol Composition A type can conform to multiple protocols at the same time. It has the form SomeProtocol \u0026amp; AnotherProtocol .\nProtocol composition don’t define any new protocol types.\nprotocol Named { var name: String { get } } protocol Aged { var age: Int { get} } struct Person: Named, Aged { var name: String var age: Int } // The type passed to the function must conform to both Named and Aged. func goToSchool(menber: Named \u0026amp; Aged) { print(\u0026#34;Go to school: \\(menber.name) is \\(menber.age)\u0026#34;) } let person = Person(name: \u0026#34;Mike\u0026#34;, age: 8) goToSchool(menber: person) // Print: Go to school: Mike is 8 Combines the Protocol and Class Combines the Named protocol and Location class.\nprotocol Named { var name: String { get } } func printInfo(location: Location \u0026amp; Named) { print(\u0026#34;The place \\(location.name) [\\(location.latitude), \\(location.longitude)] \u0026#34;) } let place = City(name: \u0026#34;Teochew\u0026#34;, latitude: 23.67, longitude: 116.62) printInfo(location: place) // Print: The place Teochew [23.67, 116.62] Checking for Protocol Conformance It can do the checking and casting as operation that in type checking and casting.\nis : check a protocol\nas : cast a protocol to a specific protocol.\nThe as? is downcast operator, it return an optional value. The as! is force downcast, it can trigger runtime error.\n// Protocol is used to describe some status. protocol HasArea { var area: Double { get } } class Circle: HasArea { let pi = 3.1415927 var radius: Double var area: Double { return pi * radius * radius} init(radius: Double) { self.radius = radius } } class Square: HasArea { var area: Double init(area: Double) { self.area = area } } class Animal { var legs: Int init(legs: Int) { self.legs = legs } } let objs: [Any] = [Circle(radius: 5), Square(area: 20), Animal(legs: 4)] for obj in objs { if obj is HasArea { print(obj, \u0026#34; is HasArea\u0026#34;) } else { print(obj, \u0026#34; is not HasArea\u0026#34;) } } for obj in objs { if let object = obj as? HasArea { // Here the object is know to be of type HasArea, so it has the only property \u0026#39;area\u0026#39; to access. print(object, \u0026#34; can be cast to a HasArea. Area is \\(object.area)\u0026#34;) } else { print(obj.self, \u0026#34; can\u0026#39;t be cast to a HasArea\u0026#34;) } } // Print: // Page_Contents.Circle is HasArea // Page_Contents.Square is HasArea // Page_Contents.Animal is not HasArea // Page_Contents.Circle can be cast to a HasArea Area is 78.5398175 // Page_Contents.Square can be cast to a HasArea Area is 20.0 // Page_Contents.Animal can\u0026#39;t be cast to a HasArea Optional Protocol Requirements Use the @objc to mark the protocol and the requirements. So these requirements don’t have to be implemented by types that conform to the protocol.\n@objc :\nCan be adopted only by classes that inherit from Objective-C class or other @objc classes (Maybe in the new swift version, the class don’t have to inherit the OC class). Can’t be adopted by structures or enumerations. The type used in the optional requirement will automatically be an optional. Such as (Int) -\u0026gt; String becomes ((Int) -\u0026gt; String)? . Here the entire function type is wrapped in the optional, not the method’s return value. @objc protocol Source { @objc optional func increment(count: Int) -\u0026gt; Int @objc optional var anotherIncrement: Int { get } } class Counter { var count = 0 var source: Source? func increment() { if let amount = source?.increment?(count: count) { count += amount } else if let amount = source?.anotherIncrement { count += amount } } } class ThreeSource: Source { let anotherIncrement = 3 } class TowardZeroSource: Source { func increment(count: Int) -\u0026gt; Int { if count == 0 { return 0 } else if count \u0026lt; 0 { return 1 } else { return -1 } } } let counter = Counter() counter.source = ThreeSource() for i in 1...3 { counter.increment() print(counter.count) } print() counter.source = TowardZeroSource() for _ in 1...10 { counter.increment() print(counter.count) } print() counter.count = -5 for _ in 1...8 { counter.increment() print(counter.count) } // Print: // 3 // 6 // 9 // // 8 // 7 // 6 // 5 // 4 // 3 // 2 // 1 // 0 // 0 // // -4 // -3 // -2 // -1 // 0 // 0 // 0 // 0 The instance of the Counter use different source of the count, so that it has the different effects.\nProtocol Extensions Protocol can be extended to provide method, initializer, subscript, and computed property implementations to conforming types. But can’t make a protocol inherit from another, the inheritance always specified in the protocol declaration itself.\nextension RandomNumberGenerator { func randomBool() -\u0026gt; Bool { return Double.random(in: 0...1) \u0026gt; 0.5 } } let generator = SystemRandomNumberGenerator() print(generator.randomBool()) The code above show that the class SystemRandomNumberGeneraror conform the RandomNumberGenerator protocol and we extend the RandomNumberGenerator protocol with a randomBool() method, so the SystemRandomNumberGeneraror can use the new method easily.\nProviding Default Implementations We can provide method or computed property requirement in the protocol’s extension.\nprotocol HasLeg { var leg: Int { get} var desc: String { get } } extension HasLeg { var desc: String { return \u0026#34;I have \\(leg) legs\u0026#34; } } class Dog: HasLeg { var leg: Int //var desc: String init() { leg = 4 } } let dog = Dog() print(dog.desc) // I have 4 legs Adding Constraints to Protocol Extensions Here we constrain the extension of the protocol only add extension when the condition Element: Equatable satisfied.\nextension Collection where Element: Equatable { func allEqual() -\u0026gt; Bool { for element in self { if element != self.first { return false } } return true } } let a = [100, 100, 100, 100] let b = [100, 100, 200, 100] print(a.allEqual()) print(b.allEqual()) ","permalink":"https://wowios.com/post/language/swift/22protocols/","summary":"A protocol defines a blueprint with methods, properties.","title":"Protocol"},{"content":"Extension add new functionality to an existing class, structure, enumeration, or protocol type.\nExtension in Swift can:\nAdd computed instance properties and computed type properties Define instance methods and type methods Provide new initializers Define subscripts Define and use new nested types Make an existing type conform to a protocol Or even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types.\nExtension Syntax extension SomeType { } extension SomeType: SomeProtocol, AnotherProtocol { } If we define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined. Computed Properties Extension can add new computed properties, but can’t add stored properties or add property observers to existing properties.\n// Extend the Swift\u0026#39;s built-in Double type. extension Double { var km: Double { return self * 1000.0} var m: Double { return self} var mm: Double { set { self = newValue / 1000.0 } get { return self / 1000.0 } } } let tall = 22.2.km print(tall) // 22200.0 Initializers Extensions can add new convenience initializers to a class, but can’t add new designated initializers or de-initializers to a class.\nstruct Size { var width = 0.0, height = 0.0 } struct Point { var x = 0.0, y = 0.0 } struct Rect { var origin = Point() var size = Size() } var rectOne = Rect() var rectTwo = Rect(origin: Point(x: 2.0, y: 3.0), size: Size(width: 5.0, height: 4.0)) extension Rect { init(center: Point, size: Size) { let x = center.x - (size.width / 2) let y = center.y - (size.height / 2) self.init(origin: Point(x: x, y: y), size: size) } } var rectThree = Rect(center: Point(x: 3, y: 3), size: Size(width: 4, height: 4)) print(rectThree) Method Extensions can add new instance methods and type methods to existing types.\nextension Int { func repetitions(task: () -\u0026gt; Void) { for _ in 0..\u0026lt;self { task() } } } 4.repetitions { print(\u0026#34;good\u0026#34;) } The method in the extension of the class can modify the instance itself(self). However, if the method in extensions of the structures or enumerations want to modify the self , the method must mark as mutatinfg.\n// The \u0026#39;Int\u0026#39; is structure. extension Int { mutating func square() { self = self * self } } var res = 3 res.square() print(res) // 9 Subscripts Extension can add new subscripts to an existing type.\nextension Int { subscript(digitIndex: Int) -\u0026gt; Int { var decimalBase = 1 for _ in 0..\u0026lt;digitIndex { decimalBase *= 10 } return self / decimalBase % 10 } } var res = 12345[1] print(res) // 4 Nested Types extension Int { enum Kind { case negative, zero, positive } var kind: Kind { switch self { case 0: return .zero case let x where x \u0026lt; 0: return .negative case let x where x \u0026gt; 0: return .positive default: return .negative } } } var x = -5 print(x.kind) // negative Check kind and responds different situations.\nfunc check(_ nums: [Int]) -\u0026gt; String { var str = \u0026#34;\u0026#34; for num in nums { switch num.kind { case .zero: str += \u0026#34;0\u0026#34; case .negative: str += \u0026#34;-\u0026#34; case .positive: str += \u0026#34;+\u0026#34; } } return str } print(check([1, 2, 0, -2, 1])) // ++0-+ ","permalink":"https://wowios.com/post/language/swift/21extensions/","summary":"Extension add new functionality to an existing class, structure, enumeration, or protocol type.","title":"Extension"},{"content":"Enumerations, classes or structures can be nested in another type.\nstruct Closh { enum Size: String{ case H = \u0026#34;high\u0026#34;, M = \u0026#34;Medium\u0026#34;, L = \u0026#34;Low\u0026#34; } enum Detail: Int { case H = 180, M = 170, L = 160 struct Price { let normal: Int, discount: Int? } var price: Price { switch self { case .H: return Price(normal: 100, discount: 90) case .M: return Price(normal: 90, discount: 80) case .L: return Price(normal: 80, discount: 70) default: return Price(normal: self.rawValue, discount: nil) } } } let size: Size, detail: Detail var description: String { return \u0026#34;\\(size.rawValue), PriceNormal: \\(detail.price.normal) PriceDiscount: \\(detail.price.discount)\u0026#34; } } var closh = Closh(size: .M, detail: .M) print(closh.description) // Print: Medium, PriceNormal: 90 PriceDiscount: Optional(80) Referring to Nested Types\nvar L = Closh.Size.L.rawValue print(L) // Low ","permalink":"https://wowios.com/post/language/swift/20nested-types/","summary":"\u003cp\u003eEnumerations, classes or structures can be nested in another type.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eClosh\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSize\u003c/span\u003e: String{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e H = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;high\u0026#34;\u003c/span\u003e, M = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Medium\u0026#34;\u003c/span\u003e, L = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Low\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDetail\u003c/span\u003e: Int {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e H = \u003cspan style=\"color:#ae81ff\"\u003e180\u003c/span\u003e, M = \u003cspan style=\"color:#ae81ff\"\u003e170\u003c/span\u003e, L = \u003cspan style=\"color:#ae81ff\"\u003e160\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePrice\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e normal: Int, discount: Int?\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e price: Price {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eswitch\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eself\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e .H:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e Price(normal: \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e, discount: \u003cspan style=\"color:#ae81ff\"\u003e90\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e .M:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e Price(normal: \u003cspan style=\"color:#ae81ff\"\u003e90\u003c/span\u003e, discount: \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e .L:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e Price(normal: \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e, discount: \u003cspan style=\"color:#ae81ff\"\u003e70\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003edefault\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e Price(normal: \u003cspan style=\"color:#66d9ef\"\u003eself\u003c/span\u003e.rawValue, discount: \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e size: Size, detail: Detail\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e description: String {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\\(\u003c/span\u003esize.rawValue\u003cspan style=\"color:#e6db74\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e, PriceNormal: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\\(\u003c/span\u003edetail.price.normal\u003cspan style=\"color:#e6db74\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e PriceDiscount: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\\(\u003c/span\u003edetail.price.discount\u003cspan style=\"color:#e6db74\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e closh = Closh(size: .M, detail: .M)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(closh.description)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Print: Medium, PriceNormal: 90 PriceDiscount: Optional(80)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eReferring to Nested Types\u003c/p\u003e","title":"Nested Types"},{"content":"Type casting in Swift is implemented with is and as operators.\nType casting:\nA subclass instance can be use as a superclass instance. Defining a Class Hierarchy class Media { var name: String init(name: String) { self.name = name } } class Song: Media { var artist: String init(name: String, artist: String) { self.artist = artist super.init(name: name) } } class Movie: Media { var director: String init(name: String, director: String) { self.director = director super.init(name: name) } } var library = [ Movie(name: \u0026#34;A\u0026#34;, director: \u0026#34;Michael\u0026#34;), Song(name: \u0026#34;B\u0026#34;, artist: \u0026#34;Elvis\u0026#34;), Movie(name: \u0026#34;C\u0026#34;, director: \u0026#34;Orson\u0026#34;), Song(name: \u0026#34;D\u0026#34;, artist: \u0026#34;Rick\u0026#34;), Media(name: \u0026#34;E\u0026#34;) ] // The \u0026#34;library\u0026#34; is inferred to be [Media] for item in library { print(item.name) // Here the item is of \u0026#34;Media\u0026#34; type } // If we want to use the library\u0026#39;s item as the subclass instance, we should downcast the item. Checking Type Use is to check whether an instance is of a certain subclass type.\nfor item in library { if item is Movie { print(item.name + \u0026#34; is Movie\u0026#34;) } else if item is Song { print(item.name + \u0026#34; is Song\u0026#34;) } else { print(item.name + \u0026#34; is Media\u0026#34;) } } When set the movies and songs to the library, it\u0026rsquo;s the automatically upcast. The upcast is a type of polymorphism.\nDowncasting When we believe that a superclass instance is actually of a subclass type, we can downcast the instance to be a subclass type.\nTwo way to downcast a instance:\nas? get an optional result. (Recommended) as! force downcast, it will trigger runtime error when the types not match. for item in library { if let movie = item as? Movie { print(movie.name + \u0026#34; \u0026#34; + movie.director) } else if let song = item as? Song { print(song.name + \u0026#34; \u0026#34; + song.artist) } } // Print: // A Michael // B Elvis // C Orson // D Rick // E is just a Media Type Casting for Any and AnyObject Any can represent an instance of any type at all, including function type, including class type. AnyObjece can represent an instance of any class type. var things: [Any] = [] things.append(0) var a: Int? = 3 things.append(a as Any) things.append(4.0) things.append(42) things.append(\u0026#34;Oh\u0026#34;) things.append((2.0, 3.5)) things.append(Media(name: \u0026#34;LoL\u0026#34;)) things.append({(name: String) -\u0026gt; String in \u0026#34;Hello, \\(name)\u0026#34;}) for thing in things { switch thing { case is Int: print(\u0026#34;\\(thing) is Int\u0026#34;) case let someDouble as Double where someDouble \u0026gt; 2: print(\u0026#34;Double \\(someDouble) is greater than 2\u0026#34;) case is Double: print(\u0026#34;\\(thing) is Double\u0026#34;) case let s as String: print(\u0026#34;\\(thing) is String\u0026#34;) case let (x, y) as (Double, Double): print(\u0026#34;x: \\(x) y: \\(y)\u0026#34;) case let media as Media: print(\u0026#34;Media: \\(media.name)\u0026#34;) case let say as (String) -\u0026gt; String: print(\u0026#34;Func: \\(say(\u0026#34;John\u0026#34;))\u0026#34;) default: break } } // Print: // 0 is Int // Optional(3) is Int // Double 4.0 is greater than 2 // 42 is Int // Oh is String // x: 2.0 y: 3.5 // Media: LoL // Func: Hello, John If we want to use an optional variable as Any , write as Any , otherwise\nSwift will give us a warning.\nvar a: Int? = 3 things.append(a) // Warning things.append(a as Any) // No warning ","permalink":"https://wowios.com/post/language/swift/19type-casting/","summary":"\u003cp\u003eType casting in Swift is implemented with \u003ccode\u003eis\u003c/code\u003e and \u003ccode\u003eas\u003c/code\u003e operators.\u003c/p\u003e\n\u003cp\u003eType casting:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA subclass instance can be use as a superclass instance.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"defining-a-class-hierarchy\"\u003eDefining a Class Hierarchy\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMedia\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e name: String\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e(name: String) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eself\u003c/span\u003e.name = name\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSong\u003c/span\u003e: Media {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e artist: String\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e(name: String, artist: String) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eself\u003c/span\u003e.artist = artist\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.\u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e(name: name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMovie\u003c/span\u003e: Media {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e director: String\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e(name: String, director: String) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eself\u003c/span\u003e.director = director\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e.\u003cspan style=\"color:#66d9ef\"\u003einit\u003c/span\u003e(name: name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e library = [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Movie(name: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;A\u0026#34;\u003c/span\u003e, director: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Michael\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Song(name: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;B\u0026#34;\u003c/span\u003e, artist: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Elvis\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Movie(name: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;C\u0026#34;\u003c/span\u003e, director: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Orson\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Song(name: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;D\u0026#34;\u003c/span\u003e, artist: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Rick\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Media(name: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;E\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// The \u0026#34;library\u0026#34; is inferred to be [Media] \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e item \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e library {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(item.name)  \u003cspan style=\"color:#75715e\"\u003e// Here the item is of \u0026#34;Media\u0026#34; type \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// If we want to use the library\u0026#39;s item as the subclass instance, we should downcast the item.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"checking-type\"\u003eChecking Type\u003c/h2\u003e\n\u003cp\u003eUse \u003ccode\u003eis\u003c/code\u003e to check whether an instance is of a certain subclass type.\u003c/p\u003e","title":"Type Casting"},{"content":"Swift has built-in support for writing asynchronous and parallel code in a structured way.\nParallel code means multiple pieces of code run simultaneously.\nConcurrency will make the code harder to debug. Swift can help to catch problem at compile time. Although it’s possible to write concurrent code without using Swift language support, that code tends to be hard to read.\nlistPhotos(inGallery: \u0026#34;Summer Vacation\u0026#34;) { photoNames in let sortedNames = photoNames.sorted() let name = sortedNames[0] downloadPhoto(named: name) { photo in show(photo) } } Keywords:\nasync make the function asynchronous. await make function calling synchronous. Defining and Calling Asynchronous Functions The asynchronous functions or methods can run in another new ‘thread’, but we have no need to create a thread to do that, the Swift manage the asynchronous calling automatically.\nfunc listPhotos(inGallery name: String) async -\u0026gt; [String] { let result = // ... some asynchronous networking code ... return result } With the async keyword, the function will be executed in an asynchronous way when it’s been called (the async should be written before throws). The network request takes a relatively long time, so use the we async to let the rest of the app’s code keep running while this code waits for the picture to be ready.\nSuspend Execution by await Use await to make the caller being suspend. Waiting for the return of the function.That code also runs until the next suspension point, marked by await, or until it completes.\nWhile this code’s execution is suspended, some other concurrent code in the same program runs. For example, maybe a long-running background task continues updating a list of new photo galleries.\nlet photoNames = await listPhotos(inGallery: \u0026#34;Summer Vacation\u0026#34;) let sortedNames = photoNames.sorted() let name = sortedNames[0] let photo = await downloadPhoto(named: name) show(photo) The await make the code to be suspend that also called yielding the thread, so behind the scenes, the other code in the same thread will have opportunity to be executed.\nOnly certain place in the program can call asynchronous function or methods:\nCode in the body of an asynchronous function, method, or property. Code in the static main() method of a structure, class, or enumeration that mark with @main . Code in an unstructured child task. A way to simulate the waiting for network request.\nfunc listPhotos(inGallery name: String) async throws -\u0026gt; [String] { let result = [\u0026#34;fine\u0026#34;, \u0026#34;aaa\u0026#34;] try await Task.sleep(nanoseconds: 5 * 10000) // Use the \u0026#39;try await Task.sleep\u0026#39; to simulate print(\u0026#34;did\u0026#34;) return result } func downloadPhoto(names: [String]) async throws { print(\u0026#34;download\u0026#34;) try await Task.sleep(4 * 1_000_000) } Asynchronous Sequences Suspend every execution of the elements.\nimport Foundation let handle = FileHandle.standardInput for try await line in handle.bytes.lines { print(line) } Calling Asynchronous Functions in Parallel In synchronous way, they are processed one by one.\nlet firstPhoto = await downloadPhoto(named: photoNames[0]) let secondPhoto = await downloadPhoto(named: photoNames[1]) let thirdPhoto = await downloadPhoto(named: photoNames[2]) In asynchronous way, they are processed asynchronously, don’t wait for each mother.\nasync let firstPhoto = downloadPhoto(named: photoNames[0]) async let secondPhoto = downloadPhoto(named: photoNames[1]) async let thirdPhoto = downloadPhoto(named: photoNames[2]) // Async can\u0026#39;t be used for the non-async properties. Both await and async-let allow other code to run while they’re suspended. The code can use both await and async-let in a same project. Tasks and Task Groups Structured concurrency Tasks are arranged in a hierarchy. Each task in a task group has the same parent task, and each task can have child tasks. await withTaskGroup(of: Data.self) { taskGroup in let photoNames = await listPhotos(inGallery: \u0026#34;Summer Vacation\u0026#34;) for name in photoNames { taskGroup.addTask { await downloadPhoto(named: name) } } } Unstructured Concurrency Two way to create unstructured task and get a task handle as the result.\nTo create an unstructured task that runs on the current actor, call the Task.init(priority: operation:) initializer. To create an unstructured task that’s not part of the current actor, call the Task.d etached(priority:operation:) class method. let newPhoto = // ... some photo data ... let handle = Task { return await add(newPhoto, toGalleryNamed: \u0026#34;Spring Adventures\u0026#34;) } let result = await handle.value Task Cancellation Task check can do some responds when the condition is satisfied. It depended on the work we do.\nThrowing error like cancellationError Returning nil or an empty collection Returning the partially completed work Call Task.checkCancellation() , and it will throws CancellationError if the task has been cancelled. Call Task.isCancelled and handle the cancellation in the code.\nCall Task.cancel() to propagate cancellation manually.\nActors It’s similar to the class. It’s reference type. Allow only one task to access their mutable state at a time.\nWhen a task(A) is interacting with an actor instance, the another task(B) can’t access this actor instance at the same time, and the task B will be suspend and waiting for access the property.\nactor Home{ let label: String var t: [Int] private(set) var max: Int = 0 init(label: String, t: Int) { self.label = label self.t = [t] if t \u0026gt; self.max { self.max = t } } } extension Home{ func update(with temp: Int) { t.append(temp) if temp \u0026gt; max { max = temp } } } Use the actor\n@main struct DemoApp { static func main() async { var home = Home(label: \u0026#34;Ha\u0026#34;, t: 10) print(await home.max) await home.update(with: 22) print(await home.max) } } ","permalink":"https://wowios.com/post/language/swift/18concurrency/","summary":"\u003cp\u003eSwift has built-in support for writing asynchronous and parallel code in a structured way.\u003c/p\u003e\n\u003cp\u003eParallel code means multiple pieces of code run simultaneously.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eConcurrency will make the code harder to debug.\u003c/li\u003e\n\u003cli\u003eSwift can help to catch problem at compile time.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAlthough it’s possible to write concurrent code without using Swift language support, that code tends to be hard to read.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elistPhotos(inGallery: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Summer Vacation\u0026#34;\u003c/span\u003e) { photoNames \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e sortedNames = photoNames.sorted()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e name = sortedNames[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    downloadPhoto(named: name) { photo \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        show(photo)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eKeywords:\u003c/p\u003e","title":"Concurrency"},{"content":"A class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.\nWhen an optional fails, it’s useful to understand what cause the failure, so that the code can respond accordingly.\nExample: Reading a file from the disk may be fail in some way.\nFile not exist Have no permission to read. File not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.\nRepresenting and Throwing Errors We can custom an error enumeration, and conform this enumeration to the Error protocol, so that the custom error can be use as a standard error.\n// Represent enum VendingMachineError: Error { case invaildSelection case insufficientFunds(coinsNeeded: Int) case outOfStack } struct Item { var price: Int var count: Int } class VendingMachine { var inventory = [ \u0026#34;Cola\u0026#34;: Item(price: 3, count: 10), \u0026#34;Cake\u0026#34;: Item(price: 12, count: 11), \u0026#34;Chips\u0026#34;: Item(price: 8, count: 5) ] var coinsDeposited = 0 func vend(name: String) throws { guard let item = inventory[name] else { throw VendingMachineError.invaildSelection } guard item.price \u0026lt;= coinsDeposited else { throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited) } guard item.count \u0026gt;= 0 else { throw VendingMachineError.outOfStack } coinsDeposited -= item.price inventory[name]?.count -= 1 print(\u0026#34;Dispensings \\(name)\u0026#34;) } } Testing the error throwing.\nvar machine = VendingMachine() do { machine.coinsDeposited = 15 try machine.vend(name: \u0026#34;Cake\u0026#34;) print(\u0026#34;Vend cake succeed\u0026#34;) // Current coinsDeposited is 6. try machine.vend(name: \u0026#34;Chips\u0026#34;) print(\u0026#34;Vend chips succeed\u0026#34;) } catch VendingMachineError.insufficientFunds, VendingMachineError.invaildSelection, VendingMachineError.outOfStack { print(\u0026#34;Have an error\u0026#34;) } // Print: // Dispensings Cake // Vend cake succeed // Have an error The do{ try } will be interrupted if the some errors were thrown.\nHandling Errors Four way to handle error.\nPropagate the error to whom call the function.(Pass the error to higher level) Use do-catch statement. Handle the error as an optional value. (try?) Assert that the error will not occur. (try!) Swift doesn’t involve unwinding the call stack in which can be computationally expensive.\n1. Propagate Error Using Throwing let people = [\u0026#34;Amy\u0026#34;: \u0026#34;Cake\u0026#34;, \u0026#34;Bob\u0026#34;: \u0026#34;Chips\u0026#34;] func buyFavoriteSnack(name: String) throws { try machine.vend(name: name) } 2. Using Do-Catch do { try something } catch parameter1 { } catch parameter2 where condition { } Example\ndo { try machine.vend(name: \u0026#34;cola\u0026#34;) } catch is Error { // Catch all errors print(\u0026#34;Transation fail.\u0026#34;) } do { try machine.vend(name: \u0026#34;Cake\u0026#34;) } catch VendingMachineError.insufficientFunds { print(\u0026#34;insufficientFunds\u0026#34;) } catch { // Catch other errors. } If none of the catch handle the error, the error propagates to the surrounding scope. And finally the error must be handled by the top-level scope, otherwise the error will triggers the runtime error.\nFinally handle the errors.\nfunc buySomething(name: String) throws{ do { try machine.vend(name: name) } catch VendingMachineError.outOfStack { print(\u0026#34;Out of stack\u0026#34;) } } do { try buySomething(name: \u0026#34;Cake\u0026#34;) } catch VendingMachineError.invaildSelection { print(\u0026#34;insufficientFunds\u0026#34;) } catch { // Catch other errors. Otherwise the other errors will trigger runtime error. print(\u0026#34;Other\u0026#34;) } // Print: Other Write in a better form.\nfunc buySomething(name: String) throws{ do { try machine.vend(name: name) } catch is VendingMachineError { print(\u0026#34;Vending Maching have an error.\u0026#34;) } } 3. Converting Errors to Optional Values Use try? to convert errors to optional value.\nfunc remain(name: String) throws -\u0026gt; Int { if let item = machine.inventory[name] { return item.count } else { throw VendingMachineError.invaildSelection } } var countOfCake = try? remain(name: \u0026#34;Cake\u0026#34;) // Use the \u0026#39;try?\u0026#39; to convert the error into a optional value. var count: Int? do { try count = remain(name: \u0026#34;Cake\u0026#34;) } catch is Error { count = nil } print(countOfCake) // The countOfCake is equal to the count. They are all optional. 4. Assert the Error Not Occur try! return a normal type. If the method/init throws an error, it will crash. Because the returned type will be nil and a normal type cannot handle nil.\nDisabling Error Propagation\nUse the try! to disable error propagation and wrap the call in a runtime assertion\nfunc remain(name: String) throws -\u0026gt; Int { if let item = machine.inventory[name] { return item.count } else { throw VendingMachineError.invaildSelection } } let c = try! remain(name: \u0026#34;Cola\u0026#34;) let e = try! remain(name: \u0026#34;Bread\u0026#34;) // It will raises a runtime error. Avoid using try! in most cases since it will break your program.\nSpecifying Cleanup Action Use a defer statement to execute a set of statements just before code leaves the current block of code.\nA defer statement defers execution until the current scope is exited, and it has a backward sequence to call the statements in the defer block.\nfunc processFile(name: String) throws{ if exists(name) { let file = open(name) defer { close(file) // Executed third doSomething() // Executed second stop() // Executed first } while let line = try file.readline() { } // Here call the stop, doSomething, close } } ","permalink":"https://wowios.com/post/language/swift/17error-handling/","summary":"\u003cp\u003eA class support for throwing, catching, propagating, and manipulating recoverable errors at \u003cem\u003eruntime\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWhen an optional fails, it’s useful to understand what cause the failure, so that the code can respond accordingly.\u003c/p\u003e\n\u003ch2 id=\"example\"\u003eExample:\u003c/h2\u003e\n\u003cp\u003eReading a file from the disk may be fail in some way.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFile not exist\u003c/li\u003e\n\u003cli\u003eHave no permission to read.\u003c/li\u003e\n\u003cli\u003eFile not being encoded in a compatible format.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDistinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.\u003c/p\u003e","title":"Error Handling"},{"content":"A deinitializer is called immediately before a class instance is deallocated.\nWrite with deinit keyword.\nSwift manage the instance memory through automatic reference counting.\nDeinitializer can access all properties of the instance, and do some work to release the handlers (such as close a file).\nClass definition can have at most one deinitializer per class. It doesn’t take any parameters.\n// The function creat a cat and the cat will destory after the function end. class Cat { init () { print(\u0026#34;Create\u0026#34;) } deinit { print(\u0026#34;Destory\u0026#34;) } } func run() { var cat = Cat() } run() // Print: // Create // Destory Deinitializers in Action Here shows a static Bank that own some coins. When create a new player, the player get coins from the Bank. And the player give back the coins to the Bank before the player is deinitialized.\nclass Bank { static var coins = 10000 static func distribute(coinsRequest: Int) -\u0026gt; Int { let num = min(coinsRequest, coins) // It can only get at most \u0026#39;coins\u0026#39; count. coins -= num return num } static func recive(num: Int) { coins += num } } class Player { var coins: Int init(coins: Int) { self.coins = coins Bank.distribute(coinsRequest: coins) } func win(coins: Int) { self.coins += Bank.distribute(coinsRequest: coins) } deinit { Bank.recive(num: coins) } } func create() { var mike = Player(coins: 300) print(\u0026#34;After init \\(Bank.coins)\u0026#34;) mike.win(coins: 200) print(\u0026#34;After win \\(Bank.coins)\u0026#34;) } create() print(\u0026#34;After deinit \\(Bank.coins)\u0026#34;) // Print: // After init 9700 // 9500 // 10000 ","permalink":"https://wowios.com/post/language/swift/15deinitialization/","summary":"Before the object is recycle, the deinitializer solve the post events.","title":"Deinitialization"},{"content":"Initialization is the process of preparing an instance of a class, structure or enumeration for use.\nProperties were set as an initial value.\nInitializers are the implements of the process of initialization.\nThe initializers can be override.\nUnlike Object-C, Swift initialization has no return value.\nInitialization for an Instance Classes and structures must set all of their stored properties to an appropriate initial value when using the initializer. (When assign a default value to a stored property or set its value within an initializer, the property is set directly without calling any property observers)\nclass Cake { // Set the \u0026#39;size\u0026#39; property with a default value 6 when it\u0026#39;s defined. It doesn\u0026#39;t tirgger any observers. var size = 6 { didSet { print(\u0026#34;Size has been set\u0026#34;) } } var price: Double { didSet { print(price) } } // Initializer init () { price = 0.0 } } var cake = Cake() // The initializer assign the price as 0.0, it doesn\u0026#39;t trigger any observers. cake.size = 9 // The size\u0026#39;s observer triggered. cake.price = 22 // The price\u0026#39;s observer triggered. // Print: // Size has been set // 22.0 Customizing Initialization Define multiple initializer for the class.\nclass Cake { var size = 6 { didSet { print(\u0026#34;Size has been set\u0026#34;) } } var price: Double { didSet { print(price) } } init () { price = 0.0 } init (price: Double) { self.price = price } init (size: Int, price: Double) { self.size = size // It doesn\u0026#39;t trigger any obserbers. self.price = price // It doesn\u0026#39;t trigger any obserbers. } } // Now we create three cakes. They will trigger no observers. var defaultCake = Cake() var cake = Cake(price: 15) var myCake = Cake(size: 7, price: 18) Omit Argument Labels\nclass Cake { var size = 6 var price: Double init () { price = 0.0 } init (_ price: Double) { self.price = price } init (_ size: Int, _ price: Double) { self.size = size self.price = price } } var defaultCake = Cake() var cake = Cake(15) var myCake = Cake(7, 18) // The compiler calls the specific initializer by checking parmeters\u0026#39; pattern, such as type and count. Optional Property Types A stored property has “no value”, it will be automatically assigned a default value of nil .\nclass Cake { var size = 6 var price: Double? // Optional, it will be assigned as nil. init () { } } Assigning Constant Properties During Initialization Constant properties\ncan be assigned at any point during initialization. Once it’s assigned, we can’t change it any more. can’t be modify by a subclass. Assign the constant property during initialization.\nclass Cake { let price: Double = 22 init () { price = 22 // price = 23 // not allowed } } Assign the constant property by default value.\nclass Cake { let price: Double = 22 init () { // price = 23 // not allowed } } Default Initializers Swift provide a default initializer for any structure or class that provide default values for all of its properties.\nclass Cake { let price: Double = 0 var desc: String? // It get nil in default. } var cake = Cake() Member-wise Initializers for Structure Types Unlike a default initializer, the member-wise initializer can assign the arguments to the properties automatically, even if the properties have no default value.\nAn example that the properties without default value.\nstruct Cake { let price: Double var desc: String? } var cake = Cake(price: 12) var bigCake = Cake(price: 50, desc: \u0026#34;Big\u0026#34;) Another example that the properties with default.\nstruct Size { var width = 0.0, height = 0.0 } var small = Size() var medium = Size(width: 4) var big = Size(width: 10, height: 10) Initializer Delegation for Value Types A initializer can call another initializer to do some work, so to avoid some duplicate code.\nClass type It has inheritance. The classes has additional responsibility for ensuring that all stored properties they inherit are assigned a suitable value during initialization. Value Type (structures and enumerations) Without inheritance, it can only delegate to another initializer that they provide themselves. Use self.init to refer to other initializers from the same type in the custom initializer. Once define a custom initializer for a value type, we will no longer have access to the default initializer or the member-wise initializer. Write the custom initializers in an extension when want to use both default initializer and member-wise initializer. struct Size { var width = 0.0, height = 0.0 } struct Point { var x = 0.0, y = 0.0 } struct Rect { var origin = Point() var size = Size() init() {} init(origin: Point, size: Size) { self.origin = origin self.size = size } init(center: Point, size: Size) { let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) } } Class Inheritance and Initialization Swift design designated initializers and convenience initializers to ensure all stored properties receive an initial value.\nDesignated Initializers They are the primary initializer for class. Every class must have at least one designated initializer.\nClasses tend to have very few designated initializers, always have only one.\nIt just like the root of a tree , which initialization takes place, and through which the process continues up the superclass chain.\nSyntax:\ninit( parmeters ) {} Convenience Initializers They are secondary supporting initializers for a class.\nIt can call the designated initializer by self.init() .\nOverride the convenience initializers to provide multiple way to create an instance of the class.\nSyntax:\nconvenience init( parmeters ) {} Initializer Delegation for Class Types Rules for delegation calls between initializers:\nA designated initializer must call a designated initializer from its immediate superclass. A convenience initializer must call another initializer from the same class. A convenience initializer must ultimately call a designated initializer. Two-Phase Initialization The initialization process:\nFirst phase: each stored property is assigned an initial value. Second phase: each class is given the opportunity to customize its stored properties. Instance ready to use. Safety Check (Swift check during compile-time):\nA designated initializer must ensure that all of the properties introduced by its class are initialized before it delegate up to a superclass initializer. A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designate initializer assign will be overwritten by the superclass as part of its own initialization. A convenience initializer must delegate to another initializer before assigning a value to any property. If doesn’t, the new value the convenience initializer assign will be overwritten by it own class’s designated initializer. An initializer can’t call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete. Process the delegate in the subclass:\nFirst phase of the initialization. Ensure all properties were initialized. Call superclass’s designated initializer. (Initializer Delegation) Assign values to the inherited properties from the superclass. The call chain: designated init \u0026lt;- convenience init \u0026lt;- convenience init\nclass Cake { var size: Int var price: Int init() { size = 6 price = 10 } convenience init(size: Int) { self.init() self.size = size } convenience init(size: Int, price: Int) { self.init(size: size) // Convenience init must call another init before properties assigning. // It will ultimately call designated init. self.price = price } } class CheeseCake: Cake { var cheese: Int // If subcalss want to customize designated init, it should use \u0026#39;override\u0026#39; together. override init(){ self.cheese = 10 // Ensure properties\u0026#39; initialization before delegate up. super.init() // Delegate up self.cheese = 15 // Assign to property after the delegate up. self.size = 7 // Assigning to inherited property must after delegate up. self.price = 22 } } The class instance isn’t fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.\nPhase 1 Convenience initializer -\u0026gt; \u0026hellip; -\u0026gt; Designated initializer -\u0026gt; superclass’s designated initializer\nInitialize own stored properties, and then go to the superclass’s designated initializer to initialize the inherited properties.\nA designated or convenience initializer is called on a class. Allocate memory for new instance, but is not yet initialized. Designated initializer confirm all stored properties and initialize them. The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties. (run superclass initializer) This continues up to the top the chain (the base class’s initializer) Once reach the top of the chain, the base class has ensure that all of its stored properties have a value, the instance is now fully initialized, phase 1 complete. Phase 2 superclass’s designated initializer -\u0026gt; designated initializer -\u0026gt; \u0026hellip; -\u0026gt; convenience initializer\nFinish the designated initializer and the called convenience initializers.\nWorking back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access self and can modify its properties and call its instance’s method. Finally, any convenience initializers in the chain have the option to customize the instance and work with self . Initializer Inheritance and Overriding In common, subclasses don’t inherit superclass’s initializers by default. But only in certain circumstances when it’s safe and appropriate to do so.\nclass CheeseCake: Cake { var cheese: Int = 10 } var cake = CheeseCake(size: 7, price:22) When the designate initializer matches the superclass’s initializer, it need override.\nclass CheeseCake: Cake { var cheese: Int override init(){ self.cheese = 10 super.init() self.cheese = 15 self.size = 7 self.price = 22 } } When the designate initializer matches the superclass’s initializer, omit the override , it’s overwrite. The code below show the overwriting of convenience initializer from superclass.\nclass CheeseCake: Cake { var cheese: Int = 10 convenience init(size: Int, price: Int) { self.init() self.size = size self.price = price self.cheese = 10 } } The implicitly call of super.init() , it works when the superclass has only one initializer init().\nclass CheeseCake: Cake { var cheese: Int init(cheese: Int) { self.cheese = cheese // super.init() implicitly called here } convenience init(size: Int, price: Int) { self.init(cheese: 15) self.size = size self.price = price } } var cake = CheeseCake(cheese: 15) Automatic Initializer Inheritance Rule 1\nIf the subclass doesn’t define any designated initializers, it automatically inherit all of its superclass designated initializer. Rule 2\nIf subclass provides an implementation of all of its superclass designated initializers(include the rule 1). Then it automatically inherits all of the superclass convenience initializers. Even if the subclass adds further convenience initializers, these rules work.\nThe code below is an example of rule 1.\nclass CheeseCake: Cake { var cheese: Int = 1 } var cake = CheeseCake() // It call the init which inherited from the superclass. The code below is an example of rule 2.\nclass CheeseCake: Cake { var cheese: Int override init() { self.cheese = 10 super.init() } init(cheese: Int) { self.cheese = cheese } convenience init(size: Int, price: Int) { self.init(cheese: 15) self.size = size self.price = price } } var cake = CheeseCake(size: 7) // The initializer \u0026#39;convenience init(size: Int)\u0026#39; is automactically inherited from the superclass. A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.\nclass Cake { var size: Int var price: Int init() { size = 6 price = 10 } init(size: Int, price: Int) { self.size = size self.price = price } convenience init(size: Int) { self.init() self.size = size } } class CheeseCake: Cake { var cheese: Int override init() { self.cheese = 10 super.init() } init(cheese: Int) { self.cheese = cheese super.init() } // Implement superclass designated initializer as a subclass convenience override convenience init(size: Int, price: Int) { self.init(cheese: 15) self.size = size self.price = price } } var cake = CheeseCake(size: 7) Designated and Convenience Initializers in Action Classes don’t have a default member-wise initializer. (Structure )\nclass Food { var name: String init(name: String) { self.name = name } convenience init() { self.init(name: \u0026#34;default\u0026#34;) } } class Pie: Food { var area: Int override convenience init(name: String) { self.init(name: \u0026#34;default\u0026#34;, area: 4) self.name = name // It must call after the super.init } init(name: String, area: Int) { self.area = area super.init(name: name) self.name = name } } class ApplePie: Pie { } var pie = ApplePie() var applePie = ApplePie(name: \u0026#34;pumpPie\u0026#34;) var bigApplePie = ApplePie(name: \u0026#34;pumpPie\u0026#34;, area: 20) print(\u0026#34;\\(pie.name): \\(pie.area)\u0026#34;) print(\u0026#34;\\(applePie.name): \\(applePie.area)\u0026#34;) print(\u0026#34;\\(bigApplePie.name): \\(bigApplePie.area)\u0026#34;) Result:\ndefault: 4 pumpPie: 4 pumpPie: 20\nFail-able Initializers Place a question mark after the init keyword(init?).\nwe can‘t define a fail-able and a non-fail-able initializer with the same parameter types and names.\nFail-able initializer\ncreate an optional value of the type it initializes. write return nil within a fail-able initializer to indicate a point at which can trigger initialization failure. (don’t use return keyword to indicate the initialization success) Example:\n// Int(exactly: ) let num: Double = 22 let pi = 3.1415 if let value = Int(exactly: num) { print(\u0026#34;\\(num) \\(value)\u0026#34;) } else { print(\u0026#34;conversion fail\u0026#34;) } // Print: 22.0 22 // The value not match the type int let num: Double = 22.1 let pi = 3.1415 if let value = Int(exactly: num) { print(\u0026#34;\\(num) \\(value)\u0026#34;) } else { print(\u0026#34;conversion fail\u0026#34;) } // Print: conversion fail Use a fail-able initializer init a structure and check if the initialization succeeded.\nstruct Animal { let species: String init?(species: String) { if species.isEmpty { return nil} self.species = species } } let creature = Animal(species: \u0026#34;Giraffe\u0026#34;) if let giraffe = creature { print(\u0026#34;The giraffe init succeeded\u0026#34;) } else { print(\u0026#34;The giraffe init fail\u0026#34;) } // Print: The giraffe init succeeded let cat = Animal(species: \u0026#34;\u0026#34;) if let c = cat { print(\u0026#34;cat inited successful\u0026#34;) } else { print(\u0026#34;cat init fail\u0026#34;) } // Print: cat init fail // The empty string has a length of 0, but it\u0026#39;s not a nil. Fail-able Initializer for Enumerations If the given state is not found in the cases, return nil .\nenum Rank { case low, midium, high init?(rank: String) { switch rank { case \u0026#34;L\u0026#34;: self = .low case \u0026#34;M\u0026#34;: self = .midium case \u0026#34;H\u0026#34;: self = .high default: return nil } } } var rank = Rank(rank: \u0026#34;H\u0026#34;) print(rank) // Optional(Page_Contents.Rank.high) var r = Rank(rank: \u0026#34;C\u0026#34;) print(r) // nil Use in rawValue\nenum Rank: String { case low = \u0026#34;L\u0026#34;, midium = \u0026#34;M\u0026#34;, high = \u0026#34;H\u0026#34; } var rank = Rank(rawValue: \u0026#34;H\u0026#34;) print(rank) // Optional(Page_Contents.Rank.high) var r = Rank(rawValue: \u0026#34;C\u0026#34;) print(r) // nil Propagation of Initialization Failure A fail-able initializer of a class, structure, or enumeration can delegate across to another fail-able initializer from the same class, structure, or enumeration. A subclass fail-able initializer can delegate up to a superclass fail-able initializer. A fail-able initializer can delegate to a non-fail-able initializer. If delegate to another initializer that cause initialization fail, the entire initialization process fails immediately, and no further initialization code is executed.\nHere is an example that the subclass fail-able initializer delegate to the superclass fail-able initializer:\nclass Product { let name: String init?(name: String) { if name.isEmpty { print(\u0026#34;Name empty, super class init fail\u0026#34;) return nil } self.name = name } } class CartItem: Product { let quantity: Int init?(name: String, quantity: Int) { if quantity \u0026lt; 1 { print(\u0026#34;No Quantity, subclass init fail\u0026#34;) return nil } self.quantity = quantity super.init(name: name) } } var itemNoName = CartItem(name: \u0026#34;\u0026#34;, quantity: 2) var itemNoQuantity = CartItem(name: \u0026#34;Apple\u0026#34;, quantity: 0) var item = CartItem(name:\u0026#34;Pen\u0026#34;, quantity: 3) print(itemNoName) print(itemNoQuantity) print(item) // Print: // Name empty, super class init fail // No Quantity, subclass init fail // nil // nil // Optional(Page_Contents.CartItem) Overriding a Fail-able Initializer Override a superclass fail-able initializer in a subclass. Override a superclass fail-able initializer with a subclass non-fail-able initializer. The only way to delegate up to the fail-able initializer is to force-unwrap the result of the fail-able initializer. Can’t override a non-fail-able initializer with a fail-able initializer. class Doc { var name: String? init() {} init?(name: String) { if name.isEmpty { return nil} self.name = name } convenience init(size: Int, name: String) { self.init(name: name)! // Delegate up to the fail-able initializer as part of the implementation. // If the name is empty, it will trigger runtime-error. } } class FileDoc: Doc { override init() { super.init() self.name = \u0026#34;[Untilted]\u0026#34; } // Override the superclass fail-able initializer with a subclass non-fail-able initializer. override init(name: String) { super.init() if name.isEmpty { self.name = \u0026#34;[Untitled]\u0026#34; } else { self.name = name } } } Use forced unwrapping in an initializer to call a fail-able initializer from the superclass as part of the implement of a subclass’s non-fail-able initializer.\nclass FileDoc: Doc { override init() { super.init(name: \u0026#34;[Untitled]\u0026#34;)! } } class MessageDoc: Doc { var size: Int init(size: Int) { self.size = size super.init(name: \u0026#34;[Untitled]\u0026#34;)! } } init! Fail-able Initializer The init! will implicitly unwrapped the optional result.\nclass Doc { var name: String? init() {} init!(name: String) { if name.isEmpty { return nil} self.name = name } } class FileDoc: Doc { override init() { super.init(name: \u0026#34;[Untitled]\u0026#34;) } } Required Initializers Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer.\nDon’t write the override keyword.\nclass Animal { required init() { print(\u0026#34;Fine\u0026#34;) } } class Cat: Animal { required init() { print(\u0026#34;Cat\u0026#34;) } } var cat = Cat() // Print: // Cat // Fine Setting a Default Property Value with a Closure or Function The closure init before the initializer, so we can’t use self within the closure.\nWith parentheses, the closure’s return value (or result) will be assign to the property.\nclass Cake { var name: String = { print(\u0026#34;fine\u0026#34;) return \u0026#34;cake\u0026#34; }() // The parentheses after the closure means that it\u0026#39;s a calling. The closure executed immediately. } var cake = Cake() // Print: fine print(cake.name) // Print: cake Without parentheses, the closure itself is to assign to the property.\nclass Cake { var name: () -\u0026gt; String = { print(\u0026#34;fine\u0026#34;) return \u0026#34;cake\u0026#34; } } var cake = Cake() // Hasn\u0026#39;t called the closure print(cake.name) // Print: (Function) cake.name() Example:\nclass ChessBoard { var boardColors: [Bool] = { var isBlack = false var board: [Bool] = [] for i in 1...8 { for j in 1...8 { board.append(isBlack) isBlack = !isBlack } } return board }() func getIsBlack(row: Int, col: Int) -\u0026gt; Bool { return boardColors[(row * 8) + col] } } var b = ChessBoard() print(b.getIsBlack(row: 2, col: 3)) // Print: true print(b.getIsBlack(row: 4, col: 4)) // Print: false ","permalink":"https://wowios.com/post/language/swift/14initialization/","summary":"The class\u0026rsquo;s initializer set the original state for the object.","title":"Initialization"},{"content":"Class A inherit from class B. Then A is the so call subclass, B is the superclass.\nSubclass can do:\nAccess methods, properties, and subscripts belonging to their superclass, Override the methods, properties and subscripts. Extends the functionality of the superclass. Superclass can do:\nAdd property observer to inherited properties. (In order to be notified when the value of property changes) Usage class Card { var number: Int? func changeNumber(number: Int) -\u0026gt; Bool { self.number = number return true } } // Inherit from Card class StudentCard: Card { var studentID: Int? } // Inherit from Card class BankCard: Card { var account = 0 } var studentCard = StudentCard() studentCard.number = 123 studentCard.studentID = 220022 print(studentCard.number!) print(studentCard.studentID!) var bankCard = BankCard() bankCard.changeNumber(number: 124) bankCard.account = 100 print(bankCard.number!) print(bankCard.account) Overriding A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass.\nAccessing Superclass Methods, Properties, and Subscripts Use the super keyword to access the things belong to the superclass.\nOverriding the initialization.\nclass Card { var number: Int? var initFee = 0 init(number: Int){ self.number = number } } class StudentCard: Card { var studentID: Int? // Override the initialization from the superclass override init(number: Int) { super.init(number: number) // It need to init the superclass at first, the \u0026#39;super\u0026#39; can\u0026#39;t be omitted here. super.initFee = 15 // The \u0026#39;super\u0026#39; can be omitted here. } } var studentCard = StudentCard(number: 123) print(studentCard.initFee) // 15 Overriding Methods class Card { var number: Int? var initFee = 0 func setInitFee(fee: Int) { self.initFee = fee } init(number: Int){ self.number = number } } class StudentCard: Card { var studentID: Int? override func setInitFee(fee: Int) { super.initFee = fee + 5 } } var studentCard = StudentCard(number: 123) studentCard.setInitFee(fee: 5) print(studentCard.initFee) // 10 Overriding Properties Regardless of whether the property is stored or computed, override an inherited instance or type property to provide custom getter and setter, or to add property observer for the property.\nThe subclass doesn’t know whether the inherited property is stored or computed.(So must state both the name and the type of the property when override it)\nRead-Write and Read-Only:\nWe can override a read-only property to be read-write, by providing getter and setter. We can’t override a read-write property to be read-only. When override the a setter, must override the getter at the same time. Return super.someProperty simply when override getter only. The code below show how to override a property from superclass.\nclass Card { var number: Int? var _desc: String = \u0026#34;\u0026#34; // The setter can\u0026#39;t set to itself, so use \u0026#39;_desc\u0026#39; to store the value. var desc: String { get { return _desc + \u0026#34;Has a number \\(number!). \u0026#34; } } } class StudentCard: Card { var initFee = 0 override var desc: String { get { return super.desc + \u0026#34; With a initFee \\(initFee)\u0026#34;} set { _desc = \u0026#34;[\u0026#34; + newValue + \u0026#34;]\u0026#34; } } } var studentCard = StudentCard() studentCard.number = 1234 studentCard.initFee = 15 studentCard.desc = \u0026#34;A student\u0026#34; print(studentCard.desc) // Print: [A student]Has a number 1234. With a initFee 15 Overriding Property Observers can’t add property observers to inherited constant stored properties or inherited read-only computed properties. can’t provide both overriding setter and overriding property observer for the same property. The code below show the VipStudentCard inherit from the StudentCard and add an observer to the desc.\nclass Card { var number: Int? var _desc: String = \u0026#34;\u0026#34; var desc: String { get { return _desc + \u0026#34;Has a number \\(number!). \u0026#34; } } } class StudentCard: Card { var initFee = 0 override var desc: String { get { return super.desc + \u0026#34; With a initFee \\(initFee)\u0026#34;} set { _desc = \u0026#34;[\u0026#34; + newValue + \u0026#34;]\u0026#34; } } } class VipStudentCard: StudentCard { override var desc: String { didSet { initFee += 5 } } } var vip = VipStudentCard() vip.number = 12345 vip.initFee = 15 vip.desc = \u0026#34;Vip\u0026#34; print(vip.desc) // Print: [Vip]Has a number 12345. With a initFee 20 Or simply observe any value changes from within the custom setter for the desc in the VipStudentCard .\nclass Card { var number: Int? var _desc: String = \u0026#34;\u0026#34; var desc: String { get { return _desc + \u0026#34;Has a number \\(number!). \u0026#34; } } } class StudentCard: Card { var initFee = 0 override var desc: String { get { return super.desc + \u0026#34; With a initFee \\(initFee)\u0026#34;} set { _desc = \u0026#34;[\u0026#34; + newValue + \u0026#34;]\u0026#34; } } } class VipStudentCard: StudentCard { override var desc: String { set{ _desc = \u0026#34;{\u0026#34; + newValue + \u0026#34;}\u0026#34; initFee += 5 } get { return super.desc } } } var vip = VipStudentCard() vip.number = 12345 // The number property is from the base class \u0026#39;Card\u0026#39; vip.initFee = 15 // The initFee vip.desc = \u0026#34;Vip\u0026#34; print(vip.desc) // Print: {Vip}Has a number 12345. With a initFee 20 Preventing Overrides We can prevent the method, property, or subscript from being overridden by marking it with final keyword.\nclass Card { var number: Int? var _desc: String = \u0026#34;\u0026#34; // Here the desc can\u0026#39;t be overridden, because it\u0026#39;s final. final var desc: String { get { return _desc + \u0026#34;Has a number \\(number!). \u0026#34; } set { _desc = \u0026#34;|\u0026#34; + newValue + \u0026#34;|\u0026#34; } } } class StudentCard: Card { var initFee = 0 } class VipStudentCard: StudentCard { } var vip = VipStudentCard() vip.number = 12345 vip.initFee = 15 vip.desc = \u0026#34;Vip\u0026#34; print(vip.desc) // Print: |Vip|Has a number 12345. If we mark the entire class as final, it can’t be inherited.\nfinal class Card { var number: Int? var _desc: String = \u0026#34;\u0026#34; var desc: String { get { return _desc + \u0026#34;Has a number \\(number!). \u0026#34; } set { _desc = \u0026#34;|\u0026#34; + newValue + \u0026#34;|\u0026#34; } } } // class StudentCard: Card {} // Compile-time error. ","permalink":"https://wowios.com/post/language/swift/13inheritance/","summary":"A class inherit another class call super class, and get some ability from super class.","title":"Inheritance"},{"content":"Method Methods are functions that associated with a particular type.\nClasses, structures and enumerations.\nDefine instance methods for an instance of the given type. Define type method for the type itself. Instance Method It is defined in a type. And it can only be called by a specific instance of the type.\nclass Bird { var energy = 10 // Instance method func sing() { energy -= 1 } // Instance method func eatFood(food: Int) { self.energy += food // self is current instance of the type, it\u0026#39;s the instance who call the current method. } func setEnergy(energy: Int) { self.energy = energy // Here must use the \u0026#39;self\u0026#39; to distinguish the property of the instance and the method\u0026#39;s parameter. } } var keo = Bird() keo.eatFood(food: 4) print(keo.energy) // 14 keo.sing() print(keo.energy) // 13 Modifying Value Types in the Instance Method Structures and Enumerations are value type, their properties can’t be modified by default.\nHowever, we can use the mutating keyword to enable the method to modify their properties.\nstruct Point { var x = 0 var y = 0 mutating func moveTo(x: Int, y: Int) { self.x = x self.y = y } } // Assigning to self Within a Mutating Method, it has the same result as the code above. struct Point { var x = 0 var y = 0 mutating func moveTo(x: Int, y: Int) { self = Point(x: x, y: y) } } enum Level { case off, low, high mutating func next() { switch self { case .off: self = .low case .low: self = .high case .high: self = .off } } } Type Method Defined in the type, called by the type. Can be used in classes, structures, enumerations. Use the static keyword to indicate the function is the type method.\nstruct Boy { static var count = 0 static func add() { count += 1 } } var boy = Boy() Boy.add() var boyB = Boy() Boy.add() print(Boy.count) // 2 Classes can use the class key word instead of the static to allow the subclass to override the method. (Just like a protected keyword in Java)\nclass Shape { static var count = 0 class func add() { self.count += 1 // Here the \u0026#39;self\u0026#39; is the type Shape itself, not a instance of type. } } Example: The player class create a new instance of LevelTracker to track that player’s progress.\nstruct LevelTracker { static var highestUnlockedLevel = 0 var currentLevel = 0 static func unlock(_ level: Int) { if level \u0026gt; highestUnlockedLevel { highestUnlockedLevel = level } } static func isUnlocked(_ level: Int) -\u0026gt; Bool { return level \u0026lt;= highestUnlockedLevel } @discardableResult mutating func advance(to level: Int) -\u0026gt; Bool { if LevelTracker.isUnlocked(level) { currentLevel = level return true } else { return false } } } class Player { var tracker = LevelTracker() let playerName: String func complete(level: Int) { LevelTracker.unlock(level + 1) // Unlock the next level for all players. tracker.advance(to: level + 1) // Update current player\u0026#39;s progress to next level. } init(name: String) { playerName = name } } var player = Player(name: \u0026#34;Mike\u0026#34;) player.complete(level: 0) print(player.tracker.currentLevel) // 1 print(LevelTracker.highestUnlockLecel) // 1 ","permalink":"https://wowios.com/post/language/swift/11method/","summary":"The object have some method to provide functionality.","title":"Method"},{"content":" Stored properties\nOnly provided by classed and structures.\nComputed properties\nProvide by classes, structures, enumerations.\nUsually associated with instance of a particular type, can be associated with the type itself(type properties).\nCan define property observers to monitor changes in a property’s value, which can respond to with custom action.\nCan use a property wrapper to reuse code in the getter and setter.\nStored Properties **struct Setting { var width: Int let height: Int } var appSetting = Setting(width: 100, height: 200) appSetting.width = 150 let constSetting = Setting(width: 110, height: 210) //constSetting.width = 120 // This will trigger a compile-time error, the struct is of const value type.** Lazy Stored Properties Its initial value isn’t calculated until the first time it’s used.\nLazy stored properties must be a variable, it will be assigned at the first time it’s used.\nConstants can’t be lazy, because it always have a value before initialization completes.\nclass DataImporter { var fileName = \u0026#34;data.txt\u0026#34; func readFromFile(path: String) -\u0026gt; String { return \u0026#34;some \u0026#34; + path } } class DataManager { lazy var importer = DataImporter() var data: [String] = [] } let manager = DataManager() manager.data.append(\u0026#34;Happy\u0026#34;) manager.data.append(\u0026#34;Time\u0026#34;) // Here the manager.importer has not yet been created. var str = manager.importer.readFromFile(path: manager.data[0]) // Here the manager.importer is created, and then call the function of the manager.importer print(str) // Print: 「some Happy」 If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property hasn’t yet been initialized, there’s no guarantee that the property will be initialized only once. Stored Properties and Instance Variable In Objective-C or C++, the definition and initialization of an instance variable are separated in different places.\nSwift cancels the instance variable rules, and use a simple way to declare the propertied of an instance, define the name, type, memory management characteristics in a single location.\nComputed Properties In classes, structures, and enumerations, we provide a getter and setter to retrieve and set properties and values indirectly.\nUsing computed properties, we can compute something else of the class’s from the other properties.\nstruct Bag { var bookCount: Int = 0 var penCount: Int = 0 var objectCount: Int { get { return bookCount + penCount } set (count) { bookCount = Int(Double(count) * 0.8) penCount = Int(Double(count) * 0.2) } } } var bag = Bag(bookCount: 1, penCount: 2) print(bag.objectCount) // Here use the getter. Print 「3」 bag.objectCount = 10 // Here use the setter. The temporary parameter \u0026#39;count\u0026#39; is assignes to 10. print(bag.objectCount) // 10 print(bag.bookCount) // 8 print(bag.penCount) // 2 The setter has a shorter form of declaration. It must use the newValue to grab the temporary parameter.\nset { bookCount = Int(Double(newValue) * 0.8) penCount = Int(Double(newValue) * 0.2) } The getter has a shorter form of declaration. It write the code with one line and as the return expression.\nget { bookCount + penCount } Read-Only Computed Properties struct Bag { var bookCount: Int = 0 var penCount: Int = 0 var objectCount: Int { get { bookCount + penCount } } } Read-Only in a shorter form:\nstruct Bag { var bookCount: Int = 0 var penCount: Int = 0 var objectCount: Int { return bookCount + penCount } } Omit the return\nstruct Bag { var bookCount: Int = 0 var penCount: Int = 0 var objectCount: Int { bookCount + penCount } } The read-only computed properties are useful for an external user to discover the Bag ’s current status.\nProperty Observers The observer can observe and respond to changes in a property’s value.\nThe observer can’t be provide together with getter or setter.\nOnly can add property in these places:\nStored properties that we define.\nStored properties that we inherit.\nFor an inherit property, add a property observer by overriding that property in a subclass.\nComputed properties that we inherit.\nUse property’s setter to observe and responds to value changes, instead of creating an observer.\nDefine either or both of these observers on a property.\nwillSet is called before the value is stored. (pass the new property value as a constant, it has a default name of newValue) disSet is called immediately after the new value is stored.(pass the last old property value as a constant, it has a default name of oldValue) struct Bag { var bookCount: Int = 0 var penCount: Int = 0 var objectCount: Int { willSet (newCount) { print(\u0026#34;Will set the count \\(newCount)\u0026#34;) // 2 } didSet { print(\u0026#34;Has set the count, the olValue is \\(oldValue), and add \\(objectCount - oldValue)\u0026#34;) // 0 2 } } } var bag = Bag(objectCount: 0) bag.objectCount = 2 // Here trigger the wiilSet and then trigger the didSet. The newValue is 2, and the oldValue is 0. print(\u0026#34;After change, objectCount: \\(bag.objectCount)\u0026#34;) // 2 The observer in the superclass can observe the properties’ action in the subclass.\nThe subclass set the superclass’s property after the superclass’s initializer has been called. If the superclass’s initializer hasn’t been called, the observer can not work. Property Wrappers It can wrap the data and the code together as a code block. Using property wrapper can reduce the repeated codes.\nHere is an example that store a number less than 12 or equals to 12. The wrappedValue must used explicitly.\n@propertyWrapper struct Num { private var number = 0 var wrappedValue: Int { get {return number} set {number = min(newValue, 12)} } } Using\nstruct Rectangle { @Num var width: Int // It declares that the var use the rule of the propertyWrapper @Num var height: Int } var rect = Rectangle() print(rect.width) // Call the \u0026#39;get\u0026#39; function rect.height = 10 // Call the \u0026#39;set\u0026#39; function Another way to use the propertyWrapper\nstruct Rectangle { private var _height = Num() private var _width = Num() var height: Int { get{ return _height.wrappedValue } set{ _height.wrappedValue = newValue} } var width: Int { get{ return _width.wrappedValue} set{ _width.wrappedValue = newValue} } } Setting Initial Values for Wrapped Properties In default, use the wrppedValue to catch the input implicitly.\nOverride the initial function so to provide several ways to to init a Num .\n@propertyWrapper struct Num { private var maximum: Int private var number: Int var wrappedValue: Int { get { return number} set { number = min(newValue, maximum)} } init() { maximum = 12 number = 0 } init(wrappedValue: Int) { maximum = 12 number = wrappedValue } init(wrappedValue: Int, maximum: Int) { self.maximum = maximum number = wrappedValue } } The initialization without parameter.\nstruct ZeroRectangle { @Num var width: Int @Num var height: Int } var zeroRect = ZeroRectangle() The initialization with one default parameter wrappedValue .\nstruct UnitRectangle { @Num var width: Int = 1 // It call the init @Num var height: Int = 1 } var unitRect = UnitRectangle() // Or in this way struct UnitRectangle { @Num(wrappedValue: 1) var width: Int @Num(wrappedValue: 1) var height: Int } var unitRect = UnitRectangle() The initialization with two parameters.\nstruct NarrowRectangle { @Num(wrappedValue: 2, maximum: 5) var width: Int @Num(wrappedValue: 3, maximum: 4) var height: Int } var narrowRect = NarrowRectangle() // Or in this way struct NarrowRectangle { @Num(wrappedValue: 2, maximum: 5) var width: Int @Num(maximum: 4) var height: Int = 3 } var narrowRect = NarrowRectangle() The default parameter wrappedValue is used to pass input implicitly.\nProject a Value From a Property Wrapper Declare the var name projectedValue in a property wrapper.\nIt can store some information such as track the change of the property, and then the outside caller can get the information from the projectedValue. It can be accessed via the dollar sign $ , when the outside caller has the permission to access.\nstruct Num { private var number: Int private(set) var projectedValue: Bool // The projectedValue\u0026#39;s set function is declare as private. var wrappedValue: Int { get { return number} set { if newValue \u0026gt; 12 { number = 12 projectedValue = true } else { number = newValue projectedValue = false } } } init() { self.projectedValue = false self.number = 0 } } struct Rectangle { @Num var width: Int } var rect = Rectangle() rect.width = 15 // The number is private, it will be affect via the `set` function. print(rect.$width) // Use the dollar sign to access the projectedValue. // rect.$width = false // It can\u0026#39;t work, the outside caller can\u0026#39;t call the projectedValue\u0026#39;s private function \u0026#39;set\u0026#39; Global and Local Variables Global\nIt is defined outside any function, method, closure, or type context.\nGlobal constants and variables are always lazily.\nLocal\nIt is defined in any function, method, closure, or type context.\nLocal constants and variables are never computed lazily.\nStored Variables provide storage for a value of a certain type and allow that value to be set and retrieved. Observer is available for the stored variable and computed variable in a global or local scope.\nProperty wrapper can be use to a stored variable, but not to a global variable or a computed variable.\nHere’s a function’s local stored variable (count) use the wrapper property (Num).\nfunc doSomething() { @Num var count: Int _count.number = 12 // The \u0026#39;number\u0026#39; requires the wrapper \u0026#39;Num\u0026#39; so it use a underscore to indicate the wrapper. print(_count.number) } Instance Properties Every time we create a new instance of that type, it has it own set of property values, separate from any other instance.\nType Properties If we define a property belong to the type itself, it’s called type property. All instance of that type share this one type property. (like static property in Java class) Stored type properties can be variables or constants. Computed type properties are always declared as variable properties, in the same way as computed instance properties. Need default value. Lazily initialized on first access. Be initialized only once, even when accessed by multiple threads simultaneously. Type Property Syntax Define type property with static keyword.\nIn a class, use class instead the static to override the superclass’s implementation.\nstruct ShortSize { static var name = \u0026#34;Short\u0026#34; private static var store: Int = 1 static var size: Int { get { return store} set { store = newValue} } } enum MediumSize { static var name = \u0026#34;Medium\u0026#34; private static var store: Int = 4 static var size: Int { get { return store } set { store = newValue} } } class LongSize { static var name = \u0026#34;Long\u0026#34; private static var store: Int = 4 static var size: Int { get { return store} set { store = newValue} } class var sizeFromSuper: Int { get { return store } set { store = 2 * newValue} } } // Use the type properties print(ShortSize.name) print(ShortSize.size) Setting the Type Properties\nsetting\nstruct ShortSize { static var name = \u0026#34;Short\u0026#34; private static var store: Int = 1 var size: Int { get { return ShortSize.store} set { ShortSize.store = newValue} } } var shortSize = ShortSize() var shortSizeAnother = ShortSize() print(shortSize.size) print(shortSizeAnother.size) shortSize.size = 15 // It will change the sharing variable \u0026#39;store\u0026#39; (type property) print(shortSize.size) print(shortSizeAnother.size) Result\n1 1 15 15\nUse the observer to respond to the change of the variable and to affect the type property.\nstruct Channel { static let maxLevel: Int = 10 static var maxInput: Int = 0 var currentLevel: Int { didSet { if currentLevel \u0026gt; Channel.maxLevel { currentLevel = Channel.maxLevel // It set the currentLevel, but it doesn\u0026#39;t call the observer again. } else if currentLevel \u0026gt; Channel.maxInput { Channel.maxInput = currentLevel } } } } var channel = Channel(currentLevel: 0) channel.currentLevel += 4 print(Channel.maxInput) ","permalink":"https://wowios.com/post/language/swift/10properties/","summary":"\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eStored properties\u003c/p\u003e\n\u003cp\u003eOnly provided by \u003cstrong\u003eclassed and structures\u003c/strong\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eComputed properties\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eProvide by classes, structures, enumerations.\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsually associated with instance of a particular type, can be associated with the type itself(type properties).\u003c/p\u003e\n\u003cp\u003eCan define property observers to monitor changes in a property’s value, which can respond to with custom action.\u003c/p\u003e\n\u003cp\u003eCan use a property wrapper to reuse code in the getter and setter.\u003c/p\u003e\n\u003ch2 id=\"stored-properties\"\u003eStored Properties\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSetting\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e width: Int\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e height: Int  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e appSetting = Setting(width: \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e, height: \u003cspan style=\"color:#ae81ff\"\u003e200\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eappSetting.width = \u003cspan style=\"color:#ae81ff\"\u003e150\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e constSetting = Setting(width: \u003cspan style=\"color:#ae81ff\"\u003e110\u003c/span\u003e, height: \u003cspan style=\"color:#ae81ff\"\u003e210\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e//constSetting.width = 120  // This will trigger a compile-time error, the struct is of const value type.**\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"lazy-stored-properties\"\u003eLazy Stored Properties\u003c/h2\u003e\n\u003cp\u003eIts initial value isn’t calculated until the first time it’s used.\u003c/p\u003e","title":"Properties"},{"content":"Structures and classes are the basic building blocks of the program’s code.\nThey have properties and functions.\nWe can define a structure or class in a single file, the external interface of that structure or class is automatically made for other code to use.\nThe common things: Define properties to store values Define methods to provide functionality Define subscripts to provide access to their values using subscript syntax Define initializers to set up their initial state Be extended to expand their functionality beyond a default implementation Conform to protocols to provide standard functionality of a certain kind The additional capabilities that classes support: Inheritance enables one class to inherit the characteristics of another. Type casting enables you to check and interpret the type of a class instance at runtime. Deinitializers enable an instance of a class to free up any resources it has assigned. Reference counting allows more than one reference to a class instance. Usages Definition struct Cat { var weight = 3 var legCount = 4 } class Dog { var weight = 5 var legCount = 4 var cloth = Cloth() // Every dog has a cloth in red color. var name = String? } class Cloth { var color = \u0026#34;red\u0026#34; var width = 15 var length = 45 } Create Instance let cat = Cat() let dogA = Dog() let dogB = Dog() let cloth = Cloth() Access Properties print(cat.legCount) print(dogA.legCount) print(dogB.cloth.color) Initialize class Dog { var weight: Int var legCount: Int init (){ self.weight = 5 self.legCount = 4 } init (weight: Int, legCount: Int = 4){ self.weight = weight self.legCount = legCount } } let dog = Dog(weight: 8) print(dog.weight) // 8 print(dog.legCount) // 4 Structures and Enumerations Are Value Types Value type will be copied the whole value when it’s being assigned.\nintegers, floating-point numbers, Booleans, strings, arrays and dictionaries are value types. They are implemented as structures behind the scenes.\nCollections like String, array, dictionary use an optimization to reduce the performance cost of copying. They aren’t been copied immediately when be assigned. It creates a reference and share the memory of the collection, collection just be copied when the modification occurs.\nValue Copy let count = 4 let legCount = count // value copy struct Rect { var width = 20 var height = 10 } var window = Rect() // It\u0026#39;s value copy, even the \u0026#39;window\u0026#39; and the \u0026#39;table\u0026#39; has the same width and height, they are two different instance of Rect. var table = window table.width = 25 print(table.width) // Print: 「25」 print(window.width) // Print: 「20」. It hasn\u0026#39;t affect the width of the window. enum Color: Int{ case green = 1, red, blue, white mutating func toWhite() { self = .white } } var windowColor = Color.blue let tableColor = windowColor // value copy windowColor.toWhite() print(windowColor) // white print(tableColor) // blue Classes Are Reference Types Swift just copy the reference of the instance when assigned an instance to another one.\nReference Copy class Dog { var age = 2 } let labulado = Dog() let pet = labulado // Just copy the reference. pet.age += 1 // The reference has\u0026#39;t change, just change the property \u0026#39;age\u0026#39; of the instance. print(labulado.age) // 3 The labulado and pet are different reference, but they share one instance of the Dog .\nIdentity Operators identical to (===) not identical to (!==) Use identity operators to check whether two constants or variables refer to the same single instance.\nif labulado === pet { print(\u0026#34;Refer to the same instance\u0026#34;) } else { print(\u0026#34;Refer to different instance\u0026#34;) } Equal Operators equal to (==) not equal to (!=) The basic value type can use the equal operators directly.\nvar s = \u0026#34;dd\u0026#34; var a = \u0026#34;dd\u0026#34; print(s == a) We must define the equal function for our own customs classed and structures, before we use the equal operators.\nclass Dog { var age = 2 // The equal function(operator override) static func == (left: Dog, right: Dog) -\u0026gt; Bool { return left.age == right.age } } let pet = Dog() pet.age += 1 let myPet = Dog() myPet.age = 3 print(pet === myPet) // false, they are refer to different instance of Dog print(pet == myPet) // true, here use the equal function above to check whether two instances are equal. Pointer The reference in Swift is similar to a pointer in C, but isn’t a direct pointer to an address in memory.\nThe standard library provides pointer and buffer types that we can use if we want to interact with pointer directly.\n","permalink":"https://wowios.com/post/language/swift/09structures-and-classes/","summary":"The object oriented programming.","title":"Structures and Classes"},{"content":"Syntax enum Direction { case up case down case left case right } Multiple case can appear on a single line, separated by commas:\nenum { case up, down, left, right } Use the Enumeration\nvar dir = Direction.up When we want to modify the var after the initialized, we can use a shorter form of the enumeration.\nvar dir = Direction.up dir = .down // The value\u0026#39;s type has been inferred when the value is in initializing. Matching Enumeration Values with a Switch Statement enum Direction { case up case down case left case right } var dir = Direction.right switch dir { case .up: print(\u0026#34;Go up\u0026#34;) case .down: print(\u0026#34;Go down\u0026#34;) case .left: print(\u0026#34;Go left\u0026#34;) case .right: print(\u0026#34;Go right\u0026#34;) } Iterating over Enumeration Cases Conform to the CaseIterable protocol, to make the enumeration’s case be iterable.\nenum Beverage: CaseIterable { case coffee, tea, juice } let cases = Beverage.allCases for c in cases { print(c) } Result:\ncoffee tea juice\nAssociated Values Here has two reference with associated values of type (Int, Int, Int, Int) or (String), use enumeration can choose one of them.\nenum Barcode { case upc(Int, Int, Int, Int) case qrCode(String) } Use the enumeration to create value, choose a type of barcode\nBut They can store only one of them at any given time.\nvar product = Barcode.upc(8, 810, 222, 888) product = .qrCode(\u0026#34;KINGKIYK\u0026#34;) // Assign another type to the same product. Use switch to check the type, and use let or var to extract each associated value.\nswitch product { case .upc(let numberSystem, let manufacturer, let product, let check): print(\u0026#34;UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\u0026#34;) case .qrCode(let productCode): print(\u0026#34;QR code: \\(productCode).\u0026#34;) } If all the associated values are extracted as constants or if all are extracted as variable, we can use var or let annotation before the case name, for brevity.\nswitch product { case let .upc(numberSystem, manufacturer, product, check): print(\u0026#34;UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\u0026#34;) case let .qrCode(productCode): print(\u0026#34;QR code: \\(productCode).\u0026#34;) } Raw Values As an alternative to associated values, enumeration cases come pre-populated with default values(raw values), which are all of the same type.\nEach raw value must be unique within its enumeration declaration.\nenum somechar: Character { case tab = \u0026#34;\\t\u0026#34; case lineFeed = \u0026#34;\\n\u0026#34; case carriageReturn = \u0026#34;\\r\u0026#34; } In Enumeration:\nRaw values are set by default, choose one to use when we need. Associated values are set before we want to use it. Implicitly Assigned Raw Values When we define an enumeration that store integer or string raw values, it’s no need to explicitly assign for each case, Swift can infer from the first one case.\nImplicitly assign with integer enum Day: Int{ case Sunday = 1, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } print(Day.Monday.rawValue) // Print: 「2」 Implicitly assign with string\nenum Direction: String{ case up, down, left, right } print(Direction.left.rawValue) // Print: 「left」 Initializing from a Raw Value enum Day: Int{ case Sunday = 1, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } enum Direction: String{ case up, down, left, right } let day = Day(rawValue: 3) // \u0026#39;day\u0026#39; is of type \u0026#39;Day?\u0026#39; and equals to Day.Tuesday let dir = Direction(rawValue: \u0026#34;right\u0026#34;) let other = Day(rawValue: 8) // Not found rawValue, \u0026#39;other\u0026#39; will be \u0026#39;nil\u0026#39; print(day!) print(dir) print(other) Result:\nTuesday Optional(Page_Contents.Direction.right) nil\nRecursive Enumerations Base on the associated values, recursively use the the associated operation.\nUse the indirect keyword to indicate that the associated value will be called recursively.\nThe \u0026lt;T\u0026gt; indicate to use generic type.\nenum Arithmetic\u0026lt;T\u0026gt; { case num(T) indirect case add(Arithmetic, Arithmetic) indirect case multiply(Arithmetic, Arithmetic) } Another way to indicate the indirect :\nindirect enum Arithmetic\u0026lt;T\u0026gt; { case num(T) case add(Arithmetic, Arithmetic) case multiply(Arithmetic, Arithmetic) } Use the recursive, and access the value with recursive function.\nlet five = Arithmetic\u0026lt;Int\u0026gt;.num(5) let nine = Arithmetic\u0026lt;Int\u0026gt;.num(9) let sum = Arithmetic.add(five, nine) let multiply = Arithmetic.multiply(sum, five) func evaluate(_ expression: Arithmetic\u0026lt;Int\u0026gt;) -\u0026gt; Int { switch expression { case let .num(value): // Here use the value binding to match the expression. return value case let .add(first, second): return evaluate(first) + evaluate(second) case let .multiply(first, second): return evaluate(first) * evaluate(second) } } print(evaluate(sum)) // 5 + 9 == 14 print(evaluate(multiply)) // (5 + 9) * 5 == 70 Result:\n14 70\n","permalink":"https://wowios.com/post/language/swift/08enumerations/","summary":"\u003ch2 id=\"syntax\"\u003eSyntax\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDirection\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e up\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e down\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eright\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eMultiple case can appear on a single line, separated by commas:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e up, down, \u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eright\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eUse the Enumeration\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e dir = Direction.up\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhen we want to \u003cstrong\u003emodify\u003c/strong\u003e the var after the initialized, we can use a shorter form of the enumeration.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e dir = Direction.up\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edir = .down    \u003cspan style=\"color:#75715e\"\u003e// The value\u0026#39;s type has been inferred when the value is in initializing.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"matching-enumeration-values-with-a-switch-statement\"\u003eMatching Enumeration Values with a Switch Statement\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDirection\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e up\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e down\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eright\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e dir = Direction.\u003cspan style=\"color:#66d9ef\"\u003eright\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eswitch\u003c/span\u003e dir {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e .up:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Go up\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e .down:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Go down\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e .\u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Go left\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e .\u003cspan style=\"color:#66d9ef\"\u003eright\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Go right\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"iterating-over-enumeration-cases\"\u003eIterating over Enumeration Cases\u003c/h2\u003e\n\u003cp\u003eConform to the \u003ccode\u003eCaseIterable\u003c/code\u003e protocol,  to make the enumeration’s case be iterable.\u003c/p\u003e","title":"Enumerations"},{"content":" A shortcut for accessing the member of a collection, list, or sequence. Classes, structures, and enumerations can define subscripts. Get result by square brackets [] . Use the subscript keyword. We can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript.\nSyntax subscript(index: Int) -\u0026gt; Int { get {} set(newValue) {} } subscript(index: Index) -\u0026gt; Int { // return directly } Example struct TimesTable { let mul: Int subscript(index: Int) -\u0026gt; Int { return mul * index } } let times = TimesTable(mul: 3) print(times[6]) Usage class Order { var names: [String] = [] subscript(index: Int) -\u0026gt; String { assert(index \u0026lt; names.count, \u0026#34;out of index\u0026#34;) return names[index] } } var order = Order() order.names.append(\u0026#34;Mike\u0026#34;) order.names.append(\u0026#34;Amy\u0026#34;) order.names.append(\u0026#34;John\u0026#34;) print(order[1]) // Amy The Dictionary has implements the subscript. Not all key has value, so the value is optional.\nvar numberOfLegs = [\u0026#34;cat\u0026#34;: 4, \u0026#34;bird\u0026#34;: 2, \u0026#34;dog\u0026#34;: 4] print(numberOfLegs[\u0026#34;dog\u0026#34;]!) // The result of the subscript is optional, here force unpack. Delete the value by assign it to nil .\nnumberOfLegs[\u0026#34;dog\u0026#34;] = nil Subscript Options Subscript can:\ntake any number and any type of input parameters. return a value of any type. take a varying number of parameter and provide default values. Subscript can’t:\nuse in-out parameters. Subscript Overloading The subscript defined with different count of parameters or different type of parameters.\nstruct Matrix { let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) { self.rows = rows self.columns = columns grid = Array(repeating: 0.0, count: rows * columns) } func indexIsValid(row: Int, column: Int) -\u0026gt; Bool { return row \u0026gt;= 0 \u0026amp;\u0026amp; row \u0026lt; rows \u0026amp;\u0026amp; column \u0026gt;= 0 \u0026amp;\u0026amp; column \u0026lt; columns } // Here is the overloading subscript(row: Int, column: Int) -\u0026gt; Double { get { assert(indexIsValid(row: row, column: column)) return grid[row * columns + column] } set { assert(indexIsValid(row: row, column: column)) grid[row * columns + column] = newValue } } // Here is the overloading subscript(index: Int) -\u0026gt; Double { get { assert(index \u0026lt; grid.count) return grid[index] } set { assert(index \u0026lt; grid.count) grid[index] = newValue } } } var mat = Matrix(rows: 4, columns: 5) print(mat) mat[1,1] = 2.5 print(mat) mat[5] = 7.7 print(mat) Type Subscripts The subscripts show above are instance subscript. Now let’s learn about the type subscripts.\nUse static keyword to indicate the type subscript within the classes, structures and enumerations. When define type subscript in the class, Use class keyword instead of static to allow the subclass to override the subscripts. enum Day: Int { case Monday = 1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday static subscript(n: Int) -\u0026gt; Day { return Day(rawValue: n)! } } let day = Day[3] print(day) ","permalink":"https://wowios.com/post/language/swift/12subscripts/","summary":"Set subscript(index: Int) in the class to index the data of the instance of the this class.","title":"Subscripts"},{"content":"Closures **are self-contained blocks of functionality that can be passed around and used in your code.\nGlobal and nested functions are special cases of closures.\nGlobal functions are closures that have name and don’t capture any value. Nested functions are closures that have a name and can capture values from the enclosing function. Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context. The sort() will sort at original array, and sorted() will sort and return a new sorted array.\nUsage Pass a closure to a function as a tool to do something.\nFor example, pass as a comparator to a sorted function.\nPass multiple closure to a function as some handler to deal the different circumstances after the function call.\nFor example, pass a completion and onFailure closure to a loadPicture function, and to do reaction for the picture load complete or fail.\nClosures’ Syntax {(parameters) -\u0026gt; return type in statements, the closure\u0026#39;s body } Pass a function closure to a function, as a tool to do some work.\nfunc compare(_ s1: String, _ s2: String) -\u0026gt; Bool{ return s1 \u0026gt; s2 } let names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: compare) // Here we pass a comparator to the sorted method. // Here the sortedNames is [\u0026#34;Ewa\u0026#34;, \u0026#34;Daniella\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;] An easy way to pass a function (or say a comparator) to a sorted method.\nThis is the inline closure.\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted({(_ s1: String, _ s2: String) -\u0026gt; Bool in return s1 \u0026gt; s2 }) Inferring Type From Context\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: { s1, s2 in return s1 \u0026gt; s2 } ) // The compiler will infer the parameter types and the return value type. Implicit Return in Single-Expression Closures\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: { s1, s2 in s1 \u0026gt; s2 } ) Shorthand Argument Names for Inline Closures\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: { $0 \u0026gt; $1 }) // \u0026#39;$0\u0026#39; means that getting the first parameter to do the comparation.. Operator Methods\nString type has its string-specific implementation of the grater than operator ‘\u0026gt;’ can be a method that has two parameters of type String, and return a value of type Bool. let names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: \u0026gt;) Trailing Closures Without Trailing Closures\nfunc someFunction(closure: () -\u0026gt; void) { } someFunction(closure: { // closure\u0026#39;s body, to do something. }) var sortedNames = names.sorted(by: {$0 \u0026gt;$1}) With Trailing Closures\nsomeFunction() { // Trailing closure\u0026#39;s body} var sortedNames = names.sorted() {$0 \u0026gt; $1} With Trailing Closures Omitting Parentheses\nvar sortedNames = names.sorted {$0 \u0026gt; $1} Apply a Provided Closure to Each Element of A Map Using the map() method, and give a closure to it. (The map method here omit the parentheses)\nThe closure say that input a Int , output a String , the process of the closure is after the in .\nlet digitNames = [ 0: \u0026#34;Zero\u0026#34;, 1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;, 4: \u0026#34;Four\u0026#34;, 5: \u0026#34;Five\u0026#34;, 6: \u0026#34;Six\u0026#34;, 7: \u0026#34;Seven\u0026#34;, 8: \u0026#34;Eight\u0026#34;, 9: \u0026#34;Nine\u0026#34; ] // A dictionary. let numbers = [16, 58, 510] // The type of number can be omitted, because it can be inferred from the value the map to be mapped. let numbersStr = numbers.map { (number: Int) -\u0026gt; String in var num = number // The \u0026#39;number\u0026#39; parameter can\u0026#39;t be modified, so we set a \u0026#39;num\u0026#39; to use its value. var str: String = \u0026#34;\u0026#34; repeat { str = digitNames[num % 10]! + str // remainder operate to get the num\u0026#39;s last digit. num /= 10 } while num \u0026gt; 0 return str } // Now the numbersStr is [\u0026#34;OneSix\u0026#34;, \u0026#34;FiveEight\u0026#34;,\u0026#34;FiveOneZero\u0026#34;] In the above, digitNames[num % 10]! use the exclamation point, because the result from digitNames is optional, it may be not found by num%10 .(The exclamation point is used to force-unwrap the String value)\nFunction Use Multiple Closures func loadPicture(from server: Server, completion: (Picture) -\u0026gt; Void, onFailure: () -\u0026gt; Void) { if let picture = download(\u0026#34;photo.jpg\u0026#34;, from: server) { completion(picture) } else { onFailure() } } When we call the loadPicture function, we should give it a completion and an onFailure closure as two handlers, so that after the network service done the work, with the handler, we can do something when the download complete or fail.\nCapturing Values A closure can capture constants and variables from the surrounding context in which it’s define. It can read those constants and modify those variables, even if the original scope no longer exist.\nNested function is a form of closure that can capture values from it outside scope.\nfunc run(count: Int) -\u0026gt; () -\u0026gt; Int{ var a = 5 func wait() -\u0026gt; Int { // The function \u0026#39;wait\u0026#39; capture the reference of \u0026#39;a\u0026#39; and \u0026#39;count\u0026#39; from the surrounding function. a += count return a } func go() -\u0026gt; Int { a += count * 2 return a } return wait // It returns a function, not a simple value. } print(run(count: 4)()) // Print: 9 // Capturing by reference ensures that \u0026#39;a\u0026#39; and \u0026#39;count\u0026#39; don’t disappear when the call to \u0026#39;run\u0026#39; ends, and also ensures that \u0026#39;a\u0026#39; is available the next time the \u0026#39;wait\u0026#39; function is called. // If the value isn\u0026#39;t mutated by a closure, Swift may store a copy of this value instead of capture it. let fun = run(count: 10) print(fun()) print(fun()) Result\n9 15 25\nThe first time use the run(count: 4) , it has a scope for run.\nThe second time use the run(count: 10), it has another scope.\nNOTE If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance. Swift uses capture lists to break these strong reference cycles.\nClosures Are Reference Types let fun = run(count: 10) print(fun()) print(fun()) let myFun = fun print(myFun()) Result\n15 25 35\nEscaping Closures In order to let the closure to be use in the function caller’s scope, or the closure want to use the content in the function caller’s scope, we should specify the closure parameter with @escaping , otherwise it will cause the compile-time error.\nThe escaping indicate that the closure is store in a value that’s defined outside the function.\nvar handlers: [() -\u0026gt; Void] = [] func addHandle(handle: @escaping () -\u0026gt; Void) { handlers.append(handle) let han: () -\u0026gt; Void han = handle // The handle must be specified with @escaping func run() { } addHandle(handle: run) The code follow is not allow, because the handle has’t been defined(create instance) before the addHandle return.\nfunc addHandle(handle: () -\u0026gt; Void) -\u0026gt; () -\u0026gt; Void { return handle // The closure \u0026#39;handle\u0026#39; can\u0026#39;t be use } Add the @escaping to solve the problem above. It will escape(store in a value outside the function) and then call the reference.\nfunc addHandle(handle: @escaping () -\u0026gt; Void) -\u0026gt; () -\u0026gt; Void { return handle } Capturing self Capturing self in an escaping closure makes it easy to accidentally create a strong reference cycle.\nWhen we want to use the properties in current instance of the class, must use self explicitly, or include self in the closure’s capture list.\nUse self Explicitly\nclass Person { var age = 23 func printAge(){ self.age = 24 print(self.age) } func printAgeOther(age: Int){ print(self.age)} // Here the self is needed certainly. Otherwise we can\u0026#39;t derferentiate the \u0026#39;age\u0026#39; of the instance and current function. } var person = Person() person.printAgeOther(age: 4) Include the self in Capture List\nfunc doSomething(_ fun: () -\u0026gt; Void){ fun() } class Person { var age = 23 func printAgeOther(){ [self] // The capture list. age = 22 print(age) // Here is use the \u0026#39;self.age\u0026#39; } func myFunc() { doSomething(){ [self] in print(age) // Here is use the \u0026#39;self.age\u0026#39; } } } var person = Person() person.printAgeOther() person.myFunc() Result\n22 22\nCapture self in structure or enumeration\nCan always refer to self implicitly. But an escaping closure can’t capture a mutable reference to self . func doSomething(_ fun: () -\u0026gt; Void){ fun() } func doSomethingElse(_ fun: @escaping () -\u0026gt; Void){ fun() } struct Person { var age = 23 mutating func myFunc(){ doSomething(){ age = 18 print(age) } // The follow code, \u0026#39;doSomethingElse\u0026#39; function\u0026#39;s parameter is escaping, it will trigger compiler error. // doSomethingElse(){ // age = 17 // print(age) // } } } var person = Person() person.myFunc() Autoclosures When the closure is assigned to a var or a let , it hasn’t been call, just give its function reference to other.\nIt can be use as delays evaluation or overtime judge.\nvar names = [\u0026#34;Mike\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Jhon\u0026#34;] print(names.count) let theRemover = { names.remove(at: 0)} // Get the closure\u0026#39;s reference. print(names.count) print(\u0026#34;Remove element: \\(theRemover())\u0026#34;) // Call the closure, run the closure\u0026#39;s body first time. print(names.count) Result\n3 3 Remove element: Mike 2\ntheRemover has a type () -\u0026gt; String\nAlso, we can write it in function like below.\nvar names = [\u0026#34;Mike\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Jhon\u0026#34;] print(names.count) func doSomething(action: () -\u0026gt; String){ print(\u0026#34;Remove elsemet: \\(action())\u0026#34;) } doSomething(action: {names.remove(at: 0)}) print(names.count) Use the @autoclosure , it has the same result as the code above.\nvar names = [\u0026#34;Mike\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Jhon\u0026#34;] print(names.count) func doSomething(action: @autoclosure () -\u0026gt; String){ print(\u0026#34;Remove elsemet: \\(action())\u0026#34;) } doSomething(action: names.remove(at: 0)) print(names.count) Use the @autoclosure and @escaping .\nvar names = [\u0026#34;Mike\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Jhon\u0026#34;] print(names.count) var funs: [() -\u0026gt; String] = [] func doSomething(action: @autoclosure @escaping () -\u0026gt; String){ print(\u0026#34;Remove elsemet: \\(action())\u0026#34;) funs.append(action) // It need the condition that action is escaping.(maybe because the action is a reference?)) name.append(\u0026#34;Jane\u0026#34;) // The \u0026#34;Jane\u0026#34; can be added to name. } doSomething(action: names.remove(at: 0)) print(names.count) The escaping means that the argument action is allowed to escape the function’s scope.\n","permalink":"https://wowios.com/post/language/swift/07closures/","summary":"The closures can cantains something by the curly bracket.","title":"Closures"},{"content":"The function has two way to affect the outside scope\nUse return value to tell the caller. Use the inout with reference to change the the original value outside. Function Usages Without Parameter and Return Value\nfunc sayHello() { print(\u0026#34;Hello\u0026#34;) } // Call the function, will print「hello」 sayHello() With Parameter\nfunc greet(name: String) { print(\u0026#34;Hello \\(name)\u0026#34;) } // Call the function pass the String as the input to the function, will print 「Hello Mike」 greet(name: \u0026#34;Mike\u0026#34;) With Multiple Parameter\nfunc addTwoNum(a: Int, b: Int) { var c = a + b print(c) } // Call the function, pass two parameter to the function, will print 「11」 addTwoNum(a: 5, b: 6) With Return Value\nonce defined the return type of a function, it must have a return operation when the function logic end.\nfunc addTwoNum(a: Int, b: Int) -\u0026gt; Int { var c = a + b return c } // The res will be assigned as 「12」 var res = addTwoNum(a: 3, b: 9) // The return value can be ignored. addTwoNum(a: 4, b: 9) With Multiple Return Value\n// Return as a tuple func getTwoNum() -\u0026gt; (Int, Int) { var a = 2 var b = 4 return (a, b) } var nums = getTwoNum() // Return as a optional dictionary func getThreeNum() -\u0026gt; (a: Int, b: Int, c: Int)? { var a = 2 var b = 4 var c = 3 return (a, b, c) } With Multiple Parameter and Multiple Return Value\nfunc minMax(array: Int[]) -\u0026gt; (min: Int, max: Int)? { if array.isEmpty {return nil} var curMin = array[0] var curMax = array[0] for value in array[1..\u0026lt;array.count] { if value \u0026lt; curMin { curMin = value } if value \u0026gt; curMax { curMax = value } } return (curMin, curMax) } // Use optional binding to check if let bound = minMax(array: [3, 5, 5, 6, 22, 13, 16, 24, 11]) { print(\u0026#34;Min: \\(bound.min)\u0026#34;) print(\u0026#34;Max: \\(bound.max)\u0026#34;) } With Implicit Return\nIt only allow the first one sentence to implicit return. // It will return the result of a + b func sum(a: Int, b: Int) -\u0026gt; Int{ a + b } // It will not return a value func sum(a: Int, b: Int) { a + b } // This can\u0026#39;t work!!! It will trige compile-time error. func getTwoNum() -\u0026gt; Int { var a = 2 var b = 4 a + b // Here not allow to implicit return value // The implicit return only allow the first one sentence } // This can work, because the getTwoNum only use first one sentence to return func get() -\u0026gt; (Int, Int) { var a = 5 return (5, 6) } func getTwoNum() -\u0026gt; (Int, Int) { get() // The implicit return can work. } Parameter Parameter Names and Argument Labels // Argument Labels func greet(person: String, from hometown: String) -\u0026gt; String { // The \u0026#39;person\u0026#39; and \u0026#39;hometown\u0026#39; are parameter names. // The \u0026#39;from\u0026#39; is a argument label of th second parameter. return \u0026#34;\\(person) is come from \\(hometown).\u0026#34; } print(greet(person: \u0026#34;Mike\u0026#34;, from: \u0026#34;New York\u0026#34;)) Omitting Argument Labels Use the underscore to omit the label\nfunc readFromFile(_ path: String) { print(path) } readFromFile(\u0026#34;./music/one.mp3\u0026#34;) Default Parameter Values func drawRect(x: Int, y: Int, w: Int, h: Int, color: (Int, Int, Int) = (0, 0, 0)) { // Here the color has default value (0, 0, 0) } Variadic Parameter The values passed will be made as as an array. For example, the Double... passed will be made as [Double] func average(_ nums: Double...) -\u0026gt; Double{ var total: Double = 0 for num in nums { total += num } return total / Double(nums.count) } print(average(3.3, 2.9, 4.6)) To make it unambiguous between the variadic parameter and normal parameters. The first parameter that comes after a variadic parameter must have an apparent argument label.\nfunc getOne(_ nums: Double..., cut cutLen: Int) -\u0026gt; Double{ return 1.0 } print(getOne(3.3, 2.9, 4.6, cut: 3)) // Another way func getAnotherOne(_ nums: Double..., cutLen: Int) -\u0026gt; Double{ return 1.0 } print(getAnotherOne(3.3, 2.9, 4.6, cutLen: 3)) In-Out Parameters Function parameters are constants by default.\nTo modify the parameter’s value and let the changes persist after the function call, we can use the inout keyword.\n(Using the inout keyword, we can change the origin value via the function call)\nThe inout value can’t have a default value, variadic parameters can’t be marked as inout .\nWithout inout\nfunc swap(_ a: Int, _ b: Int) { var temp = a a = b // It will trigger the compile-time error. b = temp // The parameters are constant. } var x = 2 var y = 3 swap(x, y) print(\u0026#34;x = \\(x), y = \\(y)\u0026#34; With inout\nfunc swap(_ a: inout Int, _ b: inout Int) { var temp = a a = b b = temp } var x = 2 var y = 3 swap(\u0026amp;x, \u0026amp;y) // Here should use the reference sign so that the funtion can konw where to change the value of the original variable. print(\u0026#34;x = \\(x), y = \\(y)\u0026#34;) // It will print 「x = 3, y = 2」 Function Types To describe a function’s input and output.\nSuch as (Int, Int) -\u0026gt; Int or () -\u0026gt; Void .\nfunc addTwoInts(_ a: Int, _ b: Int) -\u0026gt; Int { return a + b } var mathFunction: (Int, Int) -\u0026gt; Int = addTwoInts Function Types as Parameter Type\nfunc addTwoInts(_ a: Int, _ b: Int) -\u0026gt; Int { return a + b } func printResult(_ mathFunc: (Int, Int) -\u0026gt; Int, _ a: Int, _ b: Int) { print(\u0026#34;Result: \\(mathFunc(a, b))\u0026#34;) } printResult(addTwoInts, 2, 7) // Print 「Result: 9」 Function Types as Return Types\nfunc stepForward(_ input: Int) -\u0026gt; Int { return input + 1 } func stepBackward(_ input: Int) -\u0026gt; Int { return input - 1 } // Return a function type func chooseStepFunction(backward: Bool) -\u0026gt; (Int) -\u0026gt; Int { return backward ? stepBackward : stepForward } var cur = 3 let moveNearToZero = chooseStepFunction(backward: cur \u0026gt; 0) // So the moveNearToZero will refers to the stepBackward() function. while cur != 0 { print(\u0026#34;Cur: \\(cur)\u0026#34;) cur = moveNearToZero(cur) } result:\ncur: 3 cur: 2 cur: 1\nNested Function Hidden from the outside world by default.\nOnly when the nested function be returned, it can be used in the caller’s scope.\nfunc chooseStepFunction(backward: Bool) -\u0026gt; (Int) -\u0026gt; Int { func stepForward(input: Int) -\u0026gt; Int { return input + 1 } func stepBackward(input: Int) -\u0026gt; Int { return input - 1 } return backward ? stepBackward : stepForward } var cur = -4 let moveNearToZero = chooseStepFunction(backward: cur \u0026gt; 0) // moveNearToZero now is refers tyo the nested stepForward() cur = moveNearToZero(cur) ","permalink":"https://wowios.com/post/language/swift/06function/","summary":"Call the function(method) to do something detail.","title":"Function"},{"content":" loop while for-in repeat while condition branch if\nswitch\nwhere\nguard\ncontrol transfer statements break continue fallthrough return throw Loop For-In Loops var pets = [\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;] for pet in pets { print(pet) } for index in 0..\u0026lt;2 { print(pets[index]) } // if we don\u0026#39;t need the value from the 0..\u0026lt;2, use the underscore to ignore the value. var n = 1 for _ in 0..\u0026lt;2 { print(n) n += 1 } var words = [11: \u0026#34;fine\u0026#34;, 2: \u0026#34;happiness\u0026#34;] for (key, word) in words { print(\u0026#34;\\(key): \\(word)\u0026#34;) } Stride Function\nlet minutes = 60 let interval = 5 for tickMark in stride(from: 0, to: minutes, by: interval) { // render the mark every 5 minutes. // 0, 5, 10, ... , 50, 55 } // closed range for tickMark in stride(from: 0, through: minutes, by: inerval { // render the mark every 5 minutes. // 0, 5, 10, ... , 50, 55, 60 } The for-in can be only use to the object which conform to the Sequence protocol.\nWhile var a = 0 while a \u0026lt; 10 { print(a) // 0 to 9 a += 1 } Repeat While The content that repeat while enclose with {} will run at least once.\nvar a = 0 while a \u0026lt; 0 { print(a) a += 1 } // will not print repeat { print(a) a += 1 }while a \u0026lt; 0 // will print 0 Condition If var a = 4 if a \u0026lt; 5 { // smaller than 5 } else if a \u0026gt; 5 { // bigger than 5 } else { // equal to 5 } Switch The body of each case must contain at least one executable statement.\nNo Implicit Fallthrough: no need to write ‘break’ in each case, switch do only one case.\nvar s: String = \u0026#34;as\u0026#34; switch s { case \u0026#34;aa\u0026#34;, \u0026#34;AA\u0026#34;: print(\u0026#34;not the target\u0026#34;) case \u0026#34;as\u0026#34;: print(\u0026#34;yes\u0026#34;) default: print(\u0026#34;I don\u0026#39;t know\u0026#34;) } Interval Matching\nvar a = 40 var amount: String? switch a { case ..\u0026lt;0: amount = nil case 0: amount = \u0026#34;no\u0026#34; case 1...10: amount = \u0026#34;few\u0026#34; case 11..\u0026lt;50: amount = \u0026#34;some\u0026#34; case 50..\u0026lt;100: amount = \u0026#34;many\u0026#34; default: amount = \u0026#34;much\u0026#34; } Tuples\nUse underscore as a wildcard pattern. The point (0, 0) would match case (0, 0) first, and so all other matching cases would be ignored. let point = (1, 1) switch point { case (0, 0): print(\u0026#34;It\u0026#39;s origin\u0026#34;) case (_, 0): print(\u0026#34;It\u0026#39;s on x axis\u0026#34;) case (0, _): print(\u0026#34;It\u0026#39;s on y axis\u0026#34;) case (-2...2, -2...2): print(\u0026#34;It\u0026#39;s in the box\u0026#34;) default: print(\u0026#34;Out of box\u0026#34;) } Value Bindings\nThe case can name value or values from the matched test, for use in the body of the case. In this way, we can choose a matched pattern to do specific work. let point = (2, 0) switch point { case (let x, 0): print(\u0026#34;(\\(x),0) is on x axis\u0026#34;) case (0, let y): print(\u0026#34;(0, \\(y) is on y axis\u0026#34;) case let(x, y): print(\u0026#34;(\\(x), \\(y)) not on axis\u0026#34;) } Where\nAdd a condition for the value or values from the test. let point = (2, -2) switch point { case let(x, y) where x == y: print(\u0026#34;(\\(x), \\(y)) is on the line y = x\u0026#34;) case let(x, y) where x == -y: print(\u0026#34;(\\(x), \\(y) is on the line y = -x\u0026#34;) case let(x, y): print(\u0026#34;(\\(x), \\(y)) others\u0026#34;) } Compound Cases\nMultiple cases can compounded into one. The pattern can be written over multiple lines. let c = \u0026#34;a\u0026#34; switch c { case \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;: print(\u0026#34;It\u0026#39;s a vowel.\u0026#34;) case \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;: print(\u0026#34;It\u0026#39;s a consonant.\u0026#34;) default: print(\u0026#34;It\u0026#39;s not an alphabet.\u0026#34;) } Compound with tuple binding\nEvery pattern in a case must include the temporary object(distance), so the code in the body of the case can always access a value for distance.\nlet point = (1, 0) switch point { case (0, let distance), (let distance, 0): print(\u0026#34;point is on the axis, distance \\(distance)\u0026#34;) default: print(\u0026#34;point isn\u0026#39;t on the axis\u0026#34;) } Control Transfer Statements Continue Tells a loop to stop what it’s doing and start again at the beginning of the next iteration through the loop.\nvar nums: [Int] = [] for n in 1...10 { if n % 2 == 0 { continue } nums.append(n) } print(nums) resule\n[1, 3, 5, 7, 9]\nBreak var nums: [Int] = [] for n in 1...10 { if n == 5 { break } nums.append(n) } print(nums) result\n[1, 2, 3, 4]\nBreak in a switch\ncomments aren’t statement, use a break when the case body is empty. let n = 5 switch n { case 1: print(\u0026#34;one\u0026#34;) case 2: print(\u0026#34;I want to break\u0026#34;) break print(\u0026#34;two\u0026#34;) // it won\u0026#39;t do this case 3: print(\u0026#34;three\u0026#34;) default: break } Fallthrough In Swift , oneswitch only execute one case . If we want to execute multiple cases, use the fallthrough .\nlet n = 5 switch n { case 5: print(\u0026#34;five\u0026#34;) fallthrough // go on the code in the switch default: print(\u0026#34;believe it or not\u0026#34;) break } Labeled Statements The break and continue can only affect the current for, while, switch, repeat while. So when we want to break or continue the outside loop or switch, we can use the labeled statements.\nbreak\nvar a = 1 var sum = 0 aLoop: while a \u0026lt; 10 { while a \u0026lt; 5 { if a == 3 { a += 5 break aLoop } a += 1 print(\u0026#34;add a: \\(a)\u0026#34;) } print(a) a += 1 } result\nadd a: 2 add a: 3\ncontinue\nvar a = 1 var sum = 0 aLoop: while a \u0026lt; 10 { while a \u0026lt; 5 { if a == 3 { a+=5 // now the a is 8 continue aLoop } a += 1 print(\u0026#34;add a: \\(a)\u0026#34;) } print(a) a += 1 } result\nadd a: 2 add a: 3 8 9\nIt continue the outside while loop.\nEarly Exit A guard must have else clause after it. It’s to exit early.\nfunc play(ball: String?) { guard let str = ball else { print(\u0026#34;no ball\u0026#34;) return // the guard\u0026#39;s else can\u0026#39;t fall through, here we use the return to end the excution. } print(str) // it\u0026#39;s available after the guard\u0026#39;s statement. } play(ball: nil) Checking API Availability if #available(iOS 10, macOS 10.12, *) { } else { // Fall back to earlier iOS and macOS APIs } ","permalink":"https://wowios.com/post/language/swift/05control-flow/","summary":"loop, condition branch, control transfer.","title":"Control Flow"},{"content":" array set dictionary collection type use are generic, the type of element is specific.\nArray With ordering. Access by subscript. Variable-length. var someInts: [Int] = [] someInts.append(2) someInts = [] // Empty the array Create by class\nvar someDoubles = Array(repeating: 0.0, count: 3) print(someDoubles) var otherDoubles = Array(repeating: 2.5, count: 3) print(otherDoubles) var addedDoubles = someDoubles + otherDoubles // concatenate two array into one print(addedDoubles) result:\n[0.0, 0.0, 0.0] [2.5, 2.5, 2.5] [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]\nCreate By Array Literal\nvar shoppingList = [\u0026#34;tomato\u0026#34;, \u0026#34;milk\u0026#34;] // Appending shoppingList.append(\u0026#34;noodles\u0026#34;) shoppingList += [\u0026#34;rice\u0026#34;] shoppingList += [\u0026#34;apple\u0026#34;, \u0026#34;juice\u0026#34;] // Now the array is [\u0026#34;tomato\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;noodles\u0026#34;, \u0026#34;rice\u0026#34;, \u0026#34;apples\u0026#34;, \u0026#34;juice\u0026#34;] Accessing\nprint(\u0026#34;Count of stuff: \\(shoppingList.count)\u0026#34;) // the \u0026#39;count\u0026#39; property is read-only. if shoppingList.isEmpty { print(\u0026#34;Nothing to buy.\u0026#34;) } else { print(\u0026#34;Have something to buy.\u0026#34;) } // Accessing var oneStuff = shoppingList[2] // get the \u0026#34;noodles\u0026#34; Modifying\n// Modifying shoppingList[2] = \u0026#34;dumplings\u0026#34; // Modifying a range of value shoppingList[3...5] = [\u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;banana\u0026#34;] shoppingList[3...5] = [\u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;] // it will remove the element from 3 to 5 and just insert with two new element at position 3. //shoppingList[3...5] = [\u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;bread\u0026#34;, \u0026#34;cookie\u0026#34;] the 5 is out of array\u0026#39;s bound now, so it will trigger a run-time error. shoppingList[3...4] = [\u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;peach\u0026#34;] // it can work, just replace two element shoppingList[3] and shoppingList[4] with three new elenment. // now the array is [\u0026#34;tomato\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;dumpings\u0026#34;, \u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;peach\u0026#34;] // insert(_:at:) shoppingList.insert(\u0026#34;drink\u0026#34;, at: 0) // now the shoppingList is: [\u0026#34;drink\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;dumpings\u0026#34;, \u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;peach\u0026#34;] // remove(at:) let thing = shoppingList.remove(at: 1) // The \u0026#34;thing\u0026#34; is assiged to be \u0026#34;tomato\u0026#34; // Any gaps in an array are closed when an item is removed. // So after the removing, the shoppingList is: [\u0026#34;drink\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;dumpings\u0026#34;, \u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;peach\u0026#34;] let last = shoppingList.removeLast() // remove the \u0026#34;peach\u0026#34; var str = shoppingList[0] str.append(\u0026#34;s\u0026#34;) // this will not affect the string in the shoppingList, because the String is value type, it will be copied when be passed (assigned). shoppingList[0].append(\u0026#34;s\u0026#34;)// this will affect the string in the shoppingList. // now the array is [\u0026#34;drinks\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;dumpings\u0026#34;, \u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;] Iterating Over an Array\nfor item in shoppingList { print(item) } for (i, value) in shoppingList.enumerated() { print(\u0026#34;Item \\(i): \\(value)\u0026#34; } // here the \u0026#39;i\u0026#39; is a subscript of the array. Sets With no defined ordering. An item only appears once. A type must be hashable in order to be stored in a set—that is, the type must provide a way to compute a hash value for itself. if two objects’ hash values are equal, they are equally.\nAll of Swift’s basic types are hashable by default. (String, Int, Double, Bool, Enumeration)\nCreate a set create by an Array literal\nvar words: Set\u0026lt;Character\u0026gt; = [\u0026#34;d\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;e\u0026#34;] print(words) print(words.count) result\n[\u0026ldquo;d\u0026rdquo;, \u0026ldquo;i\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;v\u0026rdquo;] 4\nIn a shorter form\nvar words: Set = [\u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;] create an instance of class Set\nvar letter = Set\u0026lt;Character\u0026gt;() letter.insert(\u0026#34;H\u0026#34;) letter.insert(\u0026#34;e\u0026#34;) letter.insert(\u0026#34;a\u0026#34;) letter.insert(\u0026#34;r\u0026#34;) print(letter) print(letter.count) result\n[\u0026ldquo;a\u0026rdquo;, \u0026ldquo;r\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;H\u0026rdquo;] 4\nAccessing var words: Set = [\u0026#34;hide\u0026#34;, \u0026#34;ice\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;big\u0026#34;] print(words.count) // it\u0026#39;s read-only if words.isEmpty { print(\u0026#34;words is empty.\u0026#34;) } Modifying words.insert(\u0026#34;book\u0026#34;) var wordGet = words.remove(\u0026#34;ice\u0026#34;) // if words doesn\u0026#39;t contain \u0026#34;ice\u0026#34;, the removing will be invalid and the wordGet will be nil. Iterating Over a Set for word in words { print(word) } Iterating in a specific order\nfor word in words.sorted() { print(word) } Set Operations intersection(_: ) create a new set with only the values common to both sets symmetricDiffierence(_: ) create a new set with values in either set, but not both union(_: ) create a new sew with values with all of the values in both sets subtracting(_: ) create a new set with values not in the ‘b’ set var a: Set = [1, 2, 5, 6] var b: Set\u0026lt;Int\u0026gt; = [1, 3, 5] var intersection = a.intersection(b) // a \u0026amp; b var difference = a.symmetricDifference(b) // !a \u0026amp; !b var union = a.union(b) // a or b var subtract = a.subtracting(b) // a - b print(intersection) print(difference) print(union) print(subtract) result:\n[5, 1] [2, 6, 3] [3, 2, 1, 6, 5] [6, 2]\nMembership and Equality ==\nisSubset(of: )\nisSuperset(of: )\nisStrictSubset(of: )\nIt’s a subset but not equal to.\nisStrictSuperset(of: )\nIt’s a superset but not equal to.\nisDisjoint(with: )\nTwo set has no values in common. They are independent with each other.\nlet all: Set = [\u0026#34;😂\u0026#34;, \u0026#34;😎\u0026#34;, \u0026#34;😺\u0026#34;, \u0026#34;🙋🏼‍♂️\u0026#34;] let me: Set = [\u0026#34;🙋🏼‍♂️\u0026#34;] let emoj: Set = [\u0026#34;😂\u0026#34;, \u0026#34;😎\u0026#34;] let other: Set = [\u0026#34;😂\u0026#34;, \u0026#34;😎\u0026#34;, \u0026#34;😺\u0026#34;, \u0026#34;🙋🏼‍♂️\u0026#34;] print(\u0026#34;\u0026#39;me\u0026#39; is subset of \u0026#39;all\u0026#39;: \u0026#34; + String(me.isSubset(of: all))) print(\u0026#34;\u0026#39;all\u0026#39; is superset of \u0026#39;emoj\u0026#39;: \u0026#34; + String(all.isSuperset(of: emoj))) print(\u0026#34;\u0026#39;all\u0026#39; is superset of \u0026#39;other\u0026#39;: \u0026#34; + String(all.isSuperset(of: other))) print(\u0026#34;\u0026#39;all\u0026#39; is subset of \u0026#39;other\u0026#39;: \u0026#34; + String(all.isSubset(of: other))) print(\u0026#34;\u0026#39;all\u0026#39; is strict superset of \u0026#39;other\u0026#39;: \u0026#34; + String(all.isStrictSuperset(of: other))) print(\u0026#34;\u0026#39;all\u0026#39; is strict subset of \u0026#39;other\u0026#39;: \u0026#34; + String(all.isStrictSuperset(of: other))) print(\u0026#34;\u0026#39;other\u0026#39; is superset of \u0026#39;all\u0026#39;: \u0026#34; + String(other.isSuperset(of: all))) print(\u0026#34;\u0026#39;other\u0026#39; is subset of \u0026#39;all\u0026#39;: \u0026#34; + String(other.isSubset(of: all))) result:\n\u0026lsquo;me\u0026rsquo; is subset of \u0026lsquo;all\u0026rsquo;: true \u0026lsquo;all\u0026rsquo; is superset of \u0026rsquo;emoj\u0026rsquo;: true \u0026lsquo;all\u0026rsquo; is superset of \u0026lsquo;other\u0026rsquo;: true \u0026lsquo;all\u0026rsquo; is subset of \u0026lsquo;other\u0026rsquo;: true \u0026lsquo;all\u0026rsquo; is strict superset of \u0026lsquo;other\u0026rsquo;: false \u0026lsquo;all\u0026rsquo; is strict subset of \u0026lsquo;other\u0026rsquo;: false \u0026lsquo;other\u0026rsquo; is superset of \u0026lsquo;all\u0026rsquo;: true \u0026lsquo;other\u0026rsquo; is subset of \u0026lsquo;all\u0026rsquo;: true\nDictionary keys have same type, values have same type with no ordering each value is associated with a unique key key is unique, values may be same Swift’s Dictionary type is bridged to Foundation’s NSDictionaryclass. The key must conform to the Hashable protocol.\nCreate a dictionary\nby class\nvar pet = Dictionary\u0026lt;Int, String\u0026gt;() pet[11] = \u0026#34;dog\u0026#34; // adding key-value pair pet[23] = \u0026#34;bear\u0026#34; by literal\nvar pet = [11: \u0026#34;dog\u0026#34;, 23: bear] properties\nprint(pet.count) print(pet.isEmpty) if pet[23] != nil { print(pet) } result\n2 false\nUpdating\npet[11] = \u0026#34;cat\u0026#34; // update the value if let oldValue = pet.updateValue(\u0026#34;deer\u0026#34;, forKey: 23) { // now the pet is: [11: \u0026#34;cat\u0026#34;, 23: \u0026#34;deer\u0026#34;], and the oldValue is bear(optional). } else { print(\u0026#34;oldValue is nil\u0026#34;) } Removing\npet[11] = nil // remove a key-value pair. pet.removeValue(forKey: 23) // remove a key-value pair. pet = [11: \u0026#34;cat\u0026#34;, 23: \u0026#34;dog\u0026#34;] pet.removeAll() pet = [11: \u0026#34;cat\u0026#34;, 23: \u0026#34;dog\u0026#34;] pet = [:] // clear all Iterating Over a Dictionary\nby key and value\nfor (key, value) in pet { print(\u0026#34;\\(key): \\(value)\u0026#34;, terminator: \u0026#34;\\t\u0026#34;) } result\n23: dog 11: cat\nby key or value\nvar pet = [11: \u0026#34;cat\u0026#34;, 23: \u0026#34;dog\u0026#34;] print() for key in pet.keys { print(\u0026#34;\\(key) \u0026#34;, terminator: \u0026#34; \u0026#34;) } print() for value in pet.values { print(\u0026#34;\\(value)\u0026#34;, terminator: \u0026#34; \u0026#34;) } result\n11 23 cat dog\nGet an Array from key or value\n```swift let keys = [Int](pet.keys) ``` ```swift let values = [String](pet.values) ``` get in order by calling sorted(), the object who call the sorted should implements the Comparable.\nlet keys = [Int](pet.keys.sorted()) the pet.sorted(using: ) need a Comparator to sort the dictionary.\nSummary Creating\nArray\nvar pet: [String] = [\u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;]\nSet\nvar pet: Set\u0026lt;String\u0026gt; = [\u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;]\nvar pet: Set = [\u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;]\nDictionary\nvar pet: Dictionary\u0026lt;Int, String\u0026gt; = Dictionary\u0026lt;Int, String\u0026gt;()\nvar pet = [:]\nvar pet: Dictionary\u0026lt;Int, String\u0026gt; = [23: \u0026quot;dog\u0026quot;, 11: \u0026quot;cat\u0026quot;]\nvar pet = [23: \u0026quot;dog\u0026quot;, 11: \u0026quot;cat\u0026quot;]\nAccessing and Modifying\nthe Array and Dictionary can access by [someKey]directly , but the Set access by insert() and remove() .\nFor-in\nArray\nfor word in words {} Set\nfor word in words {} Dictionary\nfor (key, value) in words {} Operation\nTo generate new set, Set has some operations between two sets.\n","permalink":"https://wowios.com/post/language/swift/04collection-type/","summary":"The array, set, and dictionary.","title":"Collection Type"},{"content":"String type is bridged with Foundation’s NSString. Foundation extends String to expose methods defines by NSString. If import Foundation, you can access those NSString methods on String without casting.\nString Literals // \u0026#34;Hello World!\u0026#34; is a String literal. let sentence = \u0026#34;Hello World!\u0026#34; // Multiline let story = \u0026#34;\u0026#34;\u0026#34; There are some people in the room. They are having a party. Because today is the Christmas. \u0026#34;\u0026#34;\u0026#34; // every line has the line breaks. // the start and end sign(\u0026#34;\u0026#34;\u0026#34;) must take a single line. // backlash(\\), it means that the string is not broken. Then line breaks not to be part of the string\u0026#39;s value. let content = \u0026#34;\u0026#34;\u0026#34; In a happy atmos\\ phere. We start the conversation \u0026#34;\u0026#34;\u0026#34; print(content) // result: In a happy atmosphere. We start the conversation. // Alignment of quotation marks in the multiline string. let desc = \u0026#34;\u0026#34;\u0026#34; Ha it\u0026#39;s so funny. \u0026#34;\u0026#34;\u0026#34; print(desc) // result: Ha its so funny. let desc = \u0026#34;\u0026#34;\u0026#34; Ha it\u0026#39;s so funny. \u0026#34;\u0026#34;\u0026#34; print(desc) // result: Ha its so funny. let desc = \u0026#34;\u0026#34;\u0026#34; Ha it\u0026#39;s so funny. \u0026#34;\u0026#34;\u0026#34; print(desc) // result: Ha its so funny. Special Character in String Literals\n\\0 null character \\ backslash \\t horizontal tab \\n line feed \\r carriage return \\” double quotation mark ' single quotation mark \\u{n} n is a 1-8 digit hexadecimal let dollarSign = \u0026#34;\\u{24}\u0026#34; // $ let blackHeart = \u0026#34;\\u{2665}\u0026#34; // ♥ let redHeart = \u0026#34;\\u{1f496}\u0026#34; // 💖 // Because multiline string literals use three double quotation marks, one double quotation can be used in multiline string litral without escaping it. // And should escape the three double quotation which inside the multiline string literal. let marks = \u0026#34;\u0026#34;\u0026#34; Escaping the first quotation mark \\\u0026#34;\u0026#34;\u0026#34; Escaping all three quotation \\\u0026#34;\\\u0026#34;\\\u0026#34; \u0026#34;\u0026#34;\u0026#34; // Abosultly string // use the #\u0026#34;\u0026#34;\u0026#34; and \u0026#34;\u0026#34;\u0026#34;# to include a absultly pure string. let words = #\u0026#34;\u0026#34;\u0026#34; It sounds very good.\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;# print(words) // result: It sounds very good.\u0026#34;\u0026#34;\u0026#34; // use the #\u0026#34; and \u0026#34;# to include a absultly pure string. let words = #\u0026#34;It sounds \u0026#34;\u0026#34;\u0026#34; very good.\u0026#34;# print(words) // result: It sounds \u0026#34;\u0026#34;\u0026#34; very good. // So it has no need to add escaping character(\\). // If we want to cancel the effect of \u0026#39;#\u0026#39; in a string, use another \u0026#39;#\u0026#39; near the character. let otherWords = #\u0026#34;hello \\#rworld\u0026#34;# print(otherWords) // result: // If we want to cancel the effect of \u0026#39;#\u0026#39; in a multiline string, use another \u0026#39;#\u0026#39; near the character. let otherWords = #\u0026#34;\u0026#34;\u0026#34; hello \\###rworld \u0026#34;\u0026#34;\u0026#34;# print(otherWords) // result: hello world Initializing an Empty String\n// They are all empty, they are equivalent to each other. var myName = \u0026#34;\u0026#34; var hisName = String() // Find out if the string is empty. if myName.isEmpty { print(\u0026#34;It\u0026#39;s empty.\u0026#34;) } String Mutability var a = \u0026#34;Horse \u0026#34; var b = \u0026#34;carriage\u0026#34; b = a + b // it willf create a new String and assign to b let str = \u0026#34;he\u0026#34; str += \u0026#34;ran\u0026#34; // it will trigger the compile-time error. // constant string cannot be modified. Strings Are Value type If we create a String value, that String value is copied when it passed to a function or method. When it’s passed, it’s not the original version.\nYou can be confident that the string you are passed won’t be modified unless you modify it yourself.\nSwift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary.\nCharacter for character in \u0026#34;dog!\u0026#34; { print(character) } let c : Character = \u0026#34;!\u0026#34; let characters : [Character] = [\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;s\u0026#34;] let str = String(characters) // concatenation str.append(c) let pet = \u0026#34;dog \u0026#34; + \u0026#34;cat\u0026#34; var name = \u0026#34;Mike \u0026#34; name += \u0026#34;Amy\u0026#34; // multiline string let start = \u0026#34;\u0026#34;\u0026#34; one two \u0026#34;\u0026#34;\u0026#34; let end = \u0026#34;\u0026#34;\u0026#34; three \u0026#34;\u0026#34;\u0026#34; let goodStart = \u0026#34;\u0026#34;\u0026#34; one two \u0026#34;\u0026#34;\u0026#34; print(start + end) // result: // one // twothree print(goodStart + end) // result: // one // two // three String Interpolation let value = 3 let message = \u0026#34;The value is \\(value). Four times is \\(value * 4). \\(\u0026#34;It\u0026#39;s \u0026#34; + \u0026#34;fine.\u0026#34;)\u0026#34; print(message) // result: the value is 3. Four times is 12. It\u0026#39;s fine. print(#\u0026#34;It\u0026#39;s a \\(value).\u0026#34;#) // It will print the literal string without escaping the \u0026#39;value\u0026#39;. // It\u0026#39;s a \\(value). print(#\u0026#34;It\u0026#39;s a \\#(value).\u0026#34;#) // It will escape the value. // It\u0026#39;s a 3. Unicode print(\u0026#34;\\u{E9}\u0026#34;) // é print(\u0026#34;\\u{65}\\u{301} // é // two character compound into one character automatically. print(\u0026#34;\\u{1f425}\u0026#34;) // 🐥 let c = \u0026#34;\\u{1F1E8}\\u{1F1F3}\u0026#34; print(c + String(c.count) // 🇨🇳1 // two character compound into one. cn = c + n Counting Character let str = \u0026#34;chick\\u{1f425}\u0026#34; print(str + String(str.count)) // result: chick🐥6 var word = \u0026#34;cafe\u0026#34; word += \u0026#34;\\u{301}\u0026#34; print(word + String(word.count)) // result: café4 Accessing and Modifying a String Accessing\nstr.startIndex\nThe startIndex is 0.\nstr.endIndex\nThe endIndex is equals to count, it points to the next to the last element.\nIndex is a class. It’s special, just like a pointer. It often not start at 0.\nstr.index(before : String.Index) str.index(at : String.Index) str.index(after : String.Index) var str = \u0026#34;peak\u0026#34; str[str.startIndex] = \u0026#34;g\u0026#34; // not allowed, can not assign through subscript print(str[str.startIndex] // subscript is get-only, the result is : p print(str[str.index(before: str.endIndex)]) // result: k print(str[str.index(after: str.startIndex)]) // result: e print(str[str.index(str.startIndex, offsetBy:2)])// result: a for c in str.indices { print(\u0026#34;\\(str[c]) \u0026#34;, terminator: \u0026#34;\u0026#34;) // set terminator empty to cancel the line feed. } // result: p e a k Inserting and removing\nword.insert(_: Character, at: String.Index) word.remove(at: String.Index) message.insert(contentsOf: Collection, at: String.Index) message.removeSubrange(_: Range\u0026lt;String.Index\u0026gt;) // Insert and remove single character var word = \u0026#34;world\u0026#34; word.insert(\u0026#34;k\u0026#34;, at: word.index(word.endIndex, offsetBy: -2)) word.remove(at: word.index(word.startIndex, offsetBy: 4)) word.remove(at: word.index(before: word.endIndex)) print(word) // result: work // Insert and remove a substring var message = \u0026#34;we\u0026#34; message.insert(contentsOf : \u0026#34;lcome to here\u0026#34;, at : message.endIndex) print(message) //print: welcome to here message.removeSubrange(message.index(message.startIndex, offsetBy: 7)..\u0026lt;message.endIndex) print(message) //print: welcome Substrings\nString is value type, it’s stable but not efficient when cut the string to get substring.\nSubstring is a type. Just to reference the Substring inside the whole String.\nvar str = \u0026#34;Hello, World!\u0026#34; let index = str.firstIndex(of: \u0026#34;,\u0026#34;) ?? str.endIndex var sub = str[..\u0026lt;index] // It doesn\u0026#39;t has a whole copy of String, just create a new type \u0026#39;Substring\u0026#39; to reference the part we cut. print(sub) sub.remove(at: sub.startIndex) print(sub) // print: ello print(str) // It doesn\u0026#39;t affect the origin String, because \u0026#39;sub\u0026#39; is a independent Substring instance. let newString = String(sub)// Create an instance of String. Transform a subString to String for long term keep. Comparing Strings var a = String(\u0026#34;word\u0026#34;) var b = String(\u0026#34;word\u0026#34;) print(a == b) // print: true var str = String(\u0026#34;Hello, world!\\u{E9}\u0026#34;) var quote = String(\u0026#34;Hello, world!\\u{65}\\u{301}\u0026#34;) if str == quote { print(\u0026#34;Equal\u0026#34;) // The combine result of \u0026#39;quote\u0026#39; is same as in str. So the these two Strings are equal. // e + ́ = é } // print: equal // Single character var c = String(\u0026#34;\\u{41}\u0026#34;) var d = String(\u0026#34;\\u{041}\u0026#34;) print(c == d) // print: true var c = String(\u0026#34;\\u{41}\u0026#34;) var d = String(\u0026#34;\\u{0410}\u0026#34;) print(c == d) // print: false Prefix and Suffix Equality The hasPrefix(_:) and hasSuffix(_:) methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string.(character one by one compare)\nvar sentences = [ \u0026#34;Hello, world!\u0026#34;, \u0026#34;Hello, friend!\u0026#34;, \u0026#34;Hi,Hello, friends all!\u0026#34;, \u0026#34;Welcome, friend!\u0026#34;, \u0026#34;Welcome, friends all!\u0026#34; ] for sentence in sentences { if sentence.hasPrefix(\u0026#34;Hello\u0026#34;) { print(sentence) } } // Hello, world! // Hello, friend! for sentence in sentences { if sentence.hasSuffix(\u0026#34;friend!\u0026#34;) { print(\u0026#34;[\u0026#34; + sentence + \u0026#34;]\u0026#34;) } } // [Hello, friend!] // [Welcome, friend!] Unicode Scalar Representation Unicode \\u{1F436} each character has 20bit. 0—1048575\nUTF-16 each character has 16bit, 2Byte. 0—65535\nUTF-8 each character has 8bit, 1Byte. 0—255\nlet word = \u0026#34;dog!!\\u{1F436}\u0026#34; print(word) print(\u0026#34;UTF-8:\u0026#34;, terminator: \u0026#34; \u0026#34;) for c in word.utf8 { print(\u0026#34;\\(c)\u0026#34;, terminator : \u0026#34; \u0026#34;) } print(\u0026#34;\\nUTF-16\u0026#34;,terminator: \u0026#34; \u0026#34;) for c in word.utf16 { print(\u0026#34;\\(c)\u0026#34;, terminator: \u0026#34; \u0026#34;) } print(\u0026#34;\\nUnicode:\u0026#34;, terminator: \u0026#34; \u0026#34;) for c in word.unicodeScalars { print(\u0026#34;\\(c.value)\u0026#34;, terminator: \u0026#34; \u0026#34;) } print() print(word.count) The execute result\ndog!!🐶 UTF-8: 100 111 103 33 33 240 159 144 182 UTF-16 100 111 103 33 33 55357 56374 Unicode: 100 111 103 33 33 128054 6\n","permalink":"https://wowios.com/post/language/swift/03strings-and-characters/","summary":"\u003cp\u003eString type is bridged with Foundation’s NSString. Foundation extends String to expose methods defines by NSString. If import Foundation, you can access those NSString methods on String without casting.\u003c/p\u003e\n\u003ch2 id=\"string-literals\"\u003eString Literals\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-swift\" data-lang=\"swift\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// \u0026#34;Hello World!\u0026#34; is a String literal. \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e sentence = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Multiline\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e story = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003eThere are some people in the room.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003eThey are having a party.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003eBecause today is the Christmas.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// every line has the line breaks.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// the start and end sign(\u0026#34;\u0026#34;\u0026#34;) must take a single line.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// backlash(\\), it means that the string is not broken. Then line breaks not to be part of the string\u0026#39;s value.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e content = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003eIn a happy atmos\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003ephere. We start the conversation\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(content) \u003cspan style=\"color:#75715e\"\u003e// result: In a happy atmosphere. We start the conversation.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Alignment of quotation marks in the multiline string.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e desc = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    Ha it\u0026#39;s so funny.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(desc)  \u003cspan style=\"color:#75715e\"\u003e// result:     Ha its so funny.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e desc = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    Ha it\u0026#39;s so funny.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(desc)  \u003cspan style=\"color:#75715e\"\u003e// result: Ha its so funny.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e desc = \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e        Ha it\u0026#39;s so funny.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(desc)  \u003cspan style=\"color:#75715e\"\u003e// result:     Ha its so funny.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSpecial Character in String Literals\u003c/p\u003e","title":"Strings and Characters"},{"content":"Terminology Unary operator (such as -a) Binary operator(such as 2 + 3) Ternary operator(such as a ? b : c) The values that operators affect are operands. Prefix, infix, suffix\nAssignment Operator\n// Assignment let b = 10 var a = 5 a = b // tuple assignment let (x, y) = (1, 2) // not allowed, it is to prevent miss use when the equal operator(==) is actually intended. if x = y { // This isn\u0026#39;t valid, because x = y doesn\u0026#39;t return a value. } Arithmetic Operators\nAddition + Subtraction - Multiplication * Division / 1 + 1 5 - 3 2 * 3 10.0 / 2.5 \u0026#34;hello, \u0026#34; + \u0026#34;world\u0026#34; // Addition operator is also supported for String concatenation Remainder Operator\nb = (a x some multiplier) + remainder\n// 9 = 4 + 4 + 1 9 / 4 // it equals to 2 9 % 4 // it equals to 1 // Calculate method // a % b // b = (a x some multiplier) + remainder -9 % 4 // it equals to -1 // -9 = (4 x -2) + -1 // The sign of \u0026#39;b\u0026#39; is ignored. // a % b and a % -b always give the same answer. Compound Assignment Operators\na += 2 // it equals a = a + 2 b -= 3 c *= 2 d /= 2 // The compound assignment operators don\u0026#39;t return a value. // let b = a += 2 is illegal Comparison Operator\nEqual to a == b Not equal to a != b Greater than a \u0026gt; b Less than a \u0026lt; b Greater than or equal to a \u0026gt;= b Less than or equal to a \u0026lt;= b // Compare the tuples // from left to right (1, \u0026#34;zebra\u0026#34;) \u0026lt; (2, \u0026#34;apple\u0026#34;) // true (3, \u0026#34;apple\u0026#34;) \u0026lt; (3, \u0026#34;bird\u0026#34;) // true (4, \u0026#34;dog\u0026#34;) == (4, \u0026#34;dog\u0026#34;) // true // The element in the tuple should be comparable, so that the tuple can be comparable (String, Int) \u0026lt; (String, Int) // It\u0026#39;s ok (String, Boolean) \u0026lt; (String, Int) // Error, Boolean can\u0026#39;t be compared Ternary Operator\nvar a = 3 var b = 4 c = a \u0026gt; b ? 2 : 1 // The code equals to var a = 3 var b = 4 if a \u0026gt; b { c = 2 } else { c = 1 } Nil-Coalescing Operator Only optional type can use nil-coalescing operator\n// unwrap an optional \u0026#39;a\u0026#39; if it contains a value, or return a default value \u0026#39;b\u0026#39; if \u0026#39;a\u0026#39; is nil. a ?? b // The code equals to a != nil ? a! : b // Usage let defaultColorName = \u0026#34;red\u0026#34; var userDefinedColorName : String? // It\u0026#39;s assign with nil in default. var colorNameToUse = userDefinedColorName ?? defaultColorName // it\u0026#39;s red userDefinedColorName = \u0026#34;Green\u0026#34; colorNameToUse = userDefinedColorName ?? defaultColorName // it\u0026#39;s green Range Operator Closed Range Operator\n// From 1 to 5, include 1 and 5 for i in 1...5 { } Half-Open Range Operator\n// From 1 to 5, include 1 but not 5 for i in 1..\u0026lt;5 { } // it\u0026#39;s useful in array traversal One-Side Range\nfor name in names[2...] { // from 2 to the end, include 2 } for name in names[...2] { // from 0 to 2, include 2 } for name in names[..\u0026lt;2] { // from 0 to 2, not include 2 } // One-side operator can be used in other contexts, not just in subscripts. let range = ...5 range.contains(7) range.contains(5) range.cantains(-3) Logical Operator Logical NOT !a Logical AND a \u0026amp;\u0026amp; b Logical OR a Combining Logical Operators\nThe compound expression are left-associative.\nif enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan || hasDoorKey || knowsOverridePassword { print(\u0026#34;Welcome!\u0026#34;) } else { print(\u0026#34;Access Denied\u0026#34;) } Explicit Parentheses Add a pair of parentheses to make it easier to read.s\nif (enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword { print(\u0026#34;Welcome!\u0026#34;) } else { print(\u0026#34;Access Denied\u0026#34;) } ","permalink":"https://wowios.com/post/language/swift/02basic-operators/","summary":"Basic usage of the operators.","title":"Basic Operators"},{"content":"Syntax\n// variable var number = 6 var title: String? // const value, should be initialized before use it, can\u0026#39;t be changed after its definition let speed = 200 let name: String? = nil // array var str: [Character] = [\u0026#34;d\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;g\u0026#34;] Base data type Type Desc UInt8 UInt8.min is 0, UInt8.max is 255 Int On the 32-bit platform, it’s as Int32; On the 64-bit platform, it’s as Int64. Uint On the 32-bit platform, it’s as UInt32; On the 64-bit platform, it’s as UInt64. Double 64-bit floating-point number Float 32-bit floating-point number Boolean true or false Numeric\n/* Numeric Literals */ // They are the same number, in another word, their values are the same. let decimalInteger = 17 let binaryInteger = 0b10001 let octalInteger = 0o21 let hexadecimalInteger = 0x11 // Optional exponent (exp) 1.25e2 1.25e-2 // pad with extra zeros and underscores to make them easier to read. let paddedDouble = 000123.456 let oneMillion = 1_000_000 let justOverOneBillion = 1_000_000.000_000_1 /* Numeric Type Conversion */ // Type automatic convert let a: UInt16 = 2000 let b: UInt8 = 1 // Different type can\u0026#39;t be sum together let c = a + b // Here, system use b to create a new UInt16 object, so this new object can sum with a. // Type force convert let three = 3 let num = 0.14159 let pi = Double(three) + num // conversions between integer and floating-point numeric types must be made explict. // Truncate let integerPi = Int(pi) // The rules for combining numeric constants and variable are different from the rules for numeric literals. // Number literals don’t have an explicit type in and of themselves. Type Aliases\ntypealias MyInt16 = UInt16 var num: MyInt16 = MyInt16.min // it\u0026#39;s actually calls the UInt16.min Tuples\nlet http404Error = (404, \u0026#34; Not Found\u0026#34;) // compose a tuple let (statusCode, statusMessage) = http404Error // decompose a tuple let (justTheStatusCode, _) = http404Error // use a underscore(_) to ignore other values let statusCodeByIndex = http404Error.0 // get the tuple\u0026#39;s individual element value by index, start at 0 // name the tuple\u0026#39;s individual element let http200Status = (statusCode : 200, description : \u0026#34;OK\u0026#34;) let status200 = http200Status.statusCode let description200 = http200Status.description Optional : variable can be a value or nil. Just add a ? after the variable’s type. nilmeaning “the absence of a valid object.”\nonly optional type can be nil.\nconst value should not be nil, it has no specific meaning in application.\nvar name: String? = \u0026#34;Hello\u0026#34; // Because the initializer might be fail, it returns an optional Int (Int?), rather than an Int. let num = Int(\u0026#34;123\u0026#34;) var answer: Int? // the answer is automatically set to nil. // In Objective-C, nil is a pointer to a nonexistent object. // In Swift, nil isn’t a pointer—it’s the absence of a value of a certain type. // Include multiple condition // If any of the values in the optional bindings are nil or any Boolean condition evaluates to false, the whole if statement’s condition is considered to be false. if let firstNum = Int(\u0026#34;4\u0026#34;), let secondNum = Int(\u0026#34;5\u0026#34;), firstNum \u0026lt; secondNum \u0026amp;\u0026amp; secondNum \u0026lt; 100 { print(\u0026#34;\\(firstNum) \u0026lt; \\(secondNum) \u0026lt; 100\u0026#34;) } let hobby: String? // ordinary optional let myHobby = hobby! // must require a exclaimation point to unwrap the object. // An implicitly unwrapped optional as giving permission for the optional to be force-unwrapped if needed let address: String! // implicitly option. the name can be accessed when it is nil and without exclaimation point. let hisAddress = address // it is permitted, no need for an exclaimation point. // we are recommanded to use the ordinary optional in development. // because the implicitly optional can easily be out of control. // ######## error ######### // this will trigger a runtime error var str: String! = nil print(str.count) // this will trigger a runtime error var bag: String? print(str!.count). // \u0026#39;str!\u0026#39; is nil, so it can\u0026#39;t be accessed. // this will trigger a compiler error var pack: String? print(str.count) // str is an ordinary option, need an unwrap(!). // ####################### Function’s argument and its label use parameter label\nfunc addTwo(arg1 a : Int, arg2 b : Int) -\u0026gt; Int { let c = a + b return c } let sum = addTwo(arg1: 4, arg2: 28) Tell parameter’s name apparently(Recommended when the method has multi-parameter)\nfunc addTwo(a : Int, b : Int) -\u0026gt; Int { let c = a + _b return c } let sum = addTwo(a: 4, b: 28) use [ _ ] to pass over the label (Recommended when the method has only one parameter)\nfunc addTwo(_ a : Int, _ b : Int) -\u0026gt; Int { let c = a + b return c } let sum = addTwo(4, 28) Function’s define and invoke no need to be sequenced. It can be invoked before its define.\n// invoke function goToSchool( //function definition func goToSchool() { print(\u0026#34;I go to school.\u0026#34;) } Object Oriented Class\nclass Person { var name = \u0026#34;neo\u0026#34; var age = 0 init () {} init (_ name: String, _ age: Int) { self.name = name self.age = age } } // use different init function to create object. var a = Person() var b = Person(\u0026#34;Mike\u0026#34;, 26) print(a.name + \u0026#34; \u0026#34; + String(a.age)) print(b.name + \u0026#34; \u0026#34; + String(b.age)) Optional\nclass BlogPost { // title can be String or nil var title : String? } let post = BlogPost() print(post.body + \u0026#34; hello!\u0026#34;) //post.title = \u0026#34;yo\u0026#34; // Optional Binding if let actualTitle = post.title { print(actualTitle + \u0026#34; Hey\u0026#34;) } else { print(\u0026#34;post.title is \\(post.title)\u0026#34;) } // Testting for nil if post.title != nil { print(post.title! + \u0026#34; not nil\u0026#34;) // exclaimation \u0026#39;!\u0026#39; means force unbox } if post.title == nil { print(\u0026#34;It\u0026#39;s nil\u0026#34;) } // Implicity optional var name: String! = \u0026#34;Amy\u0026#34; // \u0026#39;!\u0026#39; means that implicity optional if name != nil { // no need to use \u0026#39;!\u0026#39; print(name + \u0026#34; not nil\u0026#34;) } Initializer\nThe rule of initializer\nA designated initializer must call the designated initializer from the immediately superclass.\nclass Worker: Person { override init () { super.init() print(\u0026#34;subclass\u0026#39;s designated initializer\u0026#34;) } // it has no conflict with the superclass\u0026#39;s convenience method. init (customName: String, age: Int) { // designated initializer call the designated initializer from superclass. super.init(name: customName) self.age = age print(\u0026#34;subclass\u0026#39;s designated initializer with two parameters\u0026#34;) } } class Person { var name = \u0026#34;neo\u0026#34; var age = 0 init () { age = 3 name = \u0026#34;ha\u0026#34; } init (name: String) { self.name = name } convenience init (customName: String, age: Int) { self.init(name: customName) self.age = age } } A convenience initializer must call another designated initializer from the same class.\nA convenience initializer must ultimately call a designated initializer.\ndesignated initializer\ninit () { age = 3 name = \u0026#34;ha\u0026#34; } init(_ name: String, _ age: Int) { self.name = name self.age = age } convenience initializer\nif we want to invoke the designated initializer self.init() in a newly init method, we should add a keyword ‘convenience’ to decorate this newly method. (The reason why we use the ‘convenience’ keyword)\nconvenience init(name: String) { self.init() // rule 3 of the rules we talk before. self.name = name } Inheritance\nSwift only permit single inheritance\nclass Car { var topSpeed = 200 func drive() { print(\u0026#34;Drive at \\(topSpeed)\u0026#34;) } } // inheritance class FutureCar: Car() { // the method belong to current class func fly() { print(\u0026#34;Fly at \\(topSpeed + 20)\u0026#34;) } } let myRide = Car() // create an instance from the class \u0026#39;Car\u0026#39;. myRide.drive() let hisCar = FutureCar() hisCar.fly() // method create by the subclass. Polymorphism\nOverride\nThe method has the same name but the arguments’ type or count are different.\nIf we call with different types or count of arguments , the phenomenons(results) are different.\nclass Car { var speed = 200 func drive() { print(\u0026#34;Drive at \\(speed)\u0026#34;) // the \u0026#39;speed\u0026#39; can be use in this class \u0026#39;Car\u0026#39; } func drive(_ speed: Int) { print(\u0026#34;Drive at \\(speed)\u0026#34;) // the \u0026#39;speed\u0026#39; can be only used in this func } } let myCar = Car() myCar.drive() myCar.drive(160) // another case goToSchool() goToSchool(\u0026#34;Mike\u0026#34;) goToSchool(\u0026#34;Micle\u0026#34;, \u0026#34;Jhon\u0026#34;) goToSchool(15) func goToSchool() { print(\u0026#34;I go to school.\u0026#34;) } func goToSchool(_ peoleA: String) { print(\u0026#34;I go to school with \\(peoleA).\u0026#34;) } func goToSchool(_ peopleA: String, _ peopleB: String) { print(\u0026#34;I go to school with \u0026#34; + peopleA + \u0026#34; and \u0026#34; + peopleB + \u0026#34;.\u0026#34;) } func goToSchool(_ speed: Int) { print(\u0026#34;I go to school in a speed of \\(speed).\u0026#34;) } The subclass define a same method already in the superclass, but the implement of this method is different from that implemented in the superclass. Use the key word ‘override’\nclass Car { var speed = 200 func drive() { print(\u0026#34;Drive at \\(speed)\u0026#34;) } } // inheritance class FutureCar: Car() { // override the method from the superclass. override func drive() { print(\u0026#34;Drive at \\(speed + 5)\u0026#34;) } } let myRide = Car()//create an instance from the class \u0026#39;Car\u0026#39;. myRide.drive() let hisCar = FutureCar() hisCar.drive() //method override by the subclass. Error Handling Two way to solve the error on runtime\nthrows\nfunc doSomething() throws { // Here may or may not throw an error } do try catch\ndo the right things to face the error.\ndo { try makeSandwich() // no error was thrown eatSandwich() } catch SandwichError.outOfCleanDishes { // an error was thrown washDish() } catch SandwichError.missingIngredients(let ingredients) { // an error was thrown buyGroceries(ingredients) } catch { // catch other errors } Assertion \u0026amp; Precondition A assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.\n// Assertion let age = -3 assert(age \u0026gt;= 0, \u0026#34;Age can\u0026#39;t be less than 0\u0026#34;) // (the condition, the message to be shown when the condition is false) assert(age \u0026gt;= 0) // omit the message, it\u0026#39;s ok. if age \u0026lt; 0 { assertionFailure(\u0026#34;Age can\u0026#39;t be less than 0\u0026#34;) // when the code already check the failure, use the assertionFailure to show message directly. } // Precondition let index = -1 precondition(index \u0026gt;= 0, \u0026#34;Index must be greater than 0\u0026#34;) precondition(index \u0026gt;= 0) preconditionFailure(\u0026#34;Index must be greater than 0\u0026#34;) // If you compile in unchecked mode (-Ounchecked), preconditions aren’t checked.But the assertion still check. // Assertion check in debug environment, not check in realease environment. // Precondition check in debug environment and release environment. // Use fatalError(_ :file:line:) to halt execution // During prototyping and early development to create stubs for functionality that hasn’t been implemented yet, write a fatalError as the stub implementation. // if the code use the functionality which hasn\u0026#39;t been implemented, that will result in a fatal error. It will remind us to implement the function or method. fatalError(\u0026#34;Unimplemented\u0026#34;) ","permalink":"https://wowios.com/post/language/swift/01basic/","summary":"Basic usage of the swift syntax.","title":"Basic"},{"content":"Outlook cinuni@outlook.com\nQQ 邮箱 1252622709@qq.com\n","permalink":"https://wowios.com/post/info/contact/mail/","summary":"false","title":"Mail"},{"content":"机器人比赛 2019.05 寻宝机器人\n2019.05 超市购物机器人\n2020.06 创意机器人比赛魔方组\n魔方机器人 🔗\n西门子智能制造挑战赛 2019.08\n大学生挑战杯 2022.07\n","permalink":"https://wowios.com/post/info/certificate/","summary":"\u003ch3 id=\"机器人比赛\"\u003e机器人比赛\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e2019.05 寻宝机器人\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"机器人\" loading=\"lazy\" src=\"../certificate/travel_car.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"寻宝\" loading=\"lazy\" src=\"../certificate/travel.jpg\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e2019.05 超市购物机器人\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"购物\" loading=\"lazy\" src=\"../certificate/car.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"购物\" loading=\"lazy\" src=\"../certificate/shopping_map.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"购物\" loading=\"lazy\" src=\"../certificate/shopping.jpg\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e2020.06 创意机器人比赛魔方组\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://compeition-excute.oss-cn-beijing.aliyuncs.com/webFile/2019117/5c3d3f1ffabd11e994a47cd30a5180b6/aWHSLydW_1573089290143.mp4\"\u003e魔方机器人 🔗\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"魔方图像识别\" loading=\"lazy\" src=\"../certificate/cube_img.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"魔方组\" loading=\"lazy\" src=\"../certificate/cube.jpg\"\u003e\u003c/p\u003e\n\u003ch3 id=\"西门子智能制造挑战赛\"\u003e西门子智能制造挑战赛\u003c/h3\u003e\n\u003cp\u003e2019.08\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"西门子\" loading=\"lazy\" src=\"../certificate/Simon.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"大学生挑战杯\"\u003e大学生挑战杯\u003c/h3\u003e\n\u003cp\u003e2022.07\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"挑战杯\" loading=\"lazy\" src=\"../certificate/sound.jpg\"\u003e\u003c/p\u003e","title":"竞赛经历与奖项"}]