[{"content":"跳转部分的实现 我需要从我的 HomeViewController 通过点击不同的 CollectionViewCell 跳至不同的 ViewController\n思路：\n 首先是需要把目标 ViewController 存放起来，在点击 cell 时可以作为目的地进行 present 跳转。  因为我的多个不同的 ViewController 都继承自 UIViewController， 那么我想用它作为父类型存放在cell中。\n 先把 Main storyboard 存为当前类的属性，以方便初始化各个 collectionView   然后使用 storyboard 自带的动态反射方法 instantiateViewController，通过字符串找到对应的 ViewController   在 dataSource 的实现中，将 cell 的属性绑定为对应的 controllerView 目标。   最后是 didTapCell 方法，是点击后的具体要做的动作，即跳转。这里的 target 类型是 UIController。  发现这样实现不了，原因是第 1 步中 MainChoiceCell 中的 targetController 不能是 weak，若为 weak 那么它在被赋值然后在函数结束时（closure 结束）会释放引用也就是恢复为 nil，所以正确的做法应该是把 weak 去掉。\n手指触碰 UICollectionViewCell 但未释放，这属于 Highlight UICollectionViewCell 底层来自 UIView。重写 highlight 的 willSet， 手指点在 UICollectionViewCell 区域会触发 highlight 置为 true ；手指不松开，移动到不属于 UICollectionViewCell 的区域，则会触发 highlight 置为 false。\noverride var isHighlighted: Bool {  willSet {  if newValue {  UIView.animate(withDuration: 0.2, animations: {  self.transform = CGAffineTransform(scaleX: 1.1, y: 1.1)  })  } else {  UIView.animate(withDuration: 0.2, animations: {  self.transform = CGAffineTransform(scaleX: 1, y: 1)  })  }   }  } 实现了进入时扩大，离开时缩小，与 UITapGestureRecognizer 互相独立。使用 UITapGestureRecognizer 实现点击监听\ncell.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(didTapCell(_:)))) 对应的触发任务\n@objc func didTapCell(_ gesture: UITapGestureRecognizer) {  guard let cell = gesture.view as? MainChoiceCell else { return }   UIView.animate(withDuration: 0.2, delay: 0.2, animations: {  cell.transform = CGAffineTransform(scaleX: 1, y: 1)  })   DispatchQueue.main.asyncAfter(deadline: .now() + 0.2, execute: {  if let target = cell.targetController{   self.present(target, animated: true)   }  })  } 使用 UITapGestureRecognizer 存在问题 点 cell 然后不松开，手指移到 cell 外边再移回来，它的 isHighlight 会再次被触发（正常），但此时 UITapGestureRecognizer 所发出的事件已经失效，即使此时松开手指，也不会执行触发任务（跳转到另一个 ViewController）。\n使用 didSelectedItemAt 可以解决问题 在 UICollectionView 的 delegate 中实现函数\nfunc collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {  let cell = collectionView.cellForItem(at: indexPath) as! MainChoiceCell  UIView.animate(withDuration: 0.2, delay: 0.2, animations: {  cell.transform = CGAffineTransform(scaleX: 1, y: 1)  })   DispatchQueue.main.asyncAfter(deadline: .now() + 0.2, execute: {  if let target = cell.targetController{  // 需要执行的动作  self.present(target, animated: true)   }  })  } ","permalink":"https://1-1.link/post/ios/viewcontrollertransform/","summary":"跳转部分的实现 我需要从我的 HomeViewController 通过点击不同的 CollectionViewCell 跳至不同的 ViewController\n思路：\n 首先是需要把目标 ViewController 存放起来，在点击 cell 时可以作为目的地进行 present 跳转。  因为我的多个不同的 ViewController 都继承自 UIViewController， 那么我想用它作为父类型存放在cell中。\n 先把 Main storyboard 存为当前类的属性，以方便初始化各个 collectionView   然后使用 storyboard 自带的动态反射方法 instantiateViewController，通过字符串找到对应的 ViewController   在 dataSource 的实现中，将 cell 的属性绑定为对应的 controllerView 目标。   最后是 didTapCell 方法，是点击后的具体要做的动作，即跳转。这里的 target 类型是 UIController。  发现这样实现不了，原因是第 1 步中 MainChoiceCell 中的 targetController 不能是 weak，若为 weak 那么它在被赋值然后在函数结束时（closure 结束）会释放引用也就是恢复为 nil，所以正确的做法应该是把 weak 去掉。\n手指触碰 UICollectionViewCell 但未释放，这属于 Highlight UICollectionViewCell 底层来自 UIView。重写 highlight 的 willSet， 手指点在 UICollectionViewCell 区域会触发 highlight 置为 true ；手指不松开，移动到不属于 UICollectionViewCell 的区域，则会触发 highlight 置为 false。","title":"如何通过点击 UICollectionViewCell 跳转至对应的 UIViewController"},{"content":"需要用到的硬件  工控机本体这里称为 A， 一台可以连接 WiFi 或者可插入以太网网线的设备称为 B。 公网的接入端口线称为 C。 一个 Wifi 路由器D。 键盘与HDMI 显示器（用于命令行查看系统信息，可省略）、两条网线。  方法一：”不同网段“接法 软路由的 LAN 接 WiFi 的 WAN，连接 WiFi 的设备和直连软路由的设备不算是同一网段。\nWiFi 所在 192.168.1.x\n软路由所在 192.168.11.x\n关键步骤：\n 以太网连接，从 C 上接一条网线到 A 的 eth1 端口。D 的 WAN 网口和 A 的 eth0 用网线连接。 使用设备 B，连接 WiFi，然后登入后台管理页面，网址一般在 WiFi 路由器背后有写明。  设备B 需要关键一步：设置为 自动 IP 分配，那么才可以在 B 上访问到 192.168.11.1\n关键配置：\n登入D 的 后台页面（依据不同品牌而定，我这里是 192.168.1.1）。WiFi 路由器 D 的设置，需要设置为 自动获得 IP 地址，拔掉 WiFi 的电源，重启，它会通过A、公网 C 自动获得 IP。这时，连接到该 WiFi 的设备就可以通过 192.168.11.1 进入软路由的管理页面了。\n进入 软路由系统的管理页面，在 openclash 中填入订阅地址，保存设置然后启动 clash 服务，即可。\n方法二：同一网段的接法 软路由与 WiFi 之间使用 LAN，连接 WiFi 的设备和直连软路由的设备属于同一网段。\n修改为交换机模式 AP mode\n设置本 WiFi 配置页面的 IP 地址，网段和软路由那边的保持一致。\n关闭 DHCP，使得路由器不作为子网网关\n这样一来，连接到 WiFi 的设备既可以访问 192.168.11.1 的软路由管理页面，也可以访问原本 WiFi 的管理页面。后续的 open clash 配置和方法一的一样。\n实际运行效果：两台播放 1080P 视频的设备同时使用，CPU 占用率也不高，可以看出来这个 N4000 在日常个人多设备使用场景下基本是够用的 ","permalink":"https://1-1.link/post/tool/wrt/setnetwork/","summary":"需要用到的硬件  工控机本体这里称为 A， 一台可以连接 WiFi 或者可插入以太网网线的设备称为 B。 公网的接入端口线称为 C。 一个 Wifi 路由器D。 键盘与HDMI 显示器（用于命令行查看系统信息，可省略）、两条网线。  方法一：”不同网段“接法 软路由的 LAN 接 WiFi 的 WAN，连接 WiFi 的设备和直连软路由的设备不算是同一网段。\nWiFi 所在 192.168.1.x\n软路由所在 192.168.11.x\n关键步骤：\n 以太网连接，从 C 上接一条网线到 A 的 eth1 端口。D 的 WAN 网口和 A 的 eth0 用网线连接。 使用设备 B，连接 WiFi，然后登入后台管理页面，网址一般在 WiFi 路由器背后有写明。  设备B 需要关键一步：设置为 自动 IP 分配，那么才可以在 B 上访问到 192.168.11.1\n关键配置：\n登入D 的 后台页面（依据不同品牌而定，我这里是 192.168.1.1）。WiFi 路由器 D 的设置，需要设置为 自动获得 IP 地址，拔掉 WiFi 的电源，重启，它会通过A、公网 C 自动获得 IP。这时，连接到该 WiFi 的设备就可以通过 192.","title":"N4000 四网口工控机组网"},{"content":"若域名有变动 需要修改三个地方\n workflow 文件夹里 Github Acction 配置文件 Action.yml 中的 cname: config.yaml 中的 baseURL Github repository setting Pages  ","permalink":"https://1-1.link/post/tool/usehugo/someproblem/","summary":"若域名有变动 需要修改三个地方\n workflow 文件夹里 Github Acction 配置文件 Action.yml 中的 cname: config.yaml 中的 baseURL Github repository setting Pages  ","title":"Hugo 的一些问题"},{"content":"安装  windows：确保有 hugo.exe 在工程目录下, 并且 .gitignore 里面写上 hugo.exe，即可 Mac：确保 hugo 已安装就可以  新建 一般，都在 post 文件夹下放 markdown 文件，使用不同文件夹来归类\n hugo new post/tool/useHugo/publishArticle.md\n 书写  设定文章的 title, categories, tags 写入内容。标题大小从 ## 开始  本地预览  hugo server\n 编译成 html，输出到 /docs （路径与 GitHub Action 对应）  hugo\n 到这里，就完成了写作\nGit Push 先 fetch，再 commit，再 push。\nGithub Page 需要重新填写域名 因为 Github Action 在执行的时候会把 master 分支中的 /docs 内所有内容拷贝到 main 分支，这里面不包括 CNAME 文件。所以在 repository 的 setting 的 pages 重新填写域名。（问题已经解决，在 workflow action.yml 中添加 cname: 1-1.link，所以如果域名有改动，需要在这修改）\n","permalink":"https://1-1.link/post/tool/usehugo/publisharticle/","summary":"安装  windows：确保有 hugo.exe 在工程目录下, 并且 .gitignore 里面写上 hugo.exe，即可 Mac：确保 hugo 已安装就可以  新建 一般，都在 post 文件夹下放 markdown 文件，使用不同文件夹来归类\n hugo new post/tool/useHugo/publishArticle.md\n 书写  设定文章的 title, categories, tags 写入内容。标题大小从 ## 开始  本地预览  hugo server\n 编译成 html，输出到 /docs （路径与 GitHub Action 对应）  hugo\n 到这里，就完成了写作\nGit Push 先 fetch，再 commit，再 push。\nGithub Page 需要重新填写域名 因为 Github Action 在执行的时候会把 master 分支中的 /docs 内所有内容拷贝到 main 分支，这里面不包括 CNAME 文件。所以在 repository 的 setting 的 pages 重新填写域名。（问题已经解决，在 workflow action.","title":"Hugo 发布一篇文章的过程"},{"content":"Notion 批量文件导出，以 PFD格式 Notion 是一款 markdown 笔记软件，可以快速书写，多端同步，支持文件导出，十分方便。 我在 notion 中写了很多页面，有时要转移到别的地方保存，那么应该怎么做呢？\nnotion 支持导出的文件格式：PDF，HTML，MD 可是，这几种方法都有缺点。\n PDF：只能当前页面，导出所有子页面，需要升级 Pro HTML：多出了一些附带的文件，文件散乱，转移和浏览都不方便 MD：导出之后，图片和文本都分开，转移不方便，文件散乱  那么，有没有更简单的办法获取我自己写的许多页面，且保存为 PDF ？ 有的，步骤如下：\n 在notion中包含子页面导出 markdown 使用 vs code 打开，使用插件 Markdown PDF 逐页导出。  具体操作步骤 下图可以看到我的一个页面包含了多个子页面。\n右上角三个点的按钮，选择 export\n  导出 markdown\n  会得到页面和子页面的目录结构\n    使用 vscode 打开。\n  安装插件 ”Markdown PDF“\n搜索 Markdown PDF， 点击安装 install。\n  设置 ”auto convert when save “\n在插件库里可以看到已安装 Markdown PDF\n这样一来，打开一个 md 文件，ctrl + s，它就自动转换为 pdf 并输出到源路径了。\n当然，也可以自己设定输出的路径，方便批量管理。\n  总结 到这里，就实现了 Notion 写作内容的固化和转移啦！\n","permalink":"https://1-1.link/post/tool/notion/notion%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA/","summary":"Notion 批量文件导出，以 PFD格式 Notion 是一款 markdown 笔记软件，可以快速书写，多端同步，支持文件导出，十分方便。 我在 notion 中写了很多页面，有时要转移到别的地方保存，那么应该怎么做呢？\nnotion 支持导出的文件格式：PDF，HTML，MD 可是，这几种方法都有缺点。\n PDF：只能当前页面，导出所有子页面，需要升级 Pro HTML：多出了一些附带的文件，文件散乱，转移和浏览都不方便 MD：导出之后，图片和文本都分开，转移不方便，文件散乱  那么，有没有更简单的办法获取我自己写的许多页面，且保存为 PDF ？ 有的，步骤如下：\n 在notion中包含子页面导出 markdown 使用 vs code 打开，使用插件 Markdown PDF 逐页导出。  具体操作步骤 下图可以看到我的一个页面包含了多个子页面。\n右上角三个点的按钮，选择 export\n  导出 markdown\n  会得到页面和子页面的目录结构\n    使用 vscode 打开。\n  安装插件 ”Markdown PDF“\n搜索 Markdown PDF， 点击安装 install。\n  设置 ”auto convert when save “","title":"Notion文件导出"},{"content":"多线程 Java 多线程编程笔记 🔗\n","permalink":"https://1-1.link/post/language/java/java/","summary":"多线程 Java 多线程编程笔记 🔗","title":"Java"},{"content":"简历  教育经历  2017\u0026ndash;2021 中国计量大学（本科）自动化专业 2021\u0026ndash;今 中国计量大学（研究生）电子信息专业  技术栈  掌握常见的数据结构与算法 熟悉各个设计模式的思想 熟悉 Swift \u0026amp; UIKit 开发 Java 服务端开发  项目经历   2021.05 跨平台文件传输 5 号电池 AAcell 🔗\n负责后端部分，使用 Java 语言，基于 SpringBoot 框架搭建了 web 服务，实现仅依赖于浏览器的文件传输便捷服务。\n多台不同系统的设备使用房间号和密码可以进入同一个房间。\n使用拦截器配合 JWT (Json Web Token) 对请求建立连接的用户进行验证。\n密码使用 sha-256 非对称加密，在具有密文的情况下也无法获取用户设置的源密码。\n使用 MySQL 数据库存放房间信息和用户发送的消息。\n每一个房间的文件是直接以分类别的方式存放在固定文件夹。\n使用 WebSocket 让多个客户端向服务器订阅消息，使用房间号作为标识。\n  2021.02 本科毕设项目，基于 Mask-RCNN 和双目视觉对快递包裹内物体的三维定位。 Mask-RCNN 图像分割将包裹内的物体的种类和物体边缘识别出来，再使用双目视觉测得物体的与相机的距离，从而得到每一个物体的三维坐标值，为后续机械臂抓取物体提供坐标信息。\n  2021.07 安卓平板点餐 App CakeTouch 🔗 前台工作人员为客户记录每一个订单需要的商品，在确认订单之后，通过蓝牙打印机打印出商品的需求信息。\n  获奖经历  2019.05 参加浙江省第四届大学生机器人比赛获得寻宝机器人组二等奖 2019.10 参加大学生挑战杯，鸡枞根部切削机器人项目，国赛二等奖  兴趣爱好  了解新的的技术和数码产品  联系方式   G-Mail\nzanxinz@gmail.com\n  QQ 邮箱\n1252622709@qq.com\n  ","permalink":"https://1-1.link/about/","summary":"简历  教育经历  2017\u0026ndash;2021 中国计量大学（本科）自动化专业 2021\u0026ndash;今 中国计量大学（研究生）电子信息专业  技术栈  掌握常见的数据结构与算法 熟悉各个设计模式的思想 熟悉 Swift \u0026amp; UIKit 开发 Java 服务端开发  项目经历   2021.05 跨平台文件传输 5 号电池 AAcell 🔗\n负责后端部分，使用 Java 语言，基于 SpringBoot 框架搭建了 web 服务，实现仅依赖于浏览器的文件传输便捷服务。\n多台不同系统的设备使用房间号和密码可以进入同一个房间。\n使用拦截器配合 JWT (Json Web Token) 对请求建立连接的用户进行验证。\n密码使用 sha-256 非对称加密，在具有密文的情况下也无法获取用户设置的源密码。\n使用 MySQL 数据库存放房间信息和用户发送的消息。\n每一个房间的文件是直接以分类别的方式存放在固定文件夹。\n使用 WebSocket 让多个客户端向服务器订阅消息，使用房间号作为标识。\n  2021.02 本科毕设项目，基于 Mask-RCNN 和双目视觉对快递包裹内物体的三维定位。 Mask-RCNN 图像分割将包裹内的物体的种类和物体边缘识别出来，再使用双目视觉测得物体的与相机的距离，从而得到每一个物体的三维坐标值，为后续机械臂抓取物体提供坐标信息。\n  2021.07 安卓平板点餐 App CakeTouch 🔗 前台工作人员为客户记录每一个订单需要的商品，在确认订单之后，通过蓝牙打印机打印出商品的需求信息。","title":"关于我"},{"content":"Creational Object Created Pattern\nFactory Method Provide the method for creating an instance in the superclass, and allow the subclass to choose the type of the instance.\n在父类中提供创建对象的方法，允许子类决定实例化对象的类型。\n具备的部分：生产者协议、产品协议，往后就可以根据需要来扩展每一种产品。\n具体的生产者比如 MongoCakeCreator 的存在是为了实现与产品相关的核心业务逻辑，而不仅仅是创建 MongoCake 实例。工厂方法将核心业务逻辑从具体产品类中分离出来。\n // Creator  protocol CakeCreator {  func createCake() -\u0026gt; Cake  func doSomethingForCake(cake: Cake) -\u0026gt; Cake  }   // Product  protocol Cake {  func doWork()  }   // ConcreteCreator  class MongoCakeCreator: CakeCreator {  var cake: MongoCake?  func createCake() -\u0026gt; Cake {  var cake = MongoCake()  doSomethingForCake(cake: cake)  return cake  }  func doSomethingForCake(cake: Cake) -\u0026gt; Cake{  cake.doWork()  cake.doWork()  return cake  }   }   // ConcreteCreator  class ChocolateCakeCreator: CakeCreator {  func createCake() -\u0026gt; Cake {  var cake = ChocolateCake()  doSomethingForCake(cake: cake)  return cake  }   func doSomethingForCake(cake: Cake) -\u0026gt; Cake{  cake.doWork()  return cake  }  }   class MongoCake: Cake {  func doWork() {  print(\u0026#34;Add some mongo\u0026#34;)  }  }   class ChocolateCake: Cake {  func doWork() {  print(\u0026#34;Add some chocolate\u0026#34;)  }  }   // If we want to add a type of cake call \u0026#34;PinapleCake\u0026#34;, just need to   // make it conform to Cake and add a creator that conform to the CakeCreator for the \u0026#34;PinapleCake\u0026#34;   let cakeOne = MongoCakeCreator().createCake() Abstract Factory Base on the factory method, add an abstract factory. We can call the same abstract factory method to create different mode’s product. If we want to create another mode’s product, we need to change the concrete factory.\n基于工厂方法模式，我们添加了一个抽象工厂协议，其它具体的工厂来实现这个工厂协议。从而我们可以调用同一个抽象工厂方法来创建不同模式的相似产品（比如 WinButton 和 MacButton）。如果想要切换模式，我们需要切换到另外一种具体的工厂实现。\n // Abstract factory  protocol GUIFactory {  func createButton() -\u0026gt; Button  func createCheckBox() -\u0026gt; CheckBox  }   // Concrete factory  class WinGUIFactory: GUIFactory {  func createButton() -\u0026gt; Button {  var btn = WinButton()  return btn  }  func createCheckBox() -\u0026gt; CheckBox {  var box = WinCheckBox()  return box  }  }   // Concrete factory  class MacGUIFactory: GUIFactory {  func createButton() -\u0026gt; Button {  var btn = MacButton()  return btn  }  func createCheckBox() -\u0026gt; CheckBox {  var box = MacCheckBox()  return box  }  }   // Abstract product  protocol Button {  func click()  }   // Abstract product  protocol CheckBox {  func render()  }   // Concrete product  class WinButton: Button {  func click() {  print(\u0026#34;Win click button\u0026#34;)  }   }   // Concrete product  class WinCheckBox: CheckBox {  func render() {  print(\u0026#34;Here the win render checkBox\u0026#34;)  }  }   // Concrete product  class MacButton: Button {  func click() {  print(\u0026#34;Mac click button\u0026#34;)  }  }   // Concrete product  class MacCheckBox: CheckBox {  func render() {  print(\u0026#34;Here the mac render checkBox\u0026#34;)  }  }   class App {  var factory: GUIFactory  init(factory: GUIFactory) {  self.factory = factory  }   func someOperation() {  var checkBox = factory.createCheckBox()  checkBox.render()  }  }   let factory = WinGUIFactory()  let app = App(factory: factory) // The mode is choosen now, and the behavior in the app is specific.  let button = app.factory.createButton();  button.click()  app.someOperation() Builder Extracting the instance’s building code from the instance’s class, and put the code into a “Builder” object to do the build work. So we can build different complex instance by using different composition of the builder method. Besides, Add a “director” to manage the calling form client.\n将对象的构造代码从对象的产品类代码中抽离出来，将这些代码放置在一个名为 “生成器” 的独立对象中。 所以，我们可以通过在建造方法中使用不同的组合，来创建不同的复杂实例。并且，增加一个 “指挥者” 来管理那些来自外界客户对调用。\n // Director  class HouseDirector{  var builder: HouseBuilder  init (builder: HouseBuilder) {  self.builder = builder  }  func changeBuilder(bulider: HouseBuilder) {  self.builder = bulider  }  // The function \u0026#34;make\u0026#34; define the house must built by some componets.   func make(type: String) {  builder.reset()  if type == \u0026#34;simple\u0026#34; {  builder.buildA()  } else {  builder.buildB()  builder.buildC()  }  }  }   // Builder  protocol HouseBuilder {  func reset()  func buildA()  func buildB()  func buildC()  }   class Builder1: HouseBuilder {  private var result: Product1?  func reset() {  result = Product1()  }  func buildA() {   }  func buildB() {   }  func buildC() {   }  func getResult() -\u0026gt; Product1? {  return result  }  }   class Builder2: HouseBuilder {  private var result: Product2?  func reset() {  result = Product2()  }  func buildA() {   }  func buildB() {   }  func buildC() {   }  func getResult() -\u0026gt; Product2? {  return result  }  }   class Product1 {   }   class Product2 {   }   let b = Builder1()  let director = HouseDirector(builder: b)  director.make(type: \u0026#34;complex\u0026#34;) Singleton Singleton can solve two problem:\n Keep that one specific class have only one instance Provide a global access node for this instance  Implementation:\n Set the default initializer as private to prevent other objects use it. Create a static func that will call the default initializer if the single instance is null, then this class will have this only one instance.  单例模式解决了可以解决两个问题：\n 保证某个类只有一个实例 为这个实例提供全局的访问节点  实现：\n 将默认的构造函数设置为私有，让其它对象无法访问。 新建一个静态函数，在这个函数内进行判断，若单例对象为空，则调用私有的构造函数来创建实例对象，实例只被创建一次。   class FileAccess {  private static var obj: FileAccess? = nil  private init(){   }  public static func getInstance() {  if obj == nil {  obj = FileAccess()  }  }  }   let firstAccess = FileAccess.getInstance()   let secondAccess = FileAccess.getInstance()   // These two access are reference to a same instance. Prototype When we want to clone the instance itself, it may create some dependencies between the client and the original class, it will make the code be more complex. So we use “prototype” to compound the clone operation into the original class itself. And the clone operation will be easily.\n当我们想要完全复制一个对象它本身时，很可能会在调用者和源类之间产生一些复杂当耦合关系。所以我们使用“原型”模式，将对象克隆操作整合在对象当源类之中。这样一来，克隆操作由特定的类自身决定，调用变得简洁。\n // Prototype  protocol StorePrototype{  func clone() -\u0026gt; Store  }   // Concrete Prototype  class Store: StorePrototype {  var area: [Int] = [0, 0]  init(store: StorePrototype) {  if let s = store as? Store {  self.area = s.area  }  }  init() {}  func clone() -\u0026gt; Store {  return Store(store: self)  }  }   // Sub Concrete Prototype  class BookStore: Store {  var bookSelfCount = 0  init(bookStore: StorePrototype) {  super.init(store: bookStore)  if let s = bookStore as? BookStore {  self.bookSelfCount = s.bookSelfCount  }  }  override init() {  super.init()  }  override func clone() -\u0026gt; Store {  return BookStore(bookStore: self)  }   }   // Sub Concrete Prototype  class FlowerStore: Store {  var flowers = [\u0026#34;Sun Flower\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;Lily\u0026#34;]  init(flowerStore: StorePrototype) {  super.init(store: flowerStore)  if let s = flowerStore as? FlowerStore {  self.flowers = s.flowers  }  }  override init() {  super.init()  }  override func clone() -\u0026gt; Store {  return FlowerStore(flowerStore: self)  }  }   let store = Store()  let obj = FlowerStore()   let copyStore = store.clone()  let copyObj = obj.clone()  // Now it did the deep copy. It copy the whole instance \u0026#34;store\u0026#34; to \u0026#34;copyStore\u0026#34;, and copy the whole instace \u0026#34;obj\u0026#34; to copyObj. Structural Adapter A class called ‘A’ needs to disguise as another class called ‘B’, create a new adapter to extend the target class B and then insert the class A into the adapter, override the methods from the class B in the adapter. So we can use the adapter which has new features from A, just like we are using class B(The adapter extends from class B).\n类 A 想要适配类 B，首先使用一个适配器继承类 B ，把类 A 注入适配器，在适配器里面重写需 要模仿的类 B 的方法。最后，在需要用 A 替换 B 的地方，传递一个适配器即可，因为它既具有 A 的性质，又具有 B 的方法，它继承自 B ，可以当作 B 来调用。\n class Bike {  var name = \u0026#34;deafult\u0026#34;  func go() {  print(\u0026#34;Bike Go\u0026#34;)  }  func addWheel() {  print(\u0026#34;Add wheel for\\(name)\u0026#34;)  }  }   class WaterBike {  var weight = 0  func floating() {  print(\u0026#34;The water bike floating on the water\u0026#34;)  }  }   // now the water bike adapt the bike, inherit the target(Bike) that be disguised.  class WaterBikeAdapter: Bike {  var waterBike: WaterBike?  init(waterBike: WaterBike) {  self.waterBike = waterBike // inject the waterBike(which want to disguise as other)  }  override func go() {  print(\u0026#34;Now it\u0026#39;s the water bike go\u0026#34;)  }   }   func someThingGo(bike: Bike) {  bike.go()  }  // This mode make the \u0026#34;WaterBike\u0026#34; to disguise as a \u0026#34;Bike\u0026#34;  let waterBikeAdapter = WaterBikeAdapter(waterBike: WaterBike()) // The adapter has a waterBike and has the method of bike.  someThingGo(bike: waterBikeAdapter) // Now it can use as a bike. Bridge It depart one class or some closing class into two independent layer, the abstract and the implementation. The concrete class A contains an abstract interface B, and this interface can be implement in different ways. The A relies on the interface B not the concrete class. We inject different concrete class（has implemented interface B） for A or subclass of A, so we can get an instance of A or subclass with different functionality.\n桥接模式将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构。实体类 A 包含有接口 B，这个接口可以通过不同的方式来实现。实体类 A 依赖于接口 B 而不是具体的类。 我们使用不同的实现了接口 B 的实体类注入到 A 类实体或者 A类的子类的实体中，从而可以得到具有不同功能的 A 实体 或者 A 子类实体。\n // Abstract interface  protocol Device {  func isEnable() -\u0026gt; Bool  func enable()  func disable()  func getVolume() -\u0026gt; Int  func setVolume(_ volumn: Int)  func getChannel() -\u0026gt; Int  func setChannel(_ channel: Int)  }   // Concrete class that contains the interface  class Remote {  var device: Device  init(_ device: Device) {  self.device = device  }  func togglePower() {  if device.isEnable() {  device.disable()  } else {  device.enable()  }  }  func volumeUp() {  device.setVolume(device.getVolume() + 1)  }   func voluomeDown() {  device.setVolume(device.getVolume() - 1)  }  func channelUp() {  device.setChannel(device.getChannel() + 1)  }   func channelDown() {  device.setChannel(device.getChannel() - 1)  }  }   // Sub class  class AdvanceRemote: Remote {   override init(_ device: Device) {  super.init(device)  }  func mute() {  device.setVolume(0)  }  }   // Specific implementation of the interface  class TV: Device {  private var displaySize = (1080, 960)  private var on: Bool = false  private var volume = 0  private var channel = 0  func isEnable() -\u0026gt; Bool {  return on  }   func enable() {  self.on = true  }   func disable() {  self.on = false  }   func getVolume() -\u0026gt; Int {  return volume  }   func setVolume(_ volumn: Int) {  self.volume = volumn  }   func getChannel() -\u0026gt; Int {  return channel  }   func setChannel(_ channel: Int) {  self.channel = channel  }  }   // Specific implementation of the interface  class Radio: Device {  private var on: Bool = false  private var volume = 0  private var channel = 0  func isEnable() -\u0026gt; Bool {  return on  }   func enable() {  on = true  }   func disable() {  on = false  }   func getVolume() -\u0026gt; Int {  return volume  }   func setVolume(_ volumn: Int) {  self.volume = volumn  }   func getChannel() -\u0026gt; Int {  return channel  }   func setChannel(_ channel: Int) {  self.channel = channel  }  }   let tv = TV() // create a TV  let remote = AdvanceRemote(tv) // inject a concrete Device to the remote.  remote.togglePower()  remote.channelUp()  remote.volumeUp()  remote.mute()   let radio = Radio()  let remoteForRadio = Remote(radio)  remoteForRadio.channelUp()  remoteForRadio.togglePower() Composite We want to make the client using the Container or Leafs in a same calling way, so we set the leaf and the container that implement the same interface (Component). And the Container contains some children. In this way we create a model like tree, the client can treat every node similarly.\n为了使客户端能够使用相同的方式调用 “容器” 和 “叶子”，我们让容器和叶子都去实现同一个接口 “组件”。并且容器中包含有一些子的容器。通过这种方式，我们可以创建一个类似于一棵树的模型，客户端对每个结点使用相同的对待方式。\n // interface  protocol Component {  func execute()  }   class Leaf: Component {   func execute() {  print(\u0026#34;I\u0026#39;m leaf\u0026#34;)  }  }   class SubLeaf: Leaf {  override func execute() {  print(\u0026#34;I\u0026#39;m sub leaf\u0026#34;)  }  }   // Composite  class Containner:Component {  private var children: [Component] = []  func add(c: Component) {  children.append(c)  }  func remove(c: Component) {   }   func execute() {  for item in children {  item.execute()  }  }  }   // We treat the leaf and the containner as the same type of node.   let leaf = Leaf()  let leafTwo = Leaf()  let subLeaf = SubLeaf()   let c = Containner()  c.add(c: leaf)  c.add(c: leafTwo)   let root = Containner()  root.add(c: c)  root.add(c: subLeaf)  c.execute()  root.execute() Decorator The components and decorators are departed, we can add new components and decorators freely. And we can make different compositions(with different decorations) to be different products.\n组件模块和装饰器是分开的，我们可以自由地添加组件和装饰器。我们也可使用不同的组合形式（基于不同装饰方式），来得到不同的产品。\n // Base interface between classes.  protocol Component {  var text: String? { get set}  func execute()  }   // Concrete Component  class Bike: Component {  var text: String?  func execute() {  text = \u0026#34;bike\u0026#34;  }  }   // Concrete Component  class Moto: Component {  var text: String?   func execute() {  text = \u0026#34;moto\u0026#34;  }  }   // Base Decorator  class BaseDecorator: Component {  var text: String?   private var c: Component  func execute() {  c.execute()   if let t = c.text {  text = \u0026#34;\u0026lt;\u0026#34; + t + \u0026#34;\u0026gt;\u0026#34; // Here the text is the property of the current concrete decorator.  } else {  text = \u0026#34;\u0026lt;\u0026gt;\u0026#34;  }  }   func getText() -\u0026gt; String {  if let s = text {  return s  } else {  return \u0026#34;\u0026#34;  }  }  func setText(_ str: String?) {  text = str  }  func getC() -\u0026gt; Component {  return c  }  // inject an instance  init(_ c: Component) {  self.c = c  }   }   // Concrete Decorator  class PaintDecorator: BaseDecorator {  override func execute() {  super.execute()  extra()  }  func extra() {  let s = getText()  setText(\u0026#34;(Paint)\\(s)(Paint)\u0026#34;)  }  }   // Concrete Decorator  class AttachTagDecorator: BaseDecorator {  override func execute() {  super.execute()  extra()  }  func extra() {  let s = getText()  setText(\u0026#34;(Tag)\\(s)(Tag)\u0026#34;)  }  }   let a = Bike()  let tag = AttachTagDecorator(a)  let paint = PaintDecorator(tag)   paint.execute() // (Paint)\u0026lt;(Tag)\u0026lt;bike\u0026gt;(Tag)\u0026gt;(Paint)  print(paint.getText())   let b = Moto()  let bpaint = PaintDecorator(b)  let bTag = AttachTagDecorator(bpaint)  bTag.execute() // (Tag)\u0026lt;(Paint)\u0026lt;moto\u0026gt;(Paint)\u0026gt;(Tag)  print(bTag.getText())  Facade The sub-system has many objects and we want to decoupling them with the client’s calling, so we set a class Facade and use its instance to interact with the sub-system. The Facade just like an inter-media.\n 一个子系统有许多对象，而我们想要将这些对象与客户端调用解耦合，所以我们设置一个 “外观” 类，使用外观类的实例来与子系统交互。这个外观类实例就像一个处于中间的媒介。\n // Sub-System objects  class VideoFile {   }  class BitwiseNot {   }   class CvtColor {   }   class Transformer {   }   // Facade  class VideoConverter {  func convert() -\u0026gt; File {  var videoFile = VideoFile()  var bitwiseNot = BitwiseNot()  var cvtColor = CvtColor()  var transformer = Transformer()  var file = File()  return file  }  }  class File {   }   let converter = VideoConverter()  var file = converter.convert() Flyweight The flyweight is to make the memory can load more objects. An object may have some properties that is repeating, and it take many memory space, we move these properties into another class(called Flyweight), and the original class just hold a reference of the Flyweight instance.\n享元可以使内存能加载更多的对象。一个对象可能会拥有一些重复的、占用空间大的属性，我们将这些属性移到另外的一个类中（这个类称为享元），然后原来的类就只是持有一个享元实例的引用。\n // Client  class Game {  var bullets: [Bullet] = []  var factory: Factory  func creatBullet(_ count: Int) {  for i in 0..\u0026lt;count {  var b = Bullet(id: i, position: [Int.random(in: 0...20), Int.random(in: 0...20)], paint: factory.getBulletPaint(sign: BulletPaint.sign))  bullets.append(b)  }  }  init() {  factory = Factory()  }  }   // Context  class Bullet {  var id: Int  var position: [Int] = [0, 0]  var paint: BulletPaint  init(id: Int, position: [Int], paint: BulletPaint) {  self.id = id  self.position = position  self.paint = paint  }  }   // Flyweight  class BulletPaint {  var picture: String?  static var sign = 0  func changePicture(picture: String) {  self.picture = picture  BulletPaint.sign += 1  }  }   // Flyweight Factory  class Factory {  private var stuff: [BulletPaint] = []  func getBulletPaint(sign: Int) -\u0026gt; BulletPaint {  if stuff.count \u0026lt;= sign || stuff[sign] == nil {  var paint = BulletPaint()  stuff.append(paint)  return paint  }  return stuff[sign]  }  }   var game = Game()  game.creatBullet(100) Proxy A class Proxy and a class Service both conform to the same protocol ServiceInterface, and Proxy want to give some of its method to done by Service, so Proxy just keep a reference of Service and call the Service when Proxy it want to solve some problem.\n一个名为 “代理” 的类和一个名为 “服务” 的类都遵守同一个名为 “服务接口” 的协议， 然后代理想要把它的一些方法交给服务去做，进而代理只是持有服务的一个引用，然后在需要解决问题的时候，调用代理来解决。\n // Service Interface  protocol Work {  func manageStuff()  func dispatchSalary()  }   // Proxy  class Boss: Work {  var manager: Manager?  init(manager: Manager) {   }  func manageStuff() {  manager?.manageStuff()  }   func dispatchSalary() {  manager?.dispatchSalary()  }    }   // Service  class Manager: Work {  func manageStuff() {   }  func dispatchSalary() {   }  }   let manager = Manager()  let boss = Boss(manager: manager)  boss.dispatchSalary() // In fact, it\u0026#39;s the manager whom dispatch the salary. Delegate We move some detail method from class A to class B (delegation), and the B can do some detail by the inputed A’s reference.\n我们 A 中实现具体功能的方法移动到 B 中，B 为受委托对象，B 中的方法都是需要输入一个 A 的引用，从而才能让 B 替 A 做一些具体且复杂的操作。相当于 A 把复杂的操作委派给 B 来完成。\nClass Game has a GameDelegation in it. Then input the Game instance to the Delegation instance, and the delegation can do some detailed work that may be previously done by the Game instance. So it‘s called delegate model.\n类 game 拥有一个 GameDelegation . 接着输入 Game 实例到 Delegation 的实例，这个委派者可以做一些本来应该由 Game 的实例来完成的细节的事情。这样的模式称为委派模式。\n // Delegation  protocol Delegation {  func gameDidStart(_ game: Game)  func game(_ game: Game)  func gameDidEnd(_ game: Game)  }   // Game  protocol Game {  var delegation: Delegation? { get set }  func play()  }  // Concrete Deleagtion  class SnakeTracker: Delegation {  func gameDidStart(_ game: Game) {  }   func game(_ game: Game) {  // do something  }  func gameDidEnd(_ game: Game) {  }  }   // Concrete Game  class SnakeGame: Game {  var delegation: Delegation?  init(_ delegation: Delegation) {  self.delegation = delegation  }  func play() {  delegation!.gameDidStart(self)  delegation!.game(self)  delegation!.gameDidEnd(self)  }  }  let gameTracker = SnakeTracker()  let game = SnakeGame(gameTracker)  game.play() // It\u0026#39;s the func of the game, but the detail work is done by the delegation. Behavioral Chain of Responsibility We set a chain of responsibility. Then it t allow the solver solve the request or sends the request to the next another solver. As the diagram shown below, the handler is one solver of the chain.\n我们设定了一条责任链，然后它允许处理者选择处理请求或者将请求发送给下一个其它的处理者。下图中，handler 是责任链上的一个处理者。\n // Problem wait to be solve  class Request {  var priority: Int  var s: String  init(p: Int, s: String) {  priority = p  self.s = s  }  }   // Handler  protocol Thought {  func solve(r: Request)  }   // Base handler  class People: Thought {   var next: People?  func setNext(next: People) {  self.next = next  }  func solve(r: Request) {  if let n = next {  n.solve(r: r)  } else {  print(\u0026#34;No people want to solve\u0026#34;)  }  }   }   // Concrete handler  class Guard: People {  override func solve(r: Request) {  if r.priority \u0026lt; 2 {  print(\u0026#34;Just be sovled by Guard [\\(r.s)]\u0026#34;)  print(r.s)  } else {  super.solve(r: r)  }  }   }   // Concrete handler  class Commander: People {  override func solve(r: Request) {  if r.priority \u0026lt; 4 {  print(\u0026#34;Commander solve [\\(r.s)]\u0026#34;)  } else {  super.solve(r: r)  }  }  }   // Concrete handler  class Leader: People {  override func solve(r: Request) {  if r.priority \u0026lt; 10 {  print(\u0026#34;Leader come and solve [\\(r.s)]\u0026#34;)  } else {  super.solve(r: r)  }  }  }   let g = Guard()  let c = Commander()  let l = Leader()  g.setNext(next: c)  c.setNext(next: l)   let r = Request(p: 9, s: \u0026#34;Let us in\u0026#34;)  g.solve(r: r) Command Create receiver, then create command and link it to the receiver if needed, then create sender and link it to the specific command. The command mode extract the command from the business, and set a sender and receiver. The sender send message to receiver by calling the command, but not call the receiver directly.\n创建接收者，然后创建命令并且在有需要的时候把它连接到接收者，然后创建发送者并且把它连接到命令。命令模式从业务中抽出命令的部分，然后设置一个发送者和接收者。发送者通过调用命令向接受者发送信息，而不是直接调用接收者。\n // Message  class TableInfo {  var tableNo: Int?  init(tableNo: Int) {  self.tableNo = tableNo  }  }   // Receiver  class Cooker {  func cookMeal(info: TableInfo) {  print(\u0026#34;Cook meal for: \\(info.tableNo!)\u0026#34;)  }   func sayHello(info: TableInfo) {  print(\u0026#34;Say hello to: \\(info.tableNo!)\u0026#34;)  }   func reheatFood(info: TableInfo) {  print(\u0026#34;Reheat food for: \\(info.tableNo!)\u0026#34;)  }   }   // Command  protocol Command {  func execute(info: TableInfo)  }   // Concrete Command  class ServeCommand: Command {  var cooker: Cooker?  init(cooker: Cooker) {  self.cooker = cooker  }  func execute(info: TableInfo) {  cooker?.sayHello(info: info)  cooker?.cookMeal(info: info)  }  }   // Sender  class Waiter {  var command: Command  init(command: Command) {  self.command = command  }  func executeCommand(info: TableInfo) {  self.command.execute(info: info)  }  }   let cooker = Cooker()  let command = ServeCommand(cooker: cooker)  let waiter = Waiter(command: command)   waiter.executeCommand(info: TableInfo(tableNo: 4))   // Print:  // Say hello to: 4  // Cook meal for: 4 Iterator The idea of the iterator is to extract the traversal behavior into an independent iterator object. The collection has some elements, and we use the iterator to get each element step by step.\n迭代器的主要思想是将遍历行为抽取为单独的迭代器对象。\n // Element in the collection  class Node {  var info: String = \u0026#34;\u0026#34;  init(_ s: String) {  self.info = s  }  }   // Iterator  protocol Iterator {  func hasNext() -\u0026gt; Bool  func getNext() -\u0026gt; Node  }   // Concrete iterator  class PositiveIterator: Iterator {   var collection: Collection  var curIndex = 0   init(_ c: Collection) {  self.collection = c  }   func hasNext() -\u0026gt; Bool {  if curIndex \u0026lt; collection.nodes.count {  return true  } else {  return false  }  }   func getNext() -\u0026gt; Node {  var node = collection.nodes[curIndex]  curIndex += 1  return node  }   }   // Concrete iterator  class RevertIerator: Iterator {  var collection: Collection  var curIndex = 0   init(_ c: Collection) {  self.collection = c  self.curIndex = collection.nodes.count - 1  }   func hasNext() -\u0026gt; Bool {  if curIndex \u0026gt;= 0{  return true  } else {  return false  }  }   func getNext() -\u0026gt; Node {  var node = collection.nodes[curIndex]  curIndex -= 1  return node  }  }   // Collection  protocol Collection {  var nodes: [Node] { get set }  func getIterator() -\u0026gt; Iterator  func getRevertIterator() -\u0026gt; Iterator  }   // Concrete collecton  class NodesCollection: Collection {  var nodes: [Node]  init() {  self.nodes = []  }   func append(_ n: Node) {  nodes.append(n)  }   func getIterator() -\u0026gt; Iterator {  return PositiveIterator(self)  }   func getRevertIterator() -\u0026gt; Iterator {  return RevertIerator(self)  }  }   let str = \u0026#34;hello world\u0026#34;  let collection = NodesCollection()  for s in str {  collection.append(Node(String(s)))  }   var it = collection.getIterator()   while (it.hasNext()) {  var n = it.getNext()  print(n.info, terminator: \u0026#34; \u0026#34;)  }   print()   it = collection.getRevertIterator()   while (it.hasNext()) {  var n = it.getNext()  print(n.info, terminator: \u0026#34;_\u0026#34;)  } Mediator The mediator constrains the interaction between the component, the components can only notify the mediator and the mediator can manage the action of all the components it contains.\n中介者限制了组件之间的交互，组件只能通知中介一些指令，然后中介者管理它内部拥有的所有组件的数据操作与行为。\n // Component basic class  class Component {  var m: Mediator  init(mediator: Mediator) {  self.m = mediator  m.notify(component: self)  }  }   // Concrete component  class Button: Component {  func click() {  m.notify(component: self)  }  }  // Concrete component  class CheckBox: Component {  var check = false  func isCheck() -\u0026gt; Bool {  return check  }  }  // Concrete component  class PasswordText: Component {  var text: String = \u0026#34;\u0026#34;  func getText() -\u0026gt; String{  return text  }   }  // Concrete component  class UserNameText: Component {  var text: String = \u0026#34;\u0026#34;  func getText() -\u0026gt; String{  return text  }   }   protocol Mediator {  func notify(component: Component)  }   // Concrete mediator  class LoginMediator: Mediator {  var btnLogin: Button?  var tickSavePassword: CheckBox?  var password: PasswordText?  var userName: UserNameText?  func notify(component: Component) {  if component is Button {  var btn = component as! Button  if self.btnLogin == nil {  // self btn initialize  self.btnLogin = btn  return  }   if (canLogin(userName: userName?.getText(), password: password?.getText())) {  print(\u0026#34;Login success\u0026#34;)  if let wantSave = tickSavePassword?.isCheck() {  // save the userName and password  }  } else {  print(\u0026#34;Login failed\u0026#34;)  }  } else if component is CheckBox {  var box = component as! CheckBox  self.tickSavePassword = box  } else if component is UserNameText {  var userName = component as! UserNameText  self.userName = userName  } else if component is PasswordText {  var password = component as! PasswordText  self.password = password  }   }  }   // The function check whether the username and password match  func canLogin(userName: String?, password: String?) -\u0026gt; Bool {  if userName == nil || password == nil {  return false  }  if let name = userName, let word = password{  if name == \u0026#34;hello\u0026#34; \u0026amp;\u0026amp; word == \u0026#34;Mike\u0026#34; {  return true  } else {  return false  }  }  return false  }   let mediator = LoginMediator()  let userName = UserNameText(mediator: mediator)  let password = PasswordText(mediator: mediator)  let tickSavePassword = CheckBox(mediator: mediator)  let btnLogin = Button(mediator: mediator)   userName.text = \u0026#34;hello\u0026#34;  password.text = \u0026#34;Mike\u0026#34;  tickSavePassword.check = true   btnLogin.click() Memento It allow to save or recover the object state before without expose the object’s implemented detail. The originator can create the snapshot of itself and can restore the snapshot when it need. The memento is a value object of the originator’s snapshot state, it’s built by the initializer and pass the information by only one time. The caretaker can only use the originator’s makeMemento() and restore().\n它允许在不暴露对象实现细节的情况下，保存和恢复对象之前的状态。原发器可以创建它自己的快照并且在需要的时候恢复快照到自身。备忘录是一个用于存放原发器快照状态的值对象，它只通过构造函数传递状态信息。负责人只可以使用原发器的 “创建快照” 和 “恢复状态” 的方法。\n // Originator  protocol Animal {  func getMemento() -\u0026gt; Memento  }   // Memento  protocol Memento {  func restore()  }   // Concrete originator  class Dog: Animal {  private var age: Int  private var weight: Float  private var legCount: Int   init(age: Int, weight: Float, legCount: Int) {  self.age = age  self.weight = weight  self.legCount = legCount  }  func getMemento() -\u0026gt; Memento {  return DogData(dog: self, age: age, weight: weight, legCount: legCount)  }  func setAge(age: Int) {  self.age = age  }  func setWeight(weight: Float) {  self.weight = weight  }  func setLegCount(legCount: Int) {  self.legCount = legCount  }   func info() -\u0026gt; String {  return \u0026#34;age: \\(age)weight: \\(weight)legCount: \\(legCount)\u0026#34;  }  }   // Concrete memento  class DogData: Memento {  private var age: Int  private var weight: Float  private var legCount: Int   private var dog: Dog?   init(dog: Dog, age: Int, weight: Float, legCount: Int) {  self.dog = dog  self.age = age  self.weight = weight  self.legCount = legCount  }   func restore() {  dog?.setAge(age: age)  dog?.setWeight(weight: weight)  dog?.setLegCount(legCount: legCount)  }   }   // CareTaker  class Recored {  var dog: Dog  var history: [Memento] = []  init(dog: Dog) {  self.dog = dog  }  func save() {  var backup = dog.getMemento()  history.append(backup)  if (history.count \u0026gt; 10) {  history.remove(at: 0)  }  }   func undo() {  if history.count \u0026lt;= 0 {  return  }  var data = history[history.count - 1]  data.restore()  history.remove(at: history.count - 1)  }   }   let dog = Dog(age: 2, weight: 15, legCount: 4)  let record = Recored(dog: dog)  record.save()  print(dog.info())   dog.setAge(age: 4)  dog.setWeight(weight: 20)  print(dog.info())   record.undo()  print(dog.info()) Observer The publisher has some subscribers reference, it can add subscriber, remove subscriber, and notify all subscriber.\n发布者持有一些订阅者的引用，它可以添加订阅者，也可以移除订阅者，或者是通知所有的订阅者。\n class Message {  var text: String = \u0026#34;\u0026#34;  init(_ m: String) {  self.text = m  }  }   class Event {  var text: String = \u0026#34;\u0026#34;  init(_ e: String) {  self.text = e  }  }   // Subscriber  protocol Listener {  func update(message: Message)  }   // Publisher  protocol Publisher {  func subscribe(event: Event, listener: Listener)  func remove(event: Event)  func notify(event: Event, message: Message)  func notifyAll(message: Message)  }   // Concrete listener  class ListenerA: Listener {  func update(message: Message) {  print(\u0026#34;A do: \\(message.text)\u0026#34;)  }  }   // Concrete listener  class ListenerB: Listener {  func update(message: Message) {  print(\u0026#34;B do: \\(message.text)\u0026#34;)  }  }   // Concrete publisher  class ViewPublisher: Publisher {  var listeners: [String: Listener] = [:]  func subscribe(event: Event, listener: Listener) {  listeners[event.text] = listener  }   func remove(event: Event) {  listeners.removeValue(forKey: event.text)  }   func notify(event: Event, message: Message) {  listeners[event.text]?.update(message: message)  }   func notifyAll(message: Message) {  for item in listeners.values {  item.update(message: message)  }  }   }   let publisher = ViewPublisher()  let a = ListenerA()  let b = ListenerB()  publisher.subscribe(event: Event(\u0026#34;look\u0026#34;), listener: a)  publisher.subscribe(event: Event(\u0026#34;find\u0026#34;), listener: b)   publisher.notify(event: Event(\u0026#34;look\u0026#34;), message: Message(\u0026#34;Firstly, welcome.\u0026#34;))  print()   publisher.notifyAll(message: Message(\u0026#34;Hello world!\u0026#34;))  print()   publisher.remove(event: Event(\u0026#34;look\u0026#34;))   publisher.notifyAll(message: Message(\u0026#34;The end.\u0026#34;)) State The state mode enable the class to change its behavior when its inner state changed. The StateContext only do the switch work, and the detail work is done by State object. The context manage the statements in a high level, it can switch some different state when we need. The context inject a reference to the concrete state object to enable the state to delegate the detail work. 状态模式中，当类的状态改变时，类的行为随着改变。状态上下文类只执行状态切换工作，具体的工作细节交给状态对象去执行。上下文对象在一个较高的层次管理着自身的状态，它可以在我们有需要的时候切换不同的状态。上下文对象注入了一个自己的引用给状态对象，使得状态对象可以代理在切换状态时候的细节工作。\n // Abstract state  class State {  var context: Context?  var name: String = \u0026#34;\u0026#34;  init(context: Context?) {  self.context = context  }   }   // Concrete state  class NewState: State {  override init(context: Context?) {  super.init(context: context)  self.name = \u0026#34;New\u0026#34;  }  func start() {  print(\u0026#34;Call start\u0026#34;)  if self.name == \u0026#34;New\u0026#34; {  context?.setState(state: RunnableState(context: context))  } else {  print(\u0026#34;Can\u0026#39;t go to runnable\u0026#34;)  }  }  }   // Concrete state  class RunnableState: State {  override init(context: Context?) {  super.init(context: context)  self.name = \u0026#34;Runnable\u0026#34;  }  func getCpu() {  if self.name == \u0026#34;Runnable\u0026#34; {  context?.setState(state: RunningState(context: context))  } else {  print(\u0026#34;Can\u0026#39;t go to running\u0026#34;)  }  }  }   // Concrete state  class RunningState: State {  override init(context: Context?) {  super.init(context: context)  self.name = \u0026#34;Running\u0026#34;  }   func suspend() {  if self.name == \u0026#34;Running\u0026#34; {  context?.setState(state: BlockState(context: context))  }  }   func stop() {  if self.name == \u0026#34;Running\u0026#34; {  context?.setState(state: DeadState(context: context))  }  }   }   // Concrete state  class BlockState: State {  override init(context: Context?) {  super.init(context: context)  self.name = \u0026#34;Block\u0026#34;  }   func resume() {  if name == \u0026#34;Block\u0026#34; {  context?.setState(state: RunnableState(context: context))  }  }  }   // Concrete state  class DeadState: State {  override init(context: Context?) {  super.init(context: context)  self.name = \u0026#34;Dead\u0026#34;  }    }   // Thread Context  class Context {  private var state: State?  init() {  self.state = NewState(context: self)  }   func setState(state: State) {  self.state = state  }   func getState() -\u0026gt; State? {  return self.state  }   func start() {  if let s = self.state as? NewState {  s.start()  }  }   func suspend() {  if let s = self.state as? RunningState {  s.suspend()  }  }    func resume() {  if let s = self.state as? BlockState {  s.resume()  }  }   func getCpu() {  if let s = self.state as? RunnableState {  s.getCpu() // It will switch to the running state.  }  }  func stop() {  if let s = self.state as? RunningState {  s.stop()  }  }    }   let context = Context()  context.start() // It will be runnable then.  context.getCpu() // It will be running then.  context.suspend() // It will be blocked then.  context.resume() // It will be runnable then.  context.getCpu() // It will be running then.  context.stop() // It will be dead then. Strategy Strategy mode set some solution class, and each solution can be substituted by other solution easily. When we face different problem, we choose different solution to solve problem. The Problem class hold a reference of Strategy interface to use different strategy. 策略模式设定了一些算法类，每个算法类可以被其它算法类所替换。当我们面对不同的问题时，我们选择不同的策略来解决问题。“问题” 类持有 “策略”接口， 以便使用不同的策略。\n protocol Strategy {  func sort(_ nums: inout [Int]) -\u0026gt; [Int]  }   // Strategy A  class SelectedSort: Strategy {  func sort(_ nums: inout [Int]) -\u0026gt; [Int] {  print(\u0026#34;Selected sort\u0026#34;)  var len = nums.count  if len \u0026lt;= 1 {  return nums  }  for i in 0..\u0026lt;len {  var minIndex = i  for j in (i + 1)..\u0026lt;len {  if nums[j] \u0026lt; nums[minIndex] {  minIndex = j  }  }  var tmp = nums[i]  nums[i] = nums[minIndex]  nums[minIndex] = tmp  }  return nums  }  }   // Strategy B  class InsertSort: Strategy {  func sort(_ nums: inout [Int]) -\u0026gt; [Int] {  print(\u0026#34;Insert sort\u0026#34;)  var len = nums.count  if len \u0026lt;= 1 {  return nums  }  for i in 1..\u0026lt;len {  var left = i - 1  while true {  if left \u0026lt; 0 || nums[i] \u0026gt; nums[left] {  var cover = i - 1  var t = nums[i]  while cover \u0026gt; left {  nums[cover + 1] = nums[cover]  cover -= 1  }  nums[left + 1] = t  break  } else {  left -= 1  }  }  }  return nums  }  }   class Problem {  private var strategy: Strategy  init(strategy: Strategy) {  self.strategy = strategy  }  func solve(_ nums: inout [Int]) -\u0026gt; [Int] {  strategy.sort(\u0026amp;nums)  }   func changeStrategy(strategy: Strategy) {  self.strategy = strategy  }  }   var nums = [2, 6, 1, 5, 0, 3]   var a = SelectedSort()  var b = InsertSort()  var problem = Problem(strategy: a)  problem.solve(\u0026amp;nums)  print(nums)   nums.shuffle()  print(nums)   problem.changeStrategy(strategy: b)  problem.solve(\u0026amp;nums)  print(nums) Template Method The super class define an algorithm structure, and the subclass can override the method without changing the structure. Depart an algorithm into a series of step, and rewrite these step as method, then call these method in the template method.\n超类定义了一个算法框架，子类可以在不改动框架的情况下依据需要来重写方法。把算法拆分为一系列的步骤，把这些步骤写成方法，然后可以在模板方法中调用这些方法。\n // Abstract class  class House {  // Use final to prevent the subclass override the template method.  final func build(){  makeRoot()  makeWall()  makeWindows()  makeRoof()  }   func makeRoot() {  print(\u0026#34;Use cement to construct root.\u0026#34;)  }   func makeWall() {  print(\u0026#34;Add white wall\u0026#34;)  }   func makeWindows() {  print(\u0026#34;Add window\u0026#34;)  }   func makeRoof() {  print(\u0026#34;Add smooth roof\u0026#34;)  }  }   // Concrete class A  class EastenHouse: House {  override func makeWall() {  print(\u0026#34;Add red wall.\u0026#34;)  }   override func makeWindows() {  print(\u0026#34;Add wooden windows.\u0026#34;)  }   override func makeRoof() {  print(\u0026#34;Add wooden roof.\u0026#34;)  }   }   // Concrete class B  class WestenHouse: House {   override func makeWindows() {  print(\u0026#34;Add iron windows\u0026#34;)  }    override func makeRoof() {  print(\u0026#34;Add cement roof\u0026#34;)  }  }   let house = EastenHouse()  house.build()   let houseB = WestenHouse()  houseB.build() Visitor Visitor mode can isolate the algorithm and the object which algorithm affect. (Depart the server and the visitor). It put the new behaviors into a Visitor class, then pass the existed object’s reference to the visitor to do the behaviors. It just visit the data of the object, but not change the original data.\n访问者模式可以隔离算法和被这个算法影响的对象（分离服务者和访问者）。它将新的行为放置在一个称为 “访问者” 的对象中，然后传递原有对象的引用来执行一些行为。它只是访问对象数据，而没有改变源数据。\n protocol Visitor {  func visit(d: Dog)  func visit(c: Cat)  func visit(h: Horse)  }   protocol Element {  func accept(v: Visitor)  }   // Element A  class Dog: Element {  var name = \u0026#34;dog\u0026#34;  var age = 0  func accept(v: Visitor) {  v.visit(d: self)  }  }   // Element B  class Cat: Element {  var name = \u0026#34;cat\u0026#34;  var age = 1  func accept(v: Visitor) {  v.visit(c: self)  }  }   // Element C  class Horse: Element {  var name = \u0026#34;horse\u0026#34;  var age = 2  func accept(v: Visitor) {  v.visit(h: self)  }  }   // Visitor 1  class NameVisitor: Visitor {  func visit(d: Dog) {  print(d.name)  }   func visit(c: Cat) {  print(c.name)  }   func visit(h: Horse) {  print(h.name)  }  }   // Visitor 2  class AgeVisitor: Visitor {  func visit(d: Dog) {  print(\u0026#34;Dog age: \\(d.age)\u0026#34;)  }   func visit(c: Cat) {  print(\u0026#34;Cat age: \\(c.age)\u0026#34;)  }   func visit(h: Horse) {  print(\u0026#34;Horse age: \\(h.age)\u0026#34;)  }  }   let dog = Dog()  let cat = Cat()  let horse = Horse()   let nameVisitor = NameVisitor()  let ageVisitor = AgeVisitor()   dog.accept(v: nameVisitor)  cat.accept(v: nameVisitor)  horse.accept(v: nameVisitor)   dog.accept(v: ageVisitor)  cat.accept(v: ageVisitor)  horse.accept(v: ageVisitor) 模式的特征与区别 结构型  适配器模式的目的是为了让类 A 去模仿类 B，从而在需要类 B 的地方可以直接使用类 A 替代，适配器C既具有 B 的属性，又看起来像是 B （因为适配器继承自类 B） 桥接模式是具体的类 A 中具有抽象接口 B，构造 A 的时候注入一个 B 的实体对象，那么可以在使用对象 A 的时候，可以调用接口 B 来实现对应功能，这样的类 A 是依赖于接口而不是具体的类。 桥接模式是两个类 A 与 B 之间，使用一个接口，由 B 实现， 注入 A。 组合模式是组件模块与容器（抽象接口）都实现同一接口，容器里面可以持有多个接口实例（由组件模块实例来注入），形成树状结构。 装饰器模式是组件与装饰器（抽象接口）都实现同一接口，装饰器里面持有一个接口实例（由组件模块实例来注入）， 装饰器对持有的实例添加附带功能。 委托模式（delegate）是让一个对象扮演另外一个对象的行为。委托对象暂时持有到另外对象的引用。在适当时间发消息给另外对象。 代理模式（proxy）比委托更为严格，若干对象实现同一接口。  行为型   责任链模式（chain of responsibility）模式中的每一个对象持有指向另一对象的引用 A（用于转移责任），询问当前对象，当前对象若有能力处理事务则处理，若没有能力处理事务则把事务移交给另外一个对象（引用 A 所指）处理。\n  命令模式（command) 发送者和接收者使用命令进行间接沟通，常用于视图和控制器的分离（视图为发送者，控制器为接收者）。若与责任链结合，则为命令在传递给接收者的时候，是传递到接收者链上，从而寻求潜在的接收者。\n  中介者模式（mediator）设置一个中介者来管理那些来自组件的调用，中介者拥有各个组件的引用，站在更高的层次上对组件进行管理。组件之间通过中介者来发生交互，而不是组件之间进行耦合。\n  备忘录模式（memento），为原发器添加一个备忘录对象用于存放原发器的的状态信息，使用一个负责人对象来管理备忘录的增加与回滚，可以对原发器的版本进行控制。\n  观察者模式（observer），发布者持有多个订阅者的引用，当有需要发布新消息时，准确地向每个订阅者发送信息。\n中介者和观察者很像，但是，中介者主要功能是消除一系列的组件之间的依赖，用于管理组件之间的调用，而观察者强调的是发布者向各个订阅的订阅者分发信息。\n  状态模式（状态模式）与策略模式（strategy）关键区别：\n状态模式中的特定状态知道其它状态的存在，能从一个状态转移到另一状态。\n策略模式中某个策略不知道其它策略的存在。\n  模版方法（template method) 中，超类定义了若干模板框架方法（固定的）和步骤方法，子类不能修改框架方法，只能重写步骤方法。模板方法中可以调用详细的步骤方法。工厂模式是模版方法的特殊形式。\n  访问者（visitor) 将操作交给其它的类（访问者类），允许访问者进行访问。它是命令模式的加强版本。访问者模式中，业务在需要使用访问服务的时候，传递自己的引用给访问者，而代理模式和委托模式是将自身引用注入到受托付到对象中，移交自己的权利。\n  ","permalink":"https://1-1.link/post/design-pattern/all-design-pattern/","summary":"Creational Object Created Pattern\nFactory Method Provide the method for creating an instance in the superclass, and allow the subclass to choose the type of the instance.\n在父类中提供创建对象的方法，允许子类决定实例化对象的类型。\n具备的部分：生产者协议、产品协议，往后就可以根据需要来扩展每一种产品。\n具体的生产者比如 MongoCakeCreator 的存在是为了实现与产品相关的核心业务逻辑，而不仅仅是创建 MongoCake 实例。工厂方法将核心业务逻辑从具体产品类中分离出来。\n // Creator  protocol CakeCreator {  func createCake() -\u0026gt; Cake  func doSomethingForCake(cake: Cake) -\u0026gt; Cake  }   // Product  protocol Cake {  func doWork()  }   // ConcreteCreator  class MongoCakeCreator: CakeCreator {  var cake: MongoCake?","title":"各种设计模式"},{"content":"G-Mail teochewness@gmail.com\nQQ 邮箱 1252622709@qq.com\n","permalink":"https://1-1.link/post/info/contact/mail/","summary":"now","title":"Mail"},{"content":"Hey\n","permalink":"https://1-1.link/home/","summary":"Hey","title":"home"},{"content":"Unlike arithmetic operators in C, arithmetic operators in Swift don’t overflow by default. If want to overflow by default, use the overflow operation begin with ampersand (\u0026amp;). For example, the overflow addition operator (\u0026amp;+).\nIt’s so free to define custom infix, prefix, postfix and assignment operators, precedence and associativity values.\nBitwise Operators Here we use a function to pad 0 for the number’s print result.\nfunc pad(num: UInt8, count: Int) -\u0026gt; String {  var str = String(num, radix: 2)  var res: String = str  for _ in 0..\u0026lt;(count - str.count) {  res = \u0026#34;0\u0026#34; + res  }   return res  }   ~ NOT\n~1 is 0\n~0 is 1\n  \u0026amp; AND\n1 \u0026amp; 1 is 1\n1 \u0026amp; 0 is 0\n0 * 0 is 0\n  | OR\n1 | 1 is 1\n1 | 0 is 1\n0 | 0 is 0\n  ^ XOR\n1 ^ 1 is 0\n1 ^ 0 is 1\n0 ^ 0 is 0\n  Bitwise NOT Operator Use ~ to do NOT operation.\nvar a: UInt8 = 0b11111100 var b = ~a print(pad(num: b, count: 8)) // 00000011 UInt8 has 8 bits, and can store 0 to 255.\nBitwise AND Operator Use \u0026amp; to do AND operation.\nlet a: UInt8 = 0b11111100 let b: UInt8 = 0b00011010 let c = a \u0026amp; b print(pad(num: c, count: 8)) // 00011000 Bitwise OR Operator Use | to do OR operator.\nlet a: UInt8 = 0b11111100 let b: UInt8 = 0b00011010 let c = a | b print(pad(num: c, count: 8)) // 11111110 Bitwise XOR Operator Return a new number whose bits are set to 1 where the input bits are different and are set to 0 where the input bits are the same.\nlet a: UInt8 = 0b11111100 let b: UInt8 = 0b00011010 let c = a ^ b print(pad(num: c, count: 8)) // 11100110 Bitwise Left and Right Shift Operators Left shift (\u0026lt;\u0026lt;) move all bits in a number to the left.\nlet a: UInt8 = 0b00111100 let b = a \u0026lt;\u0026lt; 1 let c = a \u0026lt;\u0026lt; 2 print(pad(num: b, count: 8)) // 01111000 print(pad(num: c, count: 8)) // 11110000 Shifting of the Unsigned Integer It will place an zero at the left when right shift, and place an zero at the right when left shift.\nRight shift (\u0026gt;\u0026gt;) move all bits in a number to the right.\nlet a: UInt8 = 0b00111100 let b = a \u0026gt;\u0026gt; 1 let c = a \u0026gt;\u0026gt; 2 print(pad(num: b, count: 8)) // 00011110 print(pad(num: c, count: 8)) // 00001111 Use bit shifting to encode and decode values within other data types:\nlet pink: UInt32 = 0xCC6699 let redComponent = (pink \u0026amp; 0xFF0000) \u0026gt;\u0026gt; 16 let greenComponent = (pink \u0026amp; 0x00FF00) \u0026gt;\u0026gt; 8 let blueComponent = pink \u0026amp; 0x0000FF print(String(redComponent, radix: 16)) // cc print(String(greenComponent, radix: 16)) // 66 print(String(blueComponent, radix: 16)) // 99  // By AND operation and shifting, we get the three part of the \u0026#34;pink\u0026#34; color: R G B The CSS color value #CC6699 is written as 0xCC6699 in Swift’s hexadecimal number representation.\nShifting Behavior for Signed Integer In the 8-bit signed integer example:\nSigned Integer use its first bit to indicate whether the integer is positive or negative. (0 is positive, 1 is negative)\n00000100 is 4\n11111100 is -4, the first bit 1 indicate that the integer is negative, and the remain 7 bits is 124 means that 128 - 124 = -4\nSo the signed 8-bits can represent -128(10000000) to 127(01111111).\nTwo’s Complement Representation\nThe way it’s encoded above is known as a two’s complement representation. In this way it has several advantage.\n  Add -4 and -1, it add in binary rule and discard anything that overflow.\n(-4) + (-1) = 11\n11111100 + 11111111 = 11111011\n  arithmetic shift\n  left shift: an arithmetic shift = a logical shift. It will doubling the number.\n  right shift: when shift signed integers to the right, apply same rules as for unsigned integers, but fill any empty bits on the left with the sign bit, rather than with a zero.\n11111110 \u0026gt;\u0026gt; 1 will be 11111111 01111110 \u0026gt;\u0026gt; 1 will be 00111111 In this way it ensures that the number will has the same sign after shifting. The shift will moves both positive and negative numbers closer to zero.\n    Overflow Operators When the constant or variable can’t hold the value that too large or too small, Swift will raise an error.\n// The num get the max value of Int8 var num = Int8.max  num += 1 // Here will a runtime-error. If we specifically want an overflow condition to truncate the number of available bits, we can use the overflow operators that begin with an ampersand (\u0026amp;).\n Overflow addition (\u0026amp;+) Overflow subtraction (\u0026amp;-) Overflow multiplication (\u0026amp;*)  Value Overflow If we allow the number to overflow, it may overflows in both positive and negative direction.\nvar num: UInt8 = UInt8.max // It\u0026#39;s 11111111 (255) num = num \u0026amp;+ 2  print(pad(num: num, count: 8)) // 00000001  var n: UInt8 = 1 n = n \u0026amp;- 2 print(pad(num: n, count: 8)) // 11111111 The overflow operation can be apply to signed integer.\nvar signedNum: Int8 = Int8.min // -128 signedNum = signedNum \u0026amp;- 1 print(String(signedNum, radix: 2)) // 127 Precedence and Associativity From high to low:\n %   /             let a = 2 + 3 % 4 * 5 print(a) // 17 Left associative: calculate from left to right.\n      / % \u0026amp; \u0026amp;*           | ^ \u0026amp;+ \u0026amp;- is as as? as! \u0026amp;\u0026amp; .\u0026amp; || .| .^  Right associative: calculate from right to left.\n ?? :? = *= /= %= += -= \u0026laquo;=    =\n   \u0026amp;= |= ^= \u0026amp;*= \u0026amp;+= \u0026amp;-= \u0026amp;\u0026raquo;= \u0026amp;\u0026laquo;= .\u0026amp;= .|= .^=  Isn’t associative:\n \u0026laquo;       \u0026amp;\u0026laquo; \u0026amp;\u0026raquo; \u0026lt; \u0026lt;=       =\n  == != === !== ~= .\u0026lt; .\u0026lt;= .\u0026gt; .\u0026gt;= .== .!= ..\u0026lt; …  Operator Methods Classes and structures can overloading the existing operators.\nstruct Vector2D {  var x = 0.0, y = 0.0 }  extension Vector2D {  static func + (left: Vector2D, right: Vector2D) -\u0026gt; Vector2D{  return Vector2D(x: left.x + right.x, y: left.y + right.y)  } }  var a = Vector2D(x: 1.0, y: 2.0) var b = Vector2D(x: 3.0, y: 3.0) var c = a + b print(c) // Vector2D(x: 4.0, y: 5.0) Prefix and Postfix Operators extension Vector2D {  static prefix func - (vector: Vector2D) -\u0026gt; Vector2D {  return Vector2D(x: -vector.x, y: -vector.y)  } } var x = Vector2D(x: 1.0, y: 2.0) var xx = -x print(xx) // Vector2D(x: -1.0, y: -2.0) Compound Assignment Operators +=\nextension Vector2D {  static func += (left: inout Vector2D, right: Vector2D){  left = left + right  } } var v = Vector2D(x: 1.0, y: 2.0) var w = Vector2D(x: 4.0, y: -3.0)  v += w print(v) // Vector2D(x: 5.0, y: -1.0) Equivalence Operators ==\nOne way to make == be valid for enumeration or structure: Conform to the Equalble , it has provided method to do that.\nextension Vector2D: Equatable {  }  var one = Vector2D(x: 1.0, y: 2.0) var two = Vector2D(x: 1.0, y: 2.0)  print(one == two) // true Another way is to implement the method in the extension.\nextension Vector2D: Equatable {  static func == (left: Vector2D, right: Vector2D) -\u0026gt; Bool {  return (left.x == right.x) \u0026amp;\u0026amp; (left.y == right.y)  } }  var one = Vector2D(x: 1.0, y: 2.0) var two = Vector2D(x: 1.0, y: 2.0)  print(one == two) // true Custom Operators Prefix operator\nprefix operator +++ extension Vector2D {  static prefix func +++ (vector: inout Vector2D) -\u0026gt; Vector2D {  vector += vector  return vector  } }  var some = Vector2D(x: 1.0, y: 2.0)  +++some  print(some) // Vector2D(x: 2.0, y: 4.0) Precedence for Custom Infix Operators Here we define a new custom infix operator call +-, which belongs to the precedence group AdditionPrecedence.\ninfix operator +-: AdditionPrecedence exthe tension Vector2D {  static func +- (left: Vector2D, right: Vector2D) -\u0026gt; Vector2D{  return Vector2D(x: left.x + right.x, y: left.y - right.y)  } }  var a = Vector2D(x: 1.0, y: 2.0) var b = Vector2D(x: 2.0, y: 3.0) var c = a +- b  print(c) // Vector2D(x: 3.0, y: -1.0) Don’t need to specify a precedence when defining a prefix or postfix operator. When apply both prefix and postfix to the same operand, the postfix operator is applied first.\nResult Builders If the code without result builder:\nprotocol Drawable {  func draw() -\u0026gt; String } struct Line: Drawable {  var elements: [Drawable]  func draw() -\u0026gt; String{  return elements.map { $0.draw() }.joined(separator: \u0026#34;\u0026#34;)  } }  struct Text: Drawable {  var content: String  init(_ content: String) {  self.content = content  }  func draw() -\u0026gt; String {  return content  } }  struct Space: Drawable {  func draw() -\u0026gt; String {  return \u0026#34; \u0026#34;  } }  struct Star: Drawable {  var length: Int  func draw() -\u0026gt; String {  return String(repeating: \u0026#34;*\u0026#34;, count: length)  } }  struct AllCaps: Drawable {  var content: Drawable  func draw() -\u0026gt; String {  return content.draw().uppercased()  } }  let name: String? = \u0026#34;Mike\u0026#34; let drawing = Line(elements: [  Star(length: 3),  Text(\u0026#34;Hello\u0026#34;),  Space(),  AllCaps(content: Text((name ?? \u0026#34;World\u0026#34;) + \u0026#34;!\u0026#34;)),  Star(length: 3) ])  print(drawing.draw()) // ***Hello MIKE!*** The content in the AllCaps is awkward, if the content is complex, and have some extra conditions, it’s hard to write.\nSo we use the result builder to solve this problem.\n@resultBuilder struct DrawingBuilder {  // It combines several components into a line  static func buildBlock(_ components: Drawable...) -\u0026gt; Drawable{  return Line(elements: components)  }   static func buildEither(first: Drawable) -\u0026gt; Drawable{  return first  }   static func buildEither(second: Drawable) -\u0026gt; Drawable {  return second  }  }  func draw(@DrawingBuilder content: () -\u0026gt; Drawable) -\u0026gt; Drawable {  return content() }  func caps(@DrawingBuilder content: () -\u0026gt; Drawable) -\u0026gt; Drawable {  return AllCaps(content: content()) }  func makeGreeting(for name: String? = nil) -\u0026gt; Drawable {  let greeting = draw {  Star(length: 3)  Text(\u0026#34;Hello\u0026#34;)  Space()  caps {  if let name = name {  Text(name + \u0026#34;!\u0026#34;)  } else {  Text(\u0026#34;World!\u0026#34;)  }  }  Star(length: 2)  }  return greeting }  let p = makeGreeting() print(p.draw()) // ***Hello WORLD!** let s = makeGreeting(for: \u0026#34;Amy\u0026#34;) print(s.draw()) // ***Hello AMY!** The Swift will transform the call to caps(_: ) into code like this:\nlet capsDrawing = caps {  let partialDrawing: Drawable  if let name = name {  let text = Text(name + \u0026#34;!\u0026#34;)  partialDrawing = DrawingBuilder.buildEither(first: text)  } else {  let text = Text(\u0026#34;World!\u0026#34;)  partialDrawing = DrawingBuilder.buildEither(second: text)  }  return partialDrawing } Add support for writing for loops\nextension DrawingBuilder {  static func buildArray(_ components: [Drawable]) -\u0026gt; Drawable {  return Line(elements: components)  } }  let manyStars = draw {  Text(\u0026#34;Stars:\u0026#34;)  for length in 1...3 {  Space()  Stars(length: length)  } } The result builder makes it easier and neater to organize the function blocks.\n","permalink":"https://1-1.link/post/language/swift/28advanced-operators/","summary":"Unlike arithmetic operators in C, arithmetic operators in Swift don’t overflow by default. If want to overflow by default, use the overflow operation begin with ampersand (\u0026amp;). For example, the overflow addition operator (\u0026amp;+).\nIt’s so free to define custom infix, prefix, postfix and assignment operators, precedence and associativity values.\nBitwise Operators Here we use a function to pad 0 for the number’s print result.\nfunc pad(num: UInt8, count: Int) -\u0026gt; String {  var str = String(num, radix: 2)  var res: String = str  for _ in 0.","title":"Advanced Operators"},{"content":"Access control restrict access to part of the code form code in other source files and modules. It enable us to hide the implement detail of the code, and to specify a preferred interface which that code can be accessed and used.\nSet access levels to individual types (classes, structures, enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types.\nProtocols can be restricted to a certain context, as can global constants, variable, and functions.\nWhen writing a single-target App, it has no need to specify explicit access control level at all.\nModules and Source Files Access control model is based on the concept of modules and source files.\nA module is single unit of code distribution (a framework or ) that can be imported by another module with import keyword.\nEach build target (app bundle or framework) is a separate module in Swift.\nIf an app’s code is grouped together as a stand-alone framework, everything in it will be part of a separate module.\nA source file always contains definition for multiple types, functions, and so on.\nAccess Levels Swift provides five access level for entities. These access levels are relative to the source file in which entity is defined, and also relative to the module that source file belongs to.\n Open access and public access enable entities to be use within any source file from their defining module, and also in a source file from another module that imports the defining module. Internal access enables entities to be used within any source file from their defining, but not in any file outside of that module. File-private access restricts the use of an entity to its own defining source file. Private access restricts the use of an entity to the enclosing declaration, and extensions of that declaration that are in the same file.  Open access only applies to classes and class members. It allows code outside the module to subclass and override, but public access can’t. Making a class as open indicate that using the class from other modules as a superclass.\nGuiding Principle of Access Levels No entity can be define in terms of another entity that has a lower(more restrictive) access level.\n A public variable can’t be defined as having an internal, file-private, or private type, because the type might not be available everywhere that the public variable is used. (higher access level can’t contain lower level in the variable) A function can’t have a higher access level than its parameter types and return type.  Default Access Levels All entities have a default access level of internal, so in many case we don’t need to specify an explicit access level.\nAccess Level for Single-Target Apps The code in an app is self-contained and doesn’t need to be made available outside of the app’s module. The default internal already matches this requirement. And we can mark some part as file private or private to hide their implementation detail from other code within the app’s module.\nAccess Levels for Framework Use default access level of internal to hide the implementation, or marked as private or file private makes the framework’s code hidden\nAccess Levels for Unit Test Targets By default, only open or public can be access in other module. However, a unit test target can access any internal entity if use the attribute @testable to mark the import declaration.\nAccess Control Syntax public class SomePublicClass {} internal class SomeInternalClass {} fileprivate class SomeFilePrivateClass {} private class SomePrivateClass {}  public var somePublicVariable = 0 internal let someInternalConstant = 0 fileprivate func someFilePrivateFunction() {} private func somePrivateFunction() {}  class dog {} // implicitly internal let var a = 0 // implicitly internal Custom types public var name = \u0026#34;default\u0026#34; // explicitly public   var age = 0 // implicitly internal   fileprivate func run() {} // explicitly file-private  private func eat() {} // explicitly private }  class Cat { // implicitly internal  var name = \u0026#34;\u0026#34; // implicitly internal  fileprivate func sit() {} // explicitly file-private  private func sleep() {} // explicitly private }  fileprivate class Bear { // explicitly file-private  func climb() {} // implicitly file-private  private func stand() {} // explicitly private }  private class Snake { // explicitly private  func eat() {} // implicitly private } Tuple Types When compound tuple, it will get the minimum access level.\nIf we compound two tuple type, one with internal access and one with private access, the result will be private. A tuple type’s access level is determined automatically from the types that make up the tuple type, and can’t be specified explicitly.\nFunction Types The function’s access level must matches the access level of the return type.\nHere the tuple has the minimum access level (private), so the function should be marked as private.\nprivate func someFunc() -\u0026gt; (SomeInternalClass, SomePrivateClass) {  } Enumeration Types Each cases will automatically receive the same access level as the enumeration it belongs to.\npublic enum Direction {  case north // public  case south // public  case east  case west } Raw values and associated values must have an access level at least as high as the enumeration’s level.\nThe access level of a nested type is the same as its containing type, unless the containing type is public (Nested type define within a public type have an automatic access level of internal implicitly).\nSubclassing A subclass can’t have higher access level than its superclass.\nFor classes that are defined in the same module, we can override any class member.\nFor classes that are defined in another module, we can override any open class member.\nAn override can make an inherited class member more accessible than its superclass version.\npublic class A {  fileprivate func someMethod() {   } }  public class B: A {  override internal func someMethod() {  super.someMethod() // Because superclass A and subclass B are defined in the same source file, it\u0026#39;s valid for the method in B to call super.someMethod.  } } It’s valid for a subclass member to call a superclass member that has lower access permission than the subclass member, as long as the call to the superclass’s member has the allowed access level context.\npublic class A {  fileprivate func someMethod() {   } }  public class B: A {  override internal func someMethod() {  super.someMethod()  } }  // They are in the same source file, so the \u0026#34;B\u0026#34; can call the file-private method from the \u0026#34;A\u0026#34;. Constants, Variables, Properties, and Subscripts A private type can’t contain a property has more public access level.\nFor example, if a constant, variable, property, or subscript makes use of a private type, the constant, variable, property or subscript must also be marked as private:\nprivate var privateInstance = SomePrivateClass() Getters and Setters It automatically receive the same access level from the constant, variable, property, or subscript that it belongs to.\nAnd the setter and getter can be marked with a lower access level than the access level that get from the upper context. Use fileprivate(set), private(set), and internal(set) to mark a lower access level for the setter.\nstruct Track {  private(set) var number = 0 // the setter can only be used inside the current structure.  var value: String = \u0026#34;\u0026#34; {  didSet {  number += 1  }  } }  var track = Track() track.value = \u0026#34;I \u0026#34; track.value += \u0026#34;read \u0026#34; track.value += \u0026#34;books.\u0026#34; print(\u0026#34;Modify times: \\(track.number)String: \\(track.value)\u0026#34;) // Print: // Modify times: 3 String: I read books. Initializers Custom initializers can be assigned an access level less than or equal to the type that they initialize. However, A required initializer must have the same access level as the class it belongs to.\nThe type of an initializer’s parameters can’t be more private than the initializer’s own access level.\nDefault Initializers A default initializer has the same access level as the type it initializes, unless that type is public. If the type is public, the default initializer will be internal as default.\nfileprivate class Dog {  // It\u0026#39;s default initializer is fileprivate  var name: String? } fileprivate var dog = Dog() public class Cat {  // It\u0026#39;s default initializer\u0026#39;s access level is internal  var name: String? } var cat = Cat() If we want a no-argument initializer (in public type) be used in another module, we must explicitly provide a public no-argument initializer in the type definition. Because the init() will be internal in default.\npublic class Cat { internal  var name: String?  public init() {   } } Default Member-wise Initializers for Structure Type Once the structure’s stored properties are private, the structure type will be considered as private. Likewise, The file-private has the same situation.\nAs with the default initializer above, if the structure is public, the initializer of it is internal in default. So if we want to use the no-argument initializer in other modules, we must write the The public init() implementation explicitly.\nProtocol The requirement in the protocol keep a same access level as the protocol.\nWe can’t set a protocol requirement to a different access level than the protocol it support. This ensures that all of the protocol’s requirement will be visible on any type that adopts the protocol.\nIf we define a public protocol, the protocol’s requirements require a public access level for those requirements when they’re implemented.\nProtocol Inheritance The sub-protocol have at most the same access level as the the super-protocol. For example a public protocol can’t inherit from an internal protocol.\nProtocol Conformance A type can conform a protocol with a lower access level than the type itself.\nFor example, if a type is public, but a protocol it conforms is internal, the type’s conformance to that protocol is also internal. And the type’s implementation of each protocol requirement must be at least internal.\nIf the protocol is with a private, the implementation should be at least file-private.\nprivate protocol Action {  func run()  func eat() }  public class Pig: Action {  // It\u0026#39;s not allowed, it must be declared as file-private because it matches a requirement in private.  private func run() {  print(\u0026#34;run\u0026#34;)  }  // It\u0026#39;s OK to mark it as fileprivate.  fileprivate func eat() {  print(\u0026#34;eat\u0026#34;)  } }  public class Goat: Action {   // It\u0026#39;s internal in default  func run() {   }   // Marked as public explicitly.  public func eat() {   } } Extensions If the extension extends a public or internal type, any new member in the extension will be an internal access level in default.\nIf the extension extends a file-private type, any new member in the extension will be a file-private access level in default.\nAlternatively, we can mark the extension with an access level to let the member inside extension to have new access level.\n// It can only accessed from the same file. fileprivate class Shape {  var width: Int?  var height: Int? }  // It will be can only accessed inside the current context. private extension Shape {  var area: Int {  if let x = width , let y = height {  return x * y  } else {  return 0  }  } } We can’t provide an explicit access-level modifier for an extension if we’re using that extension to add protocol conformance.\n// It\u0026#39;s with internal access level in default.s protocol Calculator {  func calcuArea() -\u0026gt; Int }  fileprivate class Shape {  var width: Int?  var height: Int? }  // Here the extension can\u0026#39;t explicit access-level modifier. extension Shape: Calculator{  func calcuArea() -\u0026gt; Int {  if let x = width , let y = height {  return x * y  } else {  return 0  }  }  } Private Members in Extensions We can:\n Declare a private member in the original declaration, and access that member from extensions in the same file. Declare a private member in one extension, and access that member from another extension in the same file. Declare a private member in an extension, and access that member from the original declaration in the same file.  Example:\nprotocol Printer {  func printLegs() }  struct Cat {  private var leg = 4 } extension Cat: Printer {  func printLegs() {  print(leg)  }  } Generics It will be the minimum of the access level on the type parameter.\nType Aliases A type alias can have an access level less than or equal to the access level of the type it aliases.\n","permalink":"https://1-1.link/post/language/swift/27access-control/","summary":"Access control restrict access to part of the code form code in other source files and modules. It enable us to hide the implement detail of the code, and to specify a preferred interface which that code can be accessed and used.\nSet access levels to individual types (classes, structures, enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types.\nProtocols can be restricted to a certain context, as can global constants, variable, and functions.","title":"Access Control"},{"content":"Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.\nHere we are talking about the situation that happen on a single thread.\nMemory Access var one = 1 // write access to the memory one is stored. print(\u0026#34;\\(one)\u0026#34;) // read access from the memory one is stored. The conflicting access to memory can occur when different part of the code are trying to access the same location in memory at the same time.\nCharacteristics of Memory Access A conflict occurs if two access that meet all of the following conditions:\n At least one is a write access or a nonatomic access. They access the same location in memory. Their duration overlap.  The different between a read and write access is obvious: a write access changes the location in memory, but a read access doesn’t.\nAn operation is atomic if it use only C atomic operation; otherwise it’s nonatomic.\nMost memory access is instantaneous.\nExample: all the read and write accesses in the code below are instantaneous\nfunc addOne(_ number: Int) -\u0026gt; Int {  return number + 1 } var num = 2 num = addOne(num) print(num) The different way to access memory:\n instantaneous access: as the code shown below. long-term access: other code can run after a long-term access but before it ends, which is call overlap. A long-term access can overlap with other long-term accesses and instantaneous access.  The situation that overlap appear:\n in-out parameters in functions. mutating methods of a structure.  Conflicting Access to In-Out Parameters A function has long-term write access to all of its in-out parameters. The write access for an in-out parameter starts after all of the non-in-out parameters have been evaluate and lasts for the entire duration of that function call. The in-out write access start in the same order as the parameter appear.\nLong-term write access to in-out parameter   One consequence\nFor long-term write access, we can’t access the original variable that was passed as in-out, even if scoping rules and access control permit it.\nvar step = 1 func increment(_ number: inout Int) { \t// It want to read step and write number  number += step // Here has a read and write overlap, the number and step refer to the same location in memory.  }  increment(\u0026amp;step) // Error conflicting access to \u0026#34;step\u0026#34; One way to solve the conflict above is to make a copy of step.\nvar copyOfStep = step // Copy from original. increment(\u0026amp;copyOfStep)// Call function with the copy. step = copyOfStep // Update the original.   Another consequence\nPassing a single variable as the argument for multiple in-out parameter of the same function produces a conflict.\nfunc balance(_ x: inout Int, _ y: inout Int) {  let sum = x + y  x = sum / 2  y = sum / 2 } var a = 20 var b = 10  balance(\u0026amp;a, \u0026amp;b) // It\u0026#39;s Ok, there are two write access overlap in time but access different location. balance(\u0026amp;a, \u0026amp;a) // It\u0026#39;s conflict, it pass \u0026#34;a\u0026#34; to the two in-out parameter, there will be two write access overlap in time and memory.   Conflicting Access to self in Methods A mutating method on a structure has write access to self for the duration of the method call.\nfunc balance(_ x: inout Int, _ y: inout Int) {  var sum = x + y  x = sum / 2  y = sum / 2 }  struct Player {  var name: String  var health: Int  var energy: Int  static let maxHealth = 100  mutating func restorehealth() {  health = Player.maxHealth // Here access the \u0026#34;self.health\u0026#34;  }   mutating func shareHealth(with teammate: inout Player) {  balance(\u0026amp;teammate.health, \u0026amp;health)  } }  var oscar = Player(name: \u0026#34;Oscar\u0026#34;, health: 100, energy: 90) var maria = Player(name: \u0026#34;Maria\u0026#34;, health: 60, energy: 90) oscar.shareHealth(with: \u0026amp;maria) // It\u0026#39;s Ok, different write access to different memory.  oscar.shareHealth(with: \u0026amp;oscar) // Error: conflicting accesses to the same memory (the memory that oscar\u0026#39;s health refer to). Conflicting Access to Properties Types like structures, tuples and enumerations are value type, mutating any piece of the value will mutate the whole value, meaning read or write access to one of the properties requires read or write access to the whole value.\nvar holly = Player(name: \u0026#34;Holly\u0026#34;, health: 10, energy: 10) balance(\u0026amp;holly.health, \u0026amp;holly.energy) // Error, \u0026#34;holly\u0026#34; refers to an entire value type, health an energy are two peice of that value,  // the two in-out of the function can\u0026#39;t write accees to the overlap memory. However, if the holly in the above example is changed to a local variable instead of a global variable, it can be safe.\nfunc someFunc() {  var holly = Player(name: \u0026#34;Holly\u0026#34;, health: 10, energy: 10)  balance(\u0026amp;holly.health, \u0026amp;holly.energy) \t// The compiler can prove that memory access is safety because the two stored properties don\u0026#39;t interact in any way. }  someFunc() // It\u0026#39;s OK. The overlapping access to properties of a structure isn’t always necessary to preserve memory safety. Exclusive access is a stricter requirement than memory safety.\nIt can prove that overlapping access to properties of a structure is safe if the following condition apply:\n Accessing only stored properties of an instance, not computed or class properties. The structure is a local variable, not a global variable. The structure is not capture by any closures, or its captured only by non-escaping closures.  If the compiler can’t prove the access is safe, it doesn’t allow the access.\n","permalink":"https://1-1.link/post/language/swift/26memory-safety/","summary":"Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.\nHere we are talking about the situation that happen on a single thread.\nMemory Access var one = 1 // write access to the memory one is stored. print(\u0026#34;\\(one)\u0026#34;) // read access from the memory one is stored.","title":"Memory Safty"},{"content":"Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.\nReference counting applies only to instance of classes.\nReference:\n strong: retain the obj. (default) weak: don’t retain the object referred to, track the object referred to. unowned: don’t retain the object referred to, don’t tract the object referred to.  How ARC Work Allocate a chunk of memory to store information about that instance\n type of the instance values of any stored properties associated with that instance.  To make sure that instance don’t disappear while they’re needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance.\nTo make this possible, whenever assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance. The “strong” reference keeps a firm hold on that instance, and doesn’t allow it to be deallocated for as long as that strong reference remains.\nARC in Action Here we define a class name Person. Then we define three variables of type Person?, they’re automatically initialized with a value of nil, and don’t currently reference a Person instance.\nclass Person {  let name: String  init(name: String) {  self.name = name  print(\u0026#34;Person build: \\(name)\u0026#34;)  }  deinit {  print(\u0026#34;Person deallocated: \\(name)\u0026#34;)  } }  var p1: Person? var p2: Person? var p3: Person? And we can create a new Person instance and assign it one of these three variables.\np1 = Person(name: \u0026#34;Mile\u0026#34;) // Now it starts the initializor, and prints the content. // Print: Person build: Mile We can set other reference to p1\np2 = p1 // The assign of reference don\u0026#39;t call the initializer. p3 = p1  // now there are three strong reference to the single Person instance. If assign other two reference with nil, the instance still has one strong reference (p1), the instance isn’t deallocated.\np1 = nil p2 = nil // The instance isn\u0026#39;t deallocated yet. If the only one last reference is broken, the instance will be deallocated.\np3 = nil // Print: Person deallocated: Mile  // Now the instacne has no reference, and it\u0026#39;s deallocated (When the instance is forgot by all of others, it will leave forever) Resolving Strong Reference Cycle Between Class Instance If two class instance hold a strong reference to each other, it’s called strong reference cycle. The solution of the strong reference cycle is to define the reference as weak or unowned.\nProblem In the function test(), the instance obj has a strong reference of type B, and the instance anotherObj has a strong reference of type A. Normally, after the obj and the anotherObj are assigned as nil, the instance A() and B() built should be recycle when the reference count is zero. But in fact, they are not be recycle (The de-initializer of them haven’t been called). They hold on the reference of each other and can not be deallocated by ARC.\nclass A {  var b: B?  deinit {  print(\u0026#34;Deinit A\u0026#34;)  } } class B {  var a: A?  deinit {  print(\u0026#34;Deinit B\u0026#34;)  } }  var obj: A? = A() var anotherObj: B? = B()  obj!.b = anotherObj anotherObj!.a = obj  obj = nil anotherObj = nil  // Two instance haven\u0026#39;t been deallocated yet. Solution Change the one of the strong reference to be weak reference.\nclass A {  var b: B?  deinit {  print(\u0026#34;Deinit A\u0026#34;)  } } class B {  weak var a: A?  deinit {  print(\u0026#34;Deinit B\u0026#34;)  } }  // So with the code below, the instances of A and B will be deallocated. var obj: A? = A() var anotherObj: B? = B()  obj!.b = anotherObj anotherObj!.a = obj  obj = nil anotherObj = nil  // Print:  // Deinit A // Deinit B Solution with Unowned Reference  Weak references must be typed as Optional; they do not retain the object referred to, but they track the object referred to, and revert to nil if that object goes out of existence. Unowned references do not retain the object referred to and do not track the object referred to, so it\u0026rsquo;s up to you to prevent that object from going out of existence or you may end up with a dangling pointer and a crash.  class A {  var b: B?  deinit {  print(\u0026#34;Deinit A\u0026#34;)  } } class B {  unowned var a: A?  deinit {  print(\u0026#34;Deinit B\u0026#34;)  } } Unowned References and Implicitly Unwrapped Optional Properties class Country {  let name: String  var capitalCity: City!  init(name: String, capitalName: String) {  self.name = name  self.capitalCity = City(name: capitalName, country: self)  } }  class City {  let name: String  unowned let country: Country  init(name: String, country: Country) {  self.name = name  self.country = country  } }  // Now we can access the capital name of the country directly. var country = Country(name: \u0026#34;Canada\u0026#34;, capitalName: \u0026#34;Ottawa\u0026#34;) print(\u0026#34;\\(country.name)capital : \\(country.capitalCity.name)\u0026#34;) // Print: Canada capital : Ottawa Strong Reference Cycles for Closures When assign a closure to a property, we are assigning a reference to that closure. So if we use both strong references, the class instance and a closure will keep each other alive.\nThe more Elegant Solution: Closure Capture List Here the asHTML is a closure property rather than an instance method, we can replace the default value of it with a custom closure.\nclass HTMLElement {  let name: String  let text: String?  \t// Using the lazy, makes the closure can use the \u0026#34;self\u0026#34; \t// The lazy property will not be accessed until   //after initialization has been complete and \u0026#34;self\u0026#34; is konwn.  lazy var asHTML: () -\u0026gt; String = {  if let text = self.text {  return \u0026#34;\u0026lt;\\(self.name)\u0026gt;\\(text)\u0026lt;/\\(self.name)\u0026gt;\u0026#34;  } else {  return \u0026#34;\u0026lt;\\(self.name)/\u0026gt;\u0026#34;  }  }   init(name: String, text: String? = nil) {  self.name = name  self.text = text  }   deinit {  print(\u0026#34;\\(name)is being deinitialized\u0026#34;)  } }  let heading = HTMLElement(name: \u0026#34;h1\u0026#34;) let defaultText = \u0026#34;Some default text\u0026#34;  // Pass a custom closure to set the asHTML property. heading.asHTML = {  return \u0026#34;\u0026lt;\\(heading.name)\u0026gt;\\(heading.text ?? defaultText)\u0026lt;/\\(heading.name)\u0026gt;\u0026#34; }  print(heading.asHTML()) // \u0026lt;h1\u0026gt;Some default text\u0026lt;/h1\u0026gt; Test the strong reference circle.\nvar paragraph: HTMLElement? = HTMLElement(name: \u0026#34;p\u0026#34;, text: \u0026#34;Hello world!\u0026#34;)  print(paragraph!.asHTML())  paragraph = nil // Now the instance that paragraph hasn\u0026#39;t beem deallocated (The meassage of deinit isn\u0026#39;t print),  // because of the strong reference circle between the instance of HTMLElement and the closure . Resolving Strong Reference Cycles for Closures Solution: defining a capture list as part of the closure’s definition. Declare each captured reference to be a weak or unowned reference rather than a strong reference.\nA capture list defines the rules to use when capturing one or more reference types within the closure’s body.\nCapture list definition\nlazy var someClosure = {  [unowned self, weak delegate = self.delegate]  (index: Int, stringToProcess: String) -\u0026gt; String in  // closure body goes here }  // If the closure hasn\u0026#39;t specific parameter lazy var someClosure = {  [unowned self, weak delegate = self.delegate] in  // closure body goes here } Correct the HTMLElement by capture list [unowned self]\nclass HTMLElement {  let name: String  let text: String?  lazy var asHTML: () -\u0026gt; String = {  [unowned self] in  if let text = self.text {  return \u0026#34;\u0026lt;\\(self.name)\u0026gt;\\(text)\u0026lt;/\\(self.name)\u0026gt;\u0026#34;  } else {  return \u0026#34;\u0026lt;\\(self.name)/\u0026gt;\u0026#34;  }  }   init(name: String, text: String? = nil) {  self.name = name  self.text = text  }   deinit {  print(\u0026#34;\\(name)is being deinitialized\u0026#34;)  } }  var paragraph: HTMLElement? = HTMLElement(name: \u0026#34;p\u0026#34;, text: \u0026#34;Hello world!\u0026#34;)  print(paragraph!.asHTML())  paragraph = nil  // Print:  // \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; // p is being deinitialized  // Up to here, now the instance of type HTMLElement is deallocated. The relationship between the HTMLElement and closure is just like the hen and the egg. If they both hold the strong reference, it’s hard to say which one has the priority to destroy the hen. And with the capture list, the HTMLElement (hen) has a strong reference link to the closure, and the closure (egg) just have a unowned reference link to the hen.\n","permalink":"https://1-1.link/post/language/swift/25automatic-reference-counting/","summary":"Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.\nReference counting applies only to instance of classes.\nReference:\n strong: retain the obj. (default) weak: don’t retain the object referred to, track the object referred to. unowned: don’t retain the object referred to, don’t tract the object referred to.  How ARC Work Allocate a chunk of memory to store information about that instance","title":"Automatic Reference Counting"},{"content":"A function with an opaque type hides its return value’s type information. Hiding type information at some boundaries between a module and code that calls into the module. Unlike returning a value whose type is a protocol type, opaque type preserve type identity —the compile has access to the type information, but clients of the module don’t.\nThe Situation Here we have a Shape protocol.\nprotocol Shape {  func draw() -\u0026gt; String } The struct Triangle conform to the Shape. Describe how to draw().\nstruct Triangle: Shape {  var size: Int  func draw() -\u0026gt; String {  var result: [String] = []  for length in 1...size {  result.append(String(repeating: \u0026#34;*\u0026#34;, count: length))  }  return result.joined(separator: \u0026#34;\\n\u0026#34;)  } }  let smallTriangle = Triangle(size: 4) print(smallTriangle.draw()) // Print: // * // ** // *** // **** The struct FlippedShape conform to the Shape and it need an injection in a type of Shape.\nstruct FlippedShape\u0026lt;T: Shape\u0026gt;: Shape{  var shape: T  func draw() -\u0026gt; String {  let lines = shape.draw().split(separator: \u0026#34;\\n\u0026#34;)  return lines.reversed().joined(separator: \u0026#34;\\n\u0026#34;)  } }  let filppingShape = FlippedShape\u0026lt;Triangle\u0026gt;(shape: smallTriangle) print(filppingShape.draw()) // Print: // **** // *** // ** // * The JoinedShape conform to the Shape and it need two injection in type of Shape. It use the generic type T and U.\nstruct JoinedShape\u0026lt;T: Shape, U: Shape\u0026gt;: Shape{  var top: T  var bottom: U  func draw() -\u0026gt; String {  return top.draw() + \u0026#34;\\n\u0026#34; + bottom.draw()  } } let joinedShape = JoinedShape(top: smallTriangle, bottom: filppingShape) print(joinedShape.draw()) // Print: // * // ** // *** // **** // **** // *** // ** // * Returning an Opaque Type The opaque type like being the reverse of a generic type. In generic, the function return a type that depends on its caller:\nfunc max\u0026lt;T\u0026gt;(_ x: T, _ y: T) -\u0026gt; where T: Comparable {...} Use opaque type. It return a some type and don’t exposing the underlying type of that shape. It only focus on the return type, not the specific type.\nstruct Square: Shape {  var size: Int  func draw() -\u0026gt; String {  let line = String(repeating: \u0026#34;*\u0026#34;, count: size)  let result = Array\u0026lt;String\u0026gt;(repeating: line, count: size) count: \u0026lt;#T##Int#\u0026gt;)  return result.joined(separator: \u0026#34;\\n\u0026#34;)  } }  func makeTrapezoid() -\u0026gt; some Shape {  let top = Triangle(size: 2)  let middle = Square(size: 2)  let bottom = FlippedShape(shape: top)  let trapezoid = JoinedShape(top: top, bottom: JoinedShape(top: middle, bottom: bottom))  return trapezoid }  // Here we get a trapezoid, it\u0026#39;s something that conform to the Shape and we can only use it as shape, the client can\u0026#39;t access the underlying information of this shape. let trapezoid = makeTrapezoid() print(trapezoid.draw())  // Print: // * // ** // ** // ** // ** // * Combine Opaque Return Type with Generics. func flip\u0026lt;T: Shape\u0026gt;(_ shape: T) -\u0026gt; some Shape {  return FlippedShape(shape: shape) } func join\u0026lt;T: Shape, U: Shape\u0026gt;(_ top: T, _ bottom: U) -\u0026gt; some Shape {  return JoinedShape(top: top, bottom: bottom) } let opaqueJoinedTriangle = join(smallTriangle, flip(smallTriangle)) print(opaqueJoinedTriangle.draw())  // Print: // * // ** // *** // **** // **** // *** // ** // * All the possible opaque return in a function must have the same type.\n// Here is an example in error   func invalidFlip\u0026lt;T: Shape\u0026gt;(_ shape: T) -\u0026gt; some Shape {  if shape is Square {  return shape  }  return FlippedShape(shape: shape) } One way to avoid return different type is to move this Square case into the FlippedShape implementation.\nstruct FlippedShape\u0026lt;T: Shape\u0026gt;: Shape{  var shape: T  func draw() -\u0026gt; String {  if shape is Square {  return shape.draw()  }   let lines = shape.draw().split(separator: \u0026#34;\\n\u0026#34;)  return lines.reversed().joined(separator: \u0026#34;\\n\u0026#34;)  } } Using generics in an opaque return type.\nfunc repeatObj\u0026lt;T: Shape\u0026gt;(shape: T, count: Int) -\u0026gt; some Collection {  return Array\u0026lt;T\u0026gt;(repeating: shape, count: count) } Differences Between Opaque Types and Protocol Types Using protocol type It can return different type that conform to Shape , it makes a much looser API than opaque return type make.\n// Protocol type func protoFlip\u0026lt;T: Shape\u0026gt;(_ shape: T) -\u0026gt; Shape {  if shape is Square {  return shape  }   return FlippedShape(shape: shape) } The less specific return type information means that the operation that depends on type information aren’t available on the return value.\nlet protoFlipTriangle = protoFlip(smallTriangle) let sameThing = protoFlip(smallTriangle) print(protoFlipTriangle == sameThing) // Error they are \u0026#39;Shape\u0026#39;, \u0026#39;Shape\u0026#39; has no func to check if they are equal, operator \u0026#39;==\u0026#39; cannot be applied to two \u0026#39;Shape\u0026#39;  The opaque types preserve the identity of the underlying type.\nprotocol Container {  associatedtype Item  var count: Int { get }  subscript(i: Int) -\u0026gt; Item { get } }  extension Array: Container {} Here we:\n can’t use Container as the return type of a function. Because the protocol has an associated type. And can’t use it as constraint in a generic return type. Because there isn’t enough information outside the function body to infer what the generic type needs to be.  // Error: Protocol with associated types can\u0026#39;t be used as a return type. func makeProtocolContainer\u0026lt;T\u0026gt;(item: T) -\u0026gt; Container {  return [item] }  // Error: Not enough information to infer C, it has associate type func makeProtocolContainer\u0026lt;T, C: Container\u0026gt;(item: T) -\u0026gt; C {  return [item] } Using the opaque type some Container as a return type. It means that the function return a container, but declines to specify the container’s type.\nfunc makeOpaqueContainer\u0026lt;T\u0026gt;(item: T) -\u0026gt; some Container {  return [item] }  let opaqueContainer = makeOpaqueContainer(item: 12) let twelve = opaqueContainer[0] print(type(of: twelve)) // Int ","permalink":"https://1-1.link/post/language/swift/24opaque-type/","summary":"A function with an opaque type hides its return value’s type information. Hiding type information at some boundaries between a module and code that calls into the module. Unlike returning a value whose type is a protocol type, opaque type preserve type identity —the compile has access to the type information, but clients of the module don’t.\nThe Situation Here we have a Shape protocol.\nprotocol Shape {  func draw() -\u0026gt; String } The struct Triangle conform to the Shape.","title":"Opaque Type"},{"content":"Write code in a more abstract way. It make the code flexible and more reusable.\nArray and Dictionary types are both generic collections.\nThe Problem That Generics Solve If the code with no generics:\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) {  let tmp = a  a = b  b = tmp }  func swapTwoStrings(_ a: inout String, _ b: inout String) {  let tmp = a  a = b  b = tmp }  func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {  let tmp = a  a = b  b = tmp }  // Use the function var aInt = 3, bInt = 4 var aString = \u0026#34;Mike\u0026#34;, bString = \u0026#34;Amy\u0026#34; var aDouble = 1.1, bDouble = 2.5  swapTwoInts(\u0026amp;aInt, \u0026amp;bInt) swapTwoStrings(\u0026amp;aString, \u0026amp;bString) swapTwoDoubles(\u0026amp;aDouble, \u0026amp;bDouble)  print(aInt, bInt) print(aString, bString) print(aDouble, bDouble)  // Print: // 4 3 // Amy Mike // 2.5 1.1 Once the code use generics:\n// The \u0026lt;T\u0026gt; means that this function will use a generic and the type is T. func swapTwoObj\u0026lt;T\u0026gt;(_ a: inout T, _ b: inout T) {  let tmp = a  a = b  b = tmp }  // Use the function var aInt = 3, bInt = 4 var aString = \u0026#34;Mike\u0026#34;, bString = \u0026#34;Amy\u0026#34; var aDouble = 1.1, bDouble = 2.5  swapTwoObj(\u0026amp;aInt, \u0026amp;bInt) swapTwoObj(\u0026amp;aString, \u0026amp;bString) swapTwoObj(\u0026amp;aDouble, \u0026amp;bDouble)  print(aInt, bInt) print(aString, bString) print(aDouble, bDouble)  // Print: // 4 3 // Amy Mike // 2.5 1.1 So the generics can clearly reduce the duplicated code when the code do the similar things.\nType Parameters We can define more than one generic types in the angle brackets.\nfunc swapTwoObj\u0026lt;T, C, D\u0026gt;(_ a: inout T, _ b: inout T, _ c: C, _ d: D) {  let tmp = a  a = b  b = tmp } Generic Types The generics can be applied to classes, structures and enumerations.\nAn example that write a generic stack : First In First Out\nclass Stack\u0026lt;T\u0026gt; {  var store: [T] = []  func push(_ element: T) {  store.append(element)  }   func pop() -\u0026gt; T? {  if store.count \u0026gt; 0 {  var t = store[store.count - 1]  store.remove(at: store.count - 1)  return t  }  return nil  }   func isEmpty() -\u0026gt; Bool {  return store.count \u0026lt;= 0  } }  let stack = Stack\u0026lt;Int\u0026gt;() stack.push(4) stack.push(22) stack.push(6)  while !stack.isEmpty() {  if let e = stack.pop() {  print(e)  } else {  print(\u0026#34;e is nil\u0026#34;)  } }  // Print:  // 6 // 22 // 4 Extending a Genetic Type extension Stack {  var topItem: T? {  return store.isEmpty ? nil : store[store.count - 1]  } } stack.push(5) stack.push(8) if let top = stack.topItem {  print(top) // 8 } Type Constraints Here we constrain the genetic types that they should conform to the specific protocol.\nfunc someFunction\u0026lt;T: SomeClass, U: SomeProtocol\u0026gt;(someT: T, someU: U) {  // function body goes here } Example:\nThe T: Equatable define that the T must conform to the Equatable protocol so that the T can be compared with ==.\nfunc findIndex\u0026lt;T: Equatable\u0026gt; (of target: T, in array: [T]) -\u0026gt; Int? {  for (index, value) in array.enumerated() {  if value == target {  return index  }  }  return nil }  let strings = [\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;llama\u0026#34;, \u0026#34;parakeet\u0026#34;, \u0026#34;terrapin\u0026#34;]  if let foundIndex = findIndex(of: \u0026#34;dog\u0026#34;, in: strings) {  print(\u0026#34;Index: \\(foundIndex)\u0026#34;) }  // Print: // Index: 1 Associated Type The actual type to use for that associated type isn’t specified until the protocol is adopted.\n// The conforming type must provide these three requirements. protocol Container {  associatedtype Item // The actual type will be infered when the append method is implemented.  mutating func append(_ item: Item)  var count: Int { get }  subscript(i: Int) -\u0026gt; Item { get } } The IntStack implementation\nstruct IntStack: Container {  var items: [Int] = []  // It demonstrates the associatedtype.  typealias Item = Int  mutating func push(_ item: Int) {  items.append(item)  }  mutating func pop() -\u0026gt; Int {  return items.removeLast()  }  mutating func append(_ item: Int) {  push(item)  }   var count: Int {  items.count  }   subscript(i: Int) -\u0026gt; Int {  items[i]  }  } The generic stack conform to the container.\nstruct Stack\u0026lt;Element\u0026gt;: Container {  var items: [Element] = []  mutating func push(_ item: Element) {  items.append(item)  }  mutating func pop() -\u0026gt; Element{  return items.removeLast()  }   // It implements the appen(_: ) requirement, Swift can therefore infer that Element is the associatedtype for the contaioner.  mutating func append(_ item: Element) {  push(item)  }  var count: Int {  items.count  }  subscript(i: Int) -\u0026gt; Element {  return items[i]  } } Extending an Existing Type to Specify an Associated Type Swift’s Array type already provides append(_: ), count, subscript. This means that we can extend Array to conform the Container protocol.\nextension Array: Container {} Adding Constraints to an Associated Type protocol Container {  associatedtype Item: Equatable // Here the Item conform to the Equatable is a constraints  mutating func append(_ item: Item)  var count: Int { get }  subscript(i: Int) -\u0026gt; Item { get } } Using a Protocol in its Associated Type’s Constraints Here using the custom protocol SuffixableContainer in its constraints.\nprotocol SuffixableContainer: Container {  // It defines an associatedtype named Suffix and its Item type must be the same as the container\u0026#39;s Item type.  associatedtype Suffix: SuffixableContainer *where* Suffix.Item == Item // Use　the protocol suffixableContainer to constrain the associated type.   func suffix(_ size: Int) -\u0026gt; Suffix }  // The extension  extension Stack: SuffixableContainer {  // It implement the method, and Swift infer that Suffix is Stack.  func suffix(_ size: Int) -\u0026gt; Stack{  var result = Stack()  for index in (count - size)..\u0026lt;count {  result.append(self[index])  }  return result  } }  var stackOfInt = Stack\u0026lt;Int\u0026gt;() stackOfInt.push(3) stackOfInt.push(6) stackOfInt.push(9) let suffix = stackOfInt.suffix(2) print(suffix)  // Print: // Stack\u0026lt;Int\u0026gt;(items: [6, 9]) Generic Where Clauses A generic where clause require that an associated type must conform to a certain protocol, or that the certain type parameters and associated types must be the same.\nfunc allItemMatch\u0026lt;C1: Container, C2: Container\u0026gt;(_ container: C1, _ anotherContainer: C2) -\u0026gt; Bool where C1.Item == C2.Item, C1.Item: Equatable {  // Check if two container\u0026#39;s count equal.  if container.count != anotherContainer.count {  return false  }  // Check each item pairs to see if they are equivalent.  for i in 0..\u0026lt;container.count {  if container[i] != anotherContainer[i] {  return false  }  }   return true } We already extends the array with the code **extension** Array: Container {} before, now both the Stack\u0026lt;String\u0026gt; and Array are conform to the Container, so they can be the parameter for the method allItemMatch.\nvar stackOfStrings = Stack\u0026lt;String\u0026gt;() stackOfStrings.push(\u0026#34;uno\u0026#34;) stackOfStrings.push(\u0026#34;dos\u0026#34;) stackOfStrings.push(\u0026#34;tree\u0026#34;)  var arrayOfStrings = [\u0026#34;uno\u0026#34;, \u0026#34;dos\u0026#34;, \u0026#34;tree\u0026#34;]  // Now C1 is Stack\u0026lt;String\u0026gt; and C2 is Array if allItemMatch(stackOfStrings, arrayOfStrings) {  print(\u0026#34;Matched\u0026#34;) } else {  print(\u0026#34;Not match\u0026#34;) } Extension with a Generic Where Clause It means that the extension have some condition to be valid. If the stack whose elements aren’t equatable and it try to call the isTop(_ :) , it will trigger a compile-time error.\nvar stackOfStrings = Stack\u0026lt;String\u0026gt;() stackOfStrings.push(\u0026#34;uno\u0026#34;) stackOfStrings.push(\u0026#34;dos\u0026#34;) stackOfStrings.push(\u0026#34;tree\u0026#34;)  // The extension only be vaild where the element conform to the Equatable protocol. extension Stack where Element: Equatable {  func isTop(_ item: Element) -\u0026gt; Bool {  guard let topItem = items.last else {  return false  }  return topItem == item  } }  print(stackOfStrings.isTop(\u0026#34;tree\u0026#34;)) We can also use generic where clause with extension to a protocol.\nextension Container where Item: Equatable {  func startWith(_ item: Item) -\u0026gt; Bool {  return count \u0026gt;= 1 \u0026amp;\u0026amp; self[0] == item  } } We can also constrain the extension’s generic type must be a specific type. Only when the condition is satisfied, the extension can be valid.\nextension Container where Item == Double {  func average() -\u0026gt; Double {  var sum = 0.0  for i in 0..\u0026lt;count {  sum += self[i]  }  return sum / Double(count)  }  }  print([11.2, 5.3, 3.2].average()) // 6.566666666666666 Contextual Where Clauses Use the condition to constrain only the method. These method only be available when the condition is satisfied.\nextension Container {  func average() -\u0026gt; Double where Item == Int {  var sum = 0.0  for i in 0..\u0026lt;count {  sum += Double(self[i])  }  return sum / Double(count)  }   func endsWith(_ item: Item) -\u0026gt; Bool where Item: Equatable{  return count \u0026gt;= 1 \u0026amp;\u0026amp; self[count - 1] == item  } } The same behavior implemented in another way. Moving those requirement in different extensions.\nextension Container where Item == Int {  func average() -\u0026gt; Double {  var sum = 0.0  for index in 0..\u0026lt;count {  sum += Double(self[index])  }  return sum / Double(count)  } } extension Container where Item: Equatable {  func endsWith(_ item: Item) -\u0026gt; Bool {  return count \u0026gt;= 1 \u0026amp;\u0026amp; self[count-1] == item  } } Two way to do the where clause above have the same behavior. They activate the specific requirements when the condition is satisfied. However, the contextual where clause only need one extension, and the extensions’ generic where clause will require one extension for per requirement.\nAssociated Type with a Generic Where Clause Here we define the Iterator conform to the IteratorProtocol where the type Iterator.Element is the same as Item.\nprotocol Container {  associatedtype Item  mutating func append(_ item: Item)  var count: Int { get }  subscript(i: Int) -\u0026gt; Item { get }  associatedtype Iterator: IteratorProtocol where Iterator.Element == Item  func makeIterator() -\u0026gt; Iterator } We can add a constraint to an inherited associated type by including the generic where clause in the protocol declaration.\nprotocol ComparableContainer: Container where Item: Comparable {} Generic Subscripts Use the where to constrain.\nextension Container {  subscript\u0026lt;Indices: Sequence\u0026gt;(indices: Indices) -\u0026gt; [Item] where Indices.Iterator.Element == Int{  var result: [Item] = []  for i in indices {  result.append(self[i])  }  return result  } } ","permalink":"https://1-1.link/post/language/swift/23generics/","summary":"Define a class with template type \u003c!-- raw HTML omitted --\u003e, then should illustract the type when use the class.","title":"Generics"},{"content":"A process for querying and calling properties, methods, and subscripts on an optional that might currently be nil .Multiple queries can be chained together, and the chain fails gracefully if any link in the chain is nil .\nOptional Chaining as an Alternative to Forced Unwrapping  ! force unwrapping triggers a runtime error when the optional is nil . Use the optional chaining to check if the optional value querying is succeed.  the chain return optional value is nil , the optional chaining fail. the chain return optional contains a value, the optional chaining succeed.    Force Unwrapping\nclass Person {  var bag: Bag? } class Bag {  var countOfPen = 1 }  var p = Person() print(p.bag!.countOfPen) // It triggers a runtime-error because the \u0026#39;bag\u0026#39; is nil, it\u0026#39;s not graceful. // If the bag has a non-nil value, the code above will succeeds. Optional Chaining. Use the question mark in place of the exclamation point\nif let count = p.bag?.countOfPen {  print(\u0026#34;The count of pen is \\(count).\u0026#34;) } else {  print(\u0026#34;Unable to retrive the count.\u0026#34;) } // Print: Unable to retrive the count. The p.bag?.countOfPen will return a Int? although the countOfPen is Int , it’s a ‘optional chaining’.\n(In this querying chain the bag may be nil, the result of this chain may be nil so the result of the chain should be optional)\nOptional Chaining for Model Classes class Person {  var bag: Bag? } class Bag {  var pens: [Pen] = [] \tsubscript(i: Int) -\u0026gt; Pen {  get {  pens[i]  }  set {  pens[i] = newValue  }  }   var countOfPen: Int {  pens.count  }  var ink: Ink?  } class Pen {  var name: String  init(name: String) {  self.name = name  } }  class Ink {  var weight: Int?  var band: String?  func tellBand() -\u0026gt; String? {  if let band = band, let weight = weight {  return \u0026#34;\\(band): \\(weight)\u0026#34;  } else if band != nil {  return band  } else {  return nil  }  } } Test the optional chaining.\n  The bag is nil and the ink is nil .\nvar p = Person()  if let count = p.bag?.countOfPen {  print(\u0026#34;The count of pen is \\(count).\u0026#34;) } else {  print(\u0026#34;Unable to retrive the count.\u0026#34;) }  if let band = p.bag?.ink?.tellBand() {  print(\u0026#34;Get: \\(band)\u0026#34;) } else {  print(\u0026#34;Unable to retrive the band\u0026#34;) }  // Print: // Unable to retrive the count. // Unable to retrive the band   The bag is non-nil and the ink is non-nil.\nvar p = Person() p.bag = Bag() p.bag?.pens.append(Pen(name: \u0026#34;Moni\u0026#34;))  if let count = p.bag?.countOfPen {  print(\u0026#34;The count of pen is \\(count).\u0026#34;)  p.bag?.ink = Ink()  p.bag?.ink?.band = \u0026#34;Hero\u0026#34;  p.bag?.ink?.weight = 40 } else {  print(\u0026#34;Unable to retrive the count.\u0026#34;) }  if let band = p.bag?.ink?.tellBand() {  print(\u0026#34;Get: \\(band)\u0026#34;) } else {  print(\u0026#34;Unable to retrive the band\u0026#34;) }  // Print: // The count of pen is 1. // Get: Hero: 40   The chain interrupted when face nil.\nfunc createInk() -\u0026gt; Ink {  print(\u0026#34;Create a ink\u0026#34;)  let ink = Ink()  ink.band = \u0026#34;Pi\u0026#34;  return ink }  var p = Person() p.bag?.ink = createInk() // The function isn\u0026#39;t called, because the bag is nil.   Access the property by subscript.\nvar p = Person() p.bag = Bag() p.bag?.pens.append(Pen(name: \u0026#34;Hi\u0026#34;)) p.bag?.pens[0] = Pen(name: \u0026#34;Mi\u0026#34;) print(p.bag?[0].name) // Optional(\u0026#34;Mi\u0026#34;) // It access by subscript(i: Int)   Linking Multiple Levels of Chaining When drill down the property through the optional chain, the result is only one level of optional, no matter how many levels of chaining are used.\nvar band = p.bag?.ink?.tellBand() // If the method is called successfully, the band will just be \u0026#39;String?\u0026#39;  Chaining on Method with Optional Return Values var length = p.bag?.ink?.tellBand()?.count // The length is optional after the assignment. ","permalink":"https://1-1.link/post/language/swift/16optional-chaining/","summary":"A process for querying and calling properties, methods, and subscripts on an optional that might currently be nil .Multiple queries can be chained together, and the chain fails gracefully if any link in the chain is nil .\nOptional Chaining as an Alternative to Forced Unwrapping  ! force unwrapping triggers a runtime error when the optional is nil . Use the optional chaining to check if the optional value querying is succeed.","title":"Optional Chaining"},{"content":"A protocol defines a blueprint of methods, properties.\nCan be Adopted and implemented by:\n class structure enumeration  Syntax Definition\nprotocol SomeProtocol { \tfunc doSomething() } Being Conformed\n  By Struct\nstruct SomeStruct: FirstProtocol, AnotherProtocol {  }   By Class\nclass SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {  }   Conforming Protocol The Dog and People both conform the DoSport protocol, so they have responsibility to implement all things from the protocol.\nprotocol DoSport {  var strength: Int { get set}  static var instanceCount: Int { get}  func walk(distance: Int) }  class Dog: DoSport {  static var instanceCount: Int = 0   func walk(distance: Int) {  print(\u0026#34;Walk \\(distance)with four leg\u0026#34;)  }  var strength: Int  init(strength: Int) {  self.strength = strength  Dog.instanceCount += 1  }  }  class People: DoSport {  static var instanceCount = 0  func walk(distance: Int) {  print(\u0026#34;Walk \\(distance)with two leg\u0026#34;)  }  var strength: Int  init(strength: Int) {  self.strength = strength  People.instanceCount += 1  } }  var d = Dog(strength: 200) d.walk(distance: 4000) var p = People(strength: 1000) p.walk(distance: 1000) Mutating Method Requirements protocol Togglable {  mutating func toggle() } The mutating keyword only used by structures and enumerations.\nInitializer Requirements protocol SomeProtocol {  init(someParameter: Int) } Class Implementation\nThe required modifier ensures that all the subclass of the someClass must conform to the protocol and implement the method.\nclass SomeClass: SomeProtocol {  required init(someParameter: Int) {   } } Subclass Override Initializer and Conform to the Protocol\nprotocol Cuttable {  init(someParameter: Int) }  class Shape {  init(someParameter: Int) {   } } class Square: Shape, Cuttable {  required override init(someParameter: Int) {  super.init(someParameter: someParameter)  } } Failable Initializer Requirements A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type. A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.\nProtocol as Types Using a protocol as type is sometimes called an existential type. So call “A type T conform to the protocol”.\nUse a protocol as a type:\n As a parameter type or return type in a function, method, or initializer As the type of a constant, variable, or property As the type of items in an array, dictionary, or other container  Example:\nUse the RandomNumberGenerator protocol as a type, the parameter that the initializer get should conform to the RandomNumberGenerator .\nprotocol RandomNumberGenerator {  func random() -\u0026gt; Double }  class Dice {  let sides: Int  let generator: RandomNumberGenerator  init(sides: Int, generator: RandomNumberGenerator) {  self.sides = sides  self.generator = generator  }  func roll() -\u0026gt; Int {  return Int(generator.random() * Double(sides)) + 1  } }  class CustomGenerator: RandomNumberGenerator {  func random() -\u0026gt; Double {  return 3.0  } }  // When the CustomGenerator() instance pass to the initialzer, it\u0026#39;s been upcasting. var dice = Dice(sides: 2, generator: CustomGenerator()) // Give it a generator. It\u0026#39;s a way to make generics. print(dice.roll()) // 7 Delegation A class has a delegation in itself and the delegation take the place of class to do other things. The delegation’s input is the class whom want to be delegated.\nExample: A snake and ladder game. The DiceGame is a protocol that require a Dice and a play() method. It’s the fundamental function of a DiceGame .\nThe DiceGameDelegate is a protocol that required some method to do the detail of the game, it defines how the game be played. It rely on the DiceGame . So here is the Delegation.\nThe SnakeAndLadders implements the DiceGame , and implements what to do in the play() method. It has a DiceGameDelegate to do delegate itself to do the detail things.\nclass Generator {  func getNum() -\u0026gt; Int { Int.random(in: 1...6)} }  class Dice {  let sides: Int  var generator: Generator  init(sides: Int, generator: Generator) {  self.sides = sides  self.generator = generator  }  func roll() -\u0026gt; Int {  return generator.getNum()  } } protocol DiceGame {  var dice: Dice{get}  func play() }  protocol DiceGameDelegate: AnyObject {  func gameDidStart(_ game: DiceGame)  func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)  func gameDidEnd(_ game: DiceGame) }  class SnakeAndLadders: DiceGame {  let finalSquare = 25  let dice = Dice(sides: 6, generator: Generator())  var square = 0  var board: [Int]  init() {  board = Array(repeating: 0, count: finalSquare + 1) \t// Some point in the board have extra square buffer.  board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02  board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08  }   weak var delegate: DiceGameDelegate?  func play() {  square = 0  delegate?.gameDidStart(self) \t gameLoop: while square != finalSquare {  let diceRoll = dice.roll()  delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)  switch square + diceRoll {  case finalSquare:  break gameLoop // If the score(square + diceRoll) equal to max, the game end  case let newSquare where newSquare \u0026gt; finalSquare:  continue gameLoop // If the score(square + diceRoll) is greater than max, try again to get a diceRoll.  default:  square += diceRoll // If the score(square + diceRoll) is smaller than max, the game loop go on.  square += board[square]  }  }  delegate?.gameDidEnd(self)  }  }  class DiceGameTracker: DiceGameDelegate {  var numberOfTurn = 0  func gameDidStart(_ game: DiceGame) {  numberOfTurn = 0  if game is SnakeAndLadders {  print(\u0026#34;Start a new game of Snakes and Ladders\u0026#34;)  }  print(\u0026#34;Game use a \\(game.dice.sides)\u0026#34;)  }   func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {  numberOfTurn += 1  print(\u0026#34;Rolled a \\(diceRoll)\u0026#34;)  }   func gameDidEnd(_ game: DiceGame) {  print(\u0026#34;The game lasted for \\(numberOfTurn)turns\u0026#34;)  } }  // The use of game and the delegation. let tracker = DiceGameTracker() // It\u0026#39;s a implementation of the DiceGameDelegate. let game = SnakeAndLadders() // It\u0026#39;s a implementation of the DiceGame. game.delegate = tracker game.play() Adding Protocol Conformance with an Extension We can extend an existing type to adopt and conform to a new protocol, even if we don’t have access to the source code for the existing type.\nprotocol TextOut {  var textDesc: String { get } }  extension Dice: TextOut {  var textDesc: String {  return \u0026#34;It\u0026#39;s a dice with \\(self.sides)sides\u0026#34;  } }  print(game.dice.textDesc) // Print: It\u0026#39;s a dice with 6 sides Conditionally Conforming to a Protocol Condition: Where the element conform the TextOut\nextension Array: TextOut where Element: TextOut {  var textDesc: String {  let itemAsText = self.map{$0.textDesc} // It\u0026#39;s a map \t// Join the map to be a string  return \u0026#34;[\u0026#34; + itemAsText.joined(separator: \u0026#34;,\u0026#34;) + \u0026#34;]\u0026#34;  } }  let d6 = Dice(sides: 12, generator: Generator()) let d12 = Dice(sides: 12, generator: Generator()) let myDice = [d6, d12] print(myDice.textDesc) // [It\u0026#39;s a dice with 12 sides,It\u0026#39;s a dice with 12 sides] Declaring Protocol Adoption with an Extension Use the instance as a protocol. So it’s the protocol oriented programming.\nstruct Hamster {  var name: String  var textDesc: String {  return \u0026#34;A Hamster \\(name)\u0026#34;  } }  extension Hamster: TextOut {}  let h = Hamster(name: \u0026#34;HH\u0026#34;) let p: TextOut = h print(p.textDesc) Adopting a Protocol Using a Synthesized Implementation Swift can automatically provide the protocol conformance for Equatable , Hashable, and Comparable in many simple cases.\nSynthesized implementation of Equatable\n Structures that have only stored properties that conform to the Equatableprotocol Enumerations that have only associated types that conform to the Equatableprotocol Enumerations that have no associated types  Synthesized implementation of Hashable .\n Structures that have only stored properties that conform to the Hashableprotocol Enumerations that have only associated types that conform to the Hashableprotocol Enumerations that have no associated types  Example:\n  Once the structure or enumeration conform the Equatable , it can be compared by ==, and the structure of enumeration needn’t to implement that the protocol required.\nstruct Vector3D: Equatable {  var x = 0.0, y = 0.0, z = 0.0 } let point = Vector3D(x: 2.0, y: 3.0, z: 4.0) let pointAnother = Vector3D(x: 2.0, y: 3.0, z: 4.0)  if point == pointAnother {  print(\u0026#34;Two vectors are equivalent\u0026#34;) }  // Print: Two vectors are equivalent   Comparable\nenum SkillLevel: Comparable {  case beginner  case intermediate  case expert(stars: Int) }  var levels = [SkillLevel.intermediate, SkillLevel.beginner, SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)]  for level in levels.sorted() {  print(level) }  // Print: // beginner // intermediate // expert(stars: 3) // expert(stars: 5)   Collection of Protocol Types A protocol can be used as the type to be stored in a collection such as an array or a dictionary.\nlet things: [TextOut] = [d6, d12, h] for thing in things {  print(thing.textDesc) }  // Print: // It\u0026#39;s a dice with 6 sides // It\u0026#39;s a dice with 12 sides // A Hamster HH Protocol Inheritance A protocol can inherit one or more other protocols.\nprotocol Storeable {  func store() -\u0026gt; String } protocol Readable {  }  protocol Cleanable {  }  protocol BookShelf: Storeable, Readable, Cleanable {  // Here the BookShelf will have the requirement from the protocols. } Class-Only Protocols We can limit protocol adoption to class types by adding the AnyObject protocol to a protocol’s inheritance list. It defines that the conforming type has a reference semantics rather than value semantics.\nprotocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol { } Protocol Composition A type can conform to multiple protocols at the same time. It has the form SomeProtocol \u0026amp; AnotherProtocol .\nProtocol composition don’t define any new protocol types.\nprotocol Named {  var name: String { get } }  protocol Aged {  var age: Int { get} }  struct Person: Named, Aged {  var name: String  var age: Int }  // The type passed to the function must conform to both Named and Aged. func goToSchool(menber: Named \u0026amp; Aged) {  print(\u0026#34;Go to school: \\(menber.name)is \\(menber.age)\u0026#34;) }  let person = Person(name: \u0026#34;Mike\u0026#34;, age: 8) goToSchool(menber: person)  // Print: Go to school: Mike is 8 Combines the Protocol and Class Combines the Named protocol and Location class.\nprotocol Named {  var name: String { get } }  func printInfo(location: Location \u0026amp; Named) {  print(\u0026#34;The place \\(location.name)[\\(location.latitude), \\(location.longitude)] \u0026#34;) }  let place = City(name: \u0026#34;Teochew\u0026#34;, latitude: 23.67, longitude: 116.62) printInfo(location: place)  // Print: The place Teochew [23.67, 116.62] Checking for Protocol Conformance It can do the checking and casting as operation that in type checking and casting.\n  is : check a protocol\n  as : cast a protocol to a specific protocol.\nThe as? is downcast operator, it return an optional value. The as! is force downcast, it can trigger runtime error.\n  // Protocol is used to describe some status. protocol HasArea {  var area: Double { get } } class Circle: HasArea {  let pi = 3.1415927  var radius: Double  var area: Double { return pi * radius * radius}  init(radius: Double) {  self.radius = radius  } }  class Square: HasArea {  var area: Double  init(area: Double) {  self.area = area  } }  class Animal {  var legs: Int  init(legs: Int) {  self.legs = legs  } }  let objs: [Any] = [Circle(radius: 5), Square(area: 20), Animal(legs: 4)]  for obj in objs {  if obj is HasArea {  print(obj, \u0026#34; is HasArea\u0026#34;)  } else {  print(obj, \u0026#34; is not HasArea\u0026#34;)  } }  for obj in objs {  if let object = obj as? HasArea { \t// Here the object is know to be of type HasArea, so it has the only property \u0026#39;area\u0026#39; to access.  print(object, \u0026#34; can be cast to a HasArea. Area is \\(object.area)\u0026#34;)  } else {  print(obj.self, \u0026#34; can\u0026#39;t be cast to a HasArea\u0026#34;)  } }  // Print: // Page_Contents.Circle is HasArea // Page_Contents.Square is HasArea // Page_Contents.Animal is not HasArea // Page_Contents.Circle can be cast to a HasArea Area is 78.5398175 // Page_Contents.Square can be cast to a HasArea Area is 20.0 // Page_Contents.Animal can\u0026#39;t be cast to a HasArea Optional Protocol Requirements Use the @objc to mark the protocol and the requirements. So these requirements don’t have to be implemented by types that conform to the protocol.\n@objc :\n Can be adopted only by classes that inherit from Objective-C class or other @objc classes (Maybe in the new swift version, the class don’t have to inherit the OC class). Can’t be adopted by structures or enumerations. The type used in the optional requirement will automatically be an optional. Such as (Int) -\u0026gt; String becomes ((Int) -\u0026gt; String)? . Here the entire function type is wrapped in the optional, not the method’s return value.  @objc protocol Source {  @objc optional func increment(count: Int) -\u0026gt; Int  @objc optional var anotherIncrement: Int { get } }  class Counter {  var count = 0  var source: Source?  func increment() {  if let amount = source?.increment?(count: count) {  count += amount  } else if let amount = source?.anotherIncrement {  count += amount  }  } }  class ThreeSource: Source {  let anotherIncrement = 3 }  class TowardZeroSource: Source {  func increment(count: Int) -\u0026gt; Int {  if count == 0 {  return 0  } else if count \u0026lt; 0 {  return 1  } else {  return -1  }  } }  let counter = Counter() counter.source = ThreeSource() for i in 1...3 {  counter.increment()  print(counter.count) }  print()  counter.source = TowardZeroSource() for _ in 1...10 {  counter.increment()  print(counter.count) }  print()  counter.count = -5 for _ in 1...8 {  counter.increment()  print(counter.count) }  // Print:  // 3 // 6 // 9 // // 8 // 7 // 6 // 5 // 4 // 3 // 2 // 1 // 0 // 0 // // -4 // -3 // -2 // -1 // 0 // 0 // 0 // 0 The instance of the Counter use different source of the count, so that it has the different effects.\nProtocol Extensions Protocol can be extended to provide method, initializer, subscript, and computed property implementations to conforming types. But can’t make a protocol inherit from another, the inheritance always specified in the protocol declaration itself.\nextension RandomNumberGenerator {  func randomBool() -\u0026gt; Bool {  return Double.random(in: 0...1) \u0026gt; 0.5  } }  let generator = SystemRandomNumberGenerator() print(generator.randomBool()) The code above show that the class SystemRandomNumberGeneraror conform the RandomNumberGenerator protocol and we extend the RandomNumberGenerator protocol with a randomBool() method, so the SystemRandomNumberGeneraror can use the new method easily.\nProviding Default Implementations We can provide method or computed property requirement in the protocol’s extension.\nprotocol HasLeg {  var leg: Int { get}  var desc: String { get } }  extension HasLeg {  var desc: String {  return \u0026#34;I have \\(leg)legs\u0026#34;  } }  class Dog: HasLeg {  var leg: Int  //var desc: String  init() {  leg = 4  } } let dog = Dog() print(dog.desc) // I have 4 legs Adding Constraints to Protocol Extensions Here we constrain the extension of the protocol only add extension when the condition Element: Equatable satisfied.\nextension Collection where Element: Equatable {  func allEqual() -\u0026gt; Bool {  for element in self {  if element != self.first {  return false  }  }  return true  } }  let a = [100, 100, 100, 100] let b = [100, 100, 200, 100]  print(a.allEqual()) print(b.allEqual()) ","permalink":"https://1-1.link/post/language/swift/22protocols/","summary":"A protocol defines a blueprint with methods, properties.","title":"Protocol"},{"content":"Extension add new functionality to an existing class, structure, enumeration, or protocol type.\nExtension in Swift can:\n Add computed instance properties and computed type properties Define instance methods and type methods Provide new initializers Define subscripts Define and use new nested types Make an existing type conform to a protocol  Or even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types.\nExtension Syntax extension SomeType { \t}  extension SomeType: SomeProtocol, AnotherProtocol {  }  If we define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.  Computed Properties Extension can add new computed properties, but can’t add stored properties or add property observers to existing properties.\n// Extend the Swift\u0026#39;s built-in Double type. extension Double {  var km: Double { return self * 1000.0}  var m: Double { return self} \tvar mm: Double {  set {  self = newValue / 1000.0  }  get {  return self / 1000.0  }  } }  let tall = 22.2.km  print(tall) // 22200.0 Initializers Extensions can add new convenience initializers to a class, but can’t add new designated initializers or de-initializers to a class.\nstruct Size {  var width = 0.0, height = 0.0 }  struct Point {  var x = 0.0, y = 0.0 } struct Rect {  var origin = Point()  var size = Size() }  var rectOne = Rect() var rectTwo = Rect(origin: Point(x: 2.0, y: 3.0), size: Size(width: 5.0, height: 4.0))  extension Rect {  init(center: Point, size: Size) {  let x = center.x - (size.width / 2)  let y = center.y - (size.height / 2)  self.init(origin: Point(x: x, y: y), size: size)  } }  var rectThree = Rect(center: Point(x: 3, y: 3), size: Size(width: 4, height: 4)) print(rectThree) Method Extensions can add new instance methods and type methods to existing types.\nextension Int {  func repetitions(task: () -\u0026gt; Void) {  for _ in 0..\u0026lt;self {  task()  }  } }  4.repetitions {  print(\u0026#34;good\u0026#34;) } The method in the extension of the class can modify the instance itself(self). However, if the method in extensions of the structures or enumerations want to modify the self , the method must mark as mutatinfg.\n// The \u0026#39;Int\u0026#39; is structure. extension Int {  mutating func square() {  self = self * self  } }  var res = 3 res.square() print(res) // 9 Subscripts Extension can add new subscripts to an existing type.\nextension Int {  subscript(digitIndex: Int) -\u0026gt; Int {  var decimalBase = 1  for _ in 0..\u0026lt;digitIndex {  decimalBase *= 10  }  return self / decimalBase % 10  } }  var res = 12345[1] print(res) // 4 Nested Types extension Int {  enum Kind {  case negative, zero, positive  }  var kind: Kind {  switch self {  case 0:  return .zero  case let x where x \u0026lt; 0:  return .negative  case let x where x \u0026gt; 0:  return .positive  default:  return .negative  }  } }  var x = -5 print(x.kind) // negative Check kind and responds different situations.\nfunc check(_ nums: [Int]) -\u0026gt; String {  var str = \u0026#34;\u0026#34;  for num in nums {  switch num.kind {  case .zero:  str += \u0026#34;0\u0026#34;  case .negative:  str += \u0026#34;-\u0026#34;  case .positive:  str += \u0026#34;+\u0026#34;  }  }  return str }  print(check([1, 2, 0, -2, 1])) // ++0-+ ","permalink":"https://1-1.link/post/language/swift/21extensions/","summary":"Extension add new functionality to an existing class, structure, enumeration, or protocol type.","title":"Extension"},{"content":"Enumerations, classes or structures can be nested in another type.\nstruct Closh {  enum Size: String{  case H = \u0026#34;high\u0026#34;, M = \u0026#34;Medium\u0026#34;, L = \u0026#34;Low\u0026#34;  }   enum Detail: Int {  case H = 180, M = 170, L = 160  struct Price {  let normal: Int, discount: Int?  }  var price: Price {  switch self {  case .H:  return Price(normal: 100, discount: 90)  case .M:  return Price(normal: 90, discount: 80)  case .L:  return Price(normal: 80, discount: 70)  default:  return Price(normal: self.rawValue, discount: nil)  }  }  }   let size: Size, detail: Detail  var description: String {  return \u0026#34;\\(size.rawValue), PriceNormal: \\(detail.price.normal)PriceDiscount: \\(detail.price.discount)\u0026#34;  } }  var closh = Closh(size: .M, detail: .M) print(closh.description) // Print: Medium, PriceNormal: 90 PriceDiscount: Optional(80) Referring to Nested Types\nvar L = Closh.Size.L.rawValue print(L) // Low ","permalink":"https://1-1.link/post/language/swift/20nested-types/","summary":"Enumerations, classes or structures can be nested in another type.\nstruct Closh {  enum Size: String{  case H = \u0026#34;high\u0026#34;, M = \u0026#34;Medium\u0026#34;, L = \u0026#34;Low\u0026#34;  }   enum Detail: Int {  case H = 180, M = 170, L = 160  struct Price {  let normal: Int, discount: Int?  }  var price: Price {  switch self {  case .","title":"Nested Types"},{"content":"Type casting in Swift is implemented with is and as operators.\nType casting:\n A subclass instance can be use as a superclass instance.  Defining a Class Hierarchy class Media {  var name: String  init(name: String) {  self.name = name  } }  class Song: Media {  var artist: String  init(name: String, artist: String) {  self.artist = artist  super.init(name: name)  } }  class Movie: Media {  var director: String  init(name: String, director: String) {  self.director = director  super.init(name: name)  } }  var library = [  Movie(name: \u0026#34;A\u0026#34;, director: \u0026#34;Michael\u0026#34;),  Song(name: \u0026#34;B\u0026#34;, artist: \u0026#34;Elvis\u0026#34;),  Movie(name: \u0026#34;C\u0026#34;, director: \u0026#34;Orson\u0026#34;),  Song(name: \u0026#34;D\u0026#34;, artist: \u0026#34;Rick\u0026#34;),  Media(name: \u0026#34;E\u0026#34;) ] // The \u0026#34;library\u0026#34; is inferred to be [Media]   for item in library {  print(item.name) // Here the item is of \u0026#34;Media\u0026#34; type  }  // If we want to use the library\u0026#39;s item as the subclass instance, we should downcast the item. Checking Type Use is to check whether an instance is of a certain subclass type.\nfor item in library {  if item is Movie {  print(item.name + \u0026#34; is Movie\u0026#34;)  } else if item is Song {  print(item.name + \u0026#34; is Song\u0026#34;)  } else { \tprint(item.name + \u0026#34; is Media\u0026#34;) \t} } When set the movies and songs to the library, it\u0026rsquo;s the automatically upcast. The upcast is a type of polymorphism.\nDowncasting When we believe that a superclass instance is actually of a subclass type, we can downcast the instance to be a subclass type.\nTwo way to downcast a instance:\n as? get an optional result. (Recommended) as! force downcast, it will trigger runtime error when the types not match.  for item in library {  if let movie = item as? Movie {  print(movie.name + \u0026#34; \u0026#34; + movie.director)  } else if let song = item as? Song {  print(song.name + \u0026#34; \u0026#34; + song.artist)  } }  // Print: // A Michael // B Elvis // C Orson // D Rick // E is just a Media Type Casting for Any and AnyObject  Any can represent an instance of any type at all, including function type, including class type. AnyObjece can represent an instance of any class type.  var things: [Any] = []  things.append(0) var a: Int? = 3 things.append(a as Any) things.append(4.0) things.append(42) things.append(\u0026#34;Oh\u0026#34;) things.append((2.0, 3.5)) things.append(Media(name: \u0026#34;LoL\u0026#34;))  things.append({(name: String) -\u0026gt; String in \u0026#34;Hello, \\(name)\u0026#34;})  for thing in things {  switch thing {  case is Int:  print(\u0026#34;\\(thing)is Int\u0026#34;)  case let someDouble as Double where someDouble \u0026gt; 2:  print(\u0026#34;Double \\(someDouble)is greater than 2\u0026#34;)  case is Double:  print(\u0026#34;\\(thing)is Double\u0026#34;)  case let s as String:  print(\u0026#34;\\(thing)is String\u0026#34;)  case let (x, y) as (Double, Double):  print(\u0026#34;x: \\(x)y: \\(y)\u0026#34;)  case let media as Media:  print(\u0026#34;Media: \\(media.name)\u0026#34;)  case let say as (String) -\u0026gt; String:  print(\u0026#34;Func: \\(say(\u0026#34;John\u0026#34;))\u0026#34;)  default: break   } }  // Print: // 0 is Int // Optional(3) is Int // Double 4.0 is greater than 2 // 42 is Int // Oh is String // x: 2.0 y: 3.5 // Media: LoL // Func: Hello, John If we want to use an optional variable as Any , write as Any , otherwise\nSwift will give us a warning.\nvar a: Int? = 3 things.append(a) // Warning things.append(a as Any) // No warning ","permalink":"https://1-1.link/post/language/swift/19type-casting/","summary":"Type casting in Swift is implemented with is and as operators.\nType casting:\n A subclass instance can be use as a superclass instance.  Defining a Class Hierarchy class Media {  var name: String  init(name: String) {  self.name = name  } }  class Song: Media {  var artist: String  init(name: String, artist: String) {  self.artist = artist  super.init(name: name)  } }  class Movie: Media {  var director: String  init(name: String, director: String) {  self.","title":"Type Casting"},{"content":"Swift has built-in support for writing asynchronous and parallel code in a structured way.\nParallel code means multiple pieces of code run simultaneously.\n Concurrency will make the code harder to debug. Swift can help to catch problem at compile time.  Although it’s possible to write concurrent code without using Swift language support, that code tends to be hard to read.\nlistPhotos(inGallery: \u0026#34;Summer Vacation\u0026#34;) { photoNames in  let sortedNames = photoNames.sorted()  let name = sortedNames[0]  downloadPhoto(named: name) { photo in  show(photo)  } } Keywords:\n async make the function asynchronous. await make function calling synchronous.  Defining and Calling Asynchronous Functions The asynchronous functions or methods can run in another new ‘thread’, but we have no need to create a thread to do that, the Swift manage the asynchronous calling automatically.\nfunc listPhotos(inGallery name: String) async -\u0026gt; [String] {  let result = // ... some asynchronous networking code ...  return result } With the async keyword, the function will be executed in an asynchronous way when it’s been called (the async should be written before throws). The network request takes a relatively long time, so use the we async to let the rest of the app’s code keep running while this code waits for the picture to be ready.\nSuspend Execution by await Use await to make the caller being suspend. Waiting for the return of the function.That code also runs until the next suspension point, marked by await, or until it completes.\nWhile this code’s execution is suspended, some other concurrent code in the same program runs. For example, maybe a long-running background task continues updating a list of new photo galleries.\nlet photoNames = await listPhotos(inGallery: \u0026#34;Summer Vacation\u0026#34;) let sortedNames = photoNames.sorted() let name = sortedNames[0] let photo = await downloadPhoto(named: name) show(photo) The await make the code to be suspend that also called yielding the thread, so behind the scenes, the other code in the same thread will have opportunity to be executed.\nOnly certain place in the program can call asynchronous function or methods:\n Code in the body of an asynchronous function, method, or property. Code in the static main() method of a structure, class, or enumeration that mark with @main . Code in an unstructured child task.  A way to simulate the waiting for network request.\nfunc listPhotos(inGallery name: String) async throws -\u0026gt; [String] {  let result = [\u0026#34;fine\u0026#34;, \u0026#34;aaa\u0026#34;]  try await Task.sleep(nanoseconds: 5 * 10000) // Use the \u0026#39;try await Task.sleep\u0026#39; to simulate   print(\u0026#34;did\u0026#34;)  return result }  func downloadPhoto(names: [String]) async throws {  print(\u0026#34;download\u0026#34;)  try await Task.sleep(4 * 1_000_000) } Asynchronous Sequences Suspend every execution of the elements.\nimport Foundation  let handle = FileHandle.standardInput for try await line in handle.bytes.lines {  print(line) } Calling Asynchronous Functions in Parallel In synchronous way, they are processed one by one.\nlet firstPhoto = await downloadPhoto(named: photoNames[0]) let secondPhoto = await downloadPhoto(named: photoNames[1]) let thirdPhoto = await downloadPhoto(named: photoNames[2]) In asynchronous way, they are processed asynchronously, don’t wait for each mother.\nasync let firstPhoto = downloadPhoto(named: photoNames[0]) async let secondPhoto = downloadPhoto(named: photoNames[1]) async let thirdPhoto = downloadPhoto(named: photoNames[2])  // Async can\u0026#39;t be used for the non-async properties.  Both await and async-let allow other code to run while they’re suspended. The code can use both await and async-let in a same project.  Tasks and Task Groups Structured concurrency  Tasks are arranged in a hierarchy. Each task in a task group has the same parent task, and each task can have child tasks.  await withTaskGroup(of: Data.self) { taskGroup in  let photoNames = await listPhotos(inGallery: \u0026#34;Summer Vacation\u0026#34;)  for name in photoNames {  taskGroup.addTask { await downloadPhoto(named: name) }  } } Unstructured Concurrency Two way to create unstructured task and get a task handle as the result.\n To create an unstructured task that runs on the current actor, call the Task.init(priority: operation:) initializer. To create an unstructured task that’s not part of the current actor, call the Task.d etached(priority:operation:) class method.  let newPhoto = // ... some photo data ... let handle = Task {  return await add(newPhoto, toGalleryNamed: \u0026#34;Spring Adventures\u0026#34;) } let result = await handle.value Task Cancellation Task check can do some responds when the condition is satisfied. It depended on the work we do.\n Throwing error like cancellationError Returning nil or an empty collection Returning the partially completed work  Call Task.checkCancellation() , and it will throws CancellationError if the task has been cancelled. Call Task.isCancelled and handle the cancellation in the code.\nCall Task.cancel() to propagate cancellation manually.\nActors It’s similar to the class. It’s reference type. Allow only one task to access their mutable state at a time.\nWhen a task(A) is interacting with an actor instance, the another task(B) can’t access this actor instance at the same time, and the task B will be suspend and waiting for access the property.\nactor Home{  let label: String  var t: [Int]  private(set) var max: Int = 0  init(label: String, t: Int) {  self.label = label  self.t = [t]  if t \u0026gt; self.max {  self.max = t  }  } }  extension Home{  func update(with temp: Int) {  t.append(temp)  if temp \u0026gt; max {  max = temp  }  } } Use the actor\n@main struct DemoApp {   static func main() async {  var home = Home(label: \u0026#34;Ha\u0026#34;, t: 10)  print(await home.max)  await home.update(with: 22)  print(await home.max)   } } ","permalink":"https://1-1.link/post/language/swift/18concurrency/","summary":"Swift has built-in support for writing asynchronous and parallel code in a structured way.\nParallel code means multiple pieces of code run simultaneously.\n Concurrency will make the code harder to debug. Swift can help to catch problem at compile time.  Although it’s possible to write concurrent code without using Swift language support, that code tends to be hard to read.\nlistPhotos(inGallery: \u0026#34;Summer Vacation\u0026#34;) { photoNames in  let sortedNames = photoNames.","title":"Concurrency"},{"content":"A class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.\nWhen an optional fails, it’s useful to understand what cause the failure, so that the code can respond accordingly.\nExample: Reading a file from the disk may be fail in some way.\n File not exist Have no permission to read. File not being encoded in a compatible format.  Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.\nRepresenting and Throwing Errors We can custom an error enumeration, and conform this enumeration to the Error protocol, so that the custom error can be use as a standard error.\n// Represent enum VendingMachineError: Error {  case invaildSelection  case insufficientFunds(coinsNeeded: Int)  case outOfStack }  struct Item {  var price: Int  var count: Int }  class VendingMachine {  var inventory = [  \u0026#34;Cola\u0026#34;: Item(price: 3, count: 10),  \u0026#34;Cake\u0026#34;: Item(price: 12, count: 11),  \u0026#34;Chips\u0026#34;: Item(price: 8, count: 5)  ]  var coinsDeposited = 0  func vend(name: String) throws {  guard let item = inventory[name] else {  throw VendingMachineError.invaildSelection  }  guard item.price \u0026lt;= coinsDeposited else {  throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)  }  guard item.count \u0026gt;= 0 else {  throw VendingMachineError.outOfStack  }  coinsDeposited -= item.price  inventory[name]?.count -= 1  print(\u0026#34;Dispensings \\(name)\u0026#34;)  } } Testing the error throwing.\nvar machine = VendingMachine()  do {  machine.coinsDeposited = 15  try machine.vend(name: \u0026#34;Cake\u0026#34;)  print(\u0026#34;Vend cake succeed\u0026#34;) // Current coinsDeposited is 6.  try machine.vend(name: \u0026#34;Chips\u0026#34;)  print(\u0026#34;Vend chips succeed\u0026#34;) } catch VendingMachineError.insufficientFunds, VendingMachineError.invaildSelection, VendingMachineError.outOfStack {  print(\u0026#34;Have an error\u0026#34;) }  // Print: // Dispensings Cake // Vend cake succeed // Have an error The do{ try } will be interrupted if the some errors were thrown.\nHandling Errors Four way to handle error.\n Propagate the error to whom call the function.(Pass the error to higher level) Use do-catch statement. Handle the error as an optional value. (try?) Assert that the error will not occur. (try!)  Swift doesn’t involve unwinding the call stack in which can be computationally expensive.\n1. Propagate Error Using Throwing let people = [\u0026#34;Amy\u0026#34;: \u0026#34;Cake\u0026#34;, \u0026#34;Bob\u0026#34;: \u0026#34;Chips\u0026#34;] func buyFavoriteSnack(name: String) throws {  try machine.vend(name: name) } 2. Using Do-Catch do { \ttry something } catch parameter1 {  } catch parameter2 where condition {  } Example\n do {  try machine.vend(name: \u0026#34;cola\u0026#34;) } catch is Error {  // Catch all errors  print(\u0026#34;Transation fail.\u0026#34;) }  do {  try machine.vend(name: \u0026#34;Cake\u0026#34;) } catch VendingMachineError.insufficientFunds {  print(\u0026#34;insufficientFunds\u0026#34;) } catch {  // Catch other errors. } If none of the catch handle the error, the error propagates to the surrounding scope. And finally the error must be handled by the top-level scope, otherwise the error will triggers the runtime error.\nFinally handle the errors.\nfunc buySomething(name: String) throws{  do {  try machine.vend(name: name)  } catch VendingMachineError.outOfStack {  print(\u0026#34;Out of stack\u0026#34;)  } } do {  try buySomething(name: \u0026#34;Cake\u0026#34;) } catch VendingMachineError.invaildSelection {  print(\u0026#34;insufficientFunds\u0026#34;) } catch {  // Catch other errors. Otherwise the other errors will trigger runtime error.  print(\u0026#34;Other\u0026#34;) }  // Print: Other Write in a better form.\nfunc buySomething(name: String) throws{  do {  try machine.vend(name: name)  } catch is VendingMachineError {  print(\u0026#34;Vending Maching have an error.\u0026#34;)  } } 3. Converting Errors to Optional Values Use try? to convert errors to optional value.\nfunc remain(name: String) throws -\u0026gt; Int {   if let item = machine.inventory[name] {  return item.count  } else {  throw VendingMachineError.invaildSelection  } }  var countOfCake = try? remain(name: \u0026#34;Cake\u0026#34;) // Use the \u0026#39;try?\u0026#39; to convert the error into a optional value.  var count: Int? do {  try count = remain(name: \u0026#34;Cake\u0026#34;) } catch is Error {  count = nil }  print(countOfCake)  // The countOfCake is equal to the count. They are all optional. 4. Assert the Error Not Occur try! return a normal type. If the method/init throws an error, it will crash. Because the returned type will be nil and a normal type cannot handle nil.\nDisabling Error Propagation\nUse the try! to disable error propagation and wrap the call in a runtime assertion\nfunc remain(name: String) throws -\u0026gt; Int {   if let item = machine.inventory[name] {  return item.count  } else {  throw VendingMachineError.invaildSelection  } }  let c = try! remain(name: \u0026#34;Cola\u0026#34;)  let e = try! remain(name: \u0026#34;Bread\u0026#34;) // It will raises a runtime error. Avoid using try! in most cases since it will break your program.\nSpecifying Cleanup Action Use a defer statement to execute a set of statements just before code leaves the current block of code.\nA defer statement defers execution until the current scope is exited, and it has a backward sequence to call the statements in the defer block.\nfunc processFile(name: String) throws{  if exists(name) {  let file = open(name)  defer {  close(file) // Executed third  doSomething() // Executed second  stop() // Executed first  }  while let line = try file.readline() {   }   // Here call the stop, doSomething, close  } } ","permalink":"https://1-1.link/post/language/swift/17error-handling/","summary":"A class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.\nWhen an optional fails, it’s useful to understand what cause the failure, so that the code can respond accordingly.\nExample: Reading a file from the disk may be fail in some way.\n File not exist Have no permission to read. File not being encoded in a compatible format.  Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.","title":"Error Handling"},{"content":"A deinitializer is called immediately before a class instance is deallocated.\nWrite with deinit keyword.\nSwift manage the instance memory through automatic reference counting.\nDeinitializer can access all properties of the instance, and do some work to release the handlers (such as close a file).\nClass definition can have at most one deinitializer per class. It doesn’t take any parameters.\n// The function creat a cat and the cat will destory after the function end. class Cat {  init () {  print(\u0026#34;Create\u0026#34;)  }  deinit {  print(\u0026#34;Destory\u0026#34;)  } } func run() {  var cat = Cat() }  run()  // Print: // Create // Destory Deinitializers in Action Here shows a static Bank that own some coins. When create a new player, the player get coins from the Bank. And the player give back the coins to the Bank before the player is deinitialized.\nclass Bank {  static var coins = 10000  static func distribute(coinsRequest: Int) -\u0026gt; Int {  let num = min(coinsRequest, coins) // It can only get at most \u0026#39;coins\u0026#39; count.  coins -= num  return num  }  static func recive(num: Int) {  coins += num  } }  class Player {  var coins: Int  init(coins: Int) {  self.coins = coins  Bank.distribute(coinsRequest: coins)  }  func win(coins: Int) {  self.coins += Bank.distribute(coinsRequest: coins)  }  deinit {  Bank.recive(num: coins)  } } func create() {  var mike = Player(coins: 300)  print(\u0026#34;After init \\(Bank.coins)\u0026#34;)  mike.win(coins: 200)  print(\u0026#34;After win \\(Bank.coins)\u0026#34;) }  create() print(\u0026#34;After deinit \\(Bank.coins)\u0026#34;)  // Print:  // After init 9700 // 9500 // 10000 ","permalink":"https://1-1.link/post/language/swift/15deinitialization/","summary":"Before the object is recycle, the deinitializer solve the post events.","title":"Deinitialization"},{"content":"Initialization is the process of preparing an instance of a class, structure or enumeration for use.\nProperties were set as an initial value.\nInitializers are the implements of the process of initialization.\nThe initializers can be override.\nUnlike Object-C, Swift initialization has no return value.\nInitialization for an Instance Classes and structures must set all of their stored properties to an appropriate initial value when using the initializer. (When assign a default value to a stored property or set its value within an initializer, the property is set directly without calling any property observers)\nclass Cake {  // Set the \u0026#39;size\u0026#39; property with a default value 6 when it\u0026#39;s defined. It doesn\u0026#39;t tirgger any observers.  var size = 6 {  didSet {  print(\u0026#34;Size has been set\u0026#34;)  }  }  var price: Double {  didSet {  print(price)  }  }  \t// Initializer  init () {  price = 0.0  } }  var cake = Cake() // The initializer assign the price as 0.0, it doesn\u0026#39;t trigger any observers. cake.size = 9 // The size\u0026#39;s observer triggered. cake.price = 22 // The price\u0026#39;s observer triggered.  // Print:  // Size has been set // 22.0 Customizing Initialization Define multiple initializer for the class.\nclass Cake {  var size = 6 {  didSet { print(\u0026#34;Size has been set\u0026#34;) }  }  var price: Double {  didSet { print(price) }  }  init () {  price = 0.0  }  init (price: Double) {  self.price = price  }  init (size: Int, price: Double) {  self.size = size // It doesn\u0026#39;t trigger any obserbers.  self.price = price // It doesn\u0026#39;t trigger any obserbers.  } } // Now we create three cakes. They will trigger no observers. var defaultCake = Cake() var cake = Cake(price: 15) var myCake = Cake(size: 7, price: 18) Omit Argument Labels\nclass Cake {  var size = 6  var price: Double  init () {  price = 0.0  }  init (_ price: Double) {  self.price = price  }  init (_ size: Int, _ price: Double) {  self.size = size  self.price = price  } } var defaultCake = Cake() var cake = Cake(15) var myCake = Cake(7, 18)  // The compiler calls the specific initializer by checking parmeters\u0026#39; pattern, such as type and count. Optional Property Types A stored property has “no value”, it will be automatically assigned a default value of nil .\nclass Cake {  var size = 6  var price: Double? // Optional, it will be assigned as nil.  init () {   } } Assigning Constant Properties During Initialization Constant properties\n can be assigned at any point during initialization. Once it’s assigned, we can’t change it any more. can’t be modify by a subclass.  Assign the constant property during initialization.\nclass Cake {  let price: Double = 22  init () {  price = 22  // price = 23 // not allowed  } } Assign the constant property by default value.\nclass Cake {  let price: Double = 22  init () {  // price = 23 // not allowed  } } Default Initializers Swift provide a default initializer for any structure or class that provide default values for all of its properties.\nclass Cake {  let price: Double = 0  var desc: String? // It get nil in default. } var cake = Cake() Member-wise Initializers for Structure Types Unlike a default initializer, the member-wise initializer can assign the arguments to the properties automatically, even if the properties have no default value.\nAn example that the properties without default value.\nstruct Cake {  let price: Double  var desc: String? } var cake = Cake(price: 12) var bigCake = Cake(price: 50, desc: \u0026#34;Big\u0026#34;) Another example that the properties with default.\nstruct Size {  var width = 0.0, height = 0.0 }  var small = Size() var medium = Size(width: 4) var big = Size(width: 10, height: 10) Initializer Delegation for Value Types A initializer can call another initializer to do some work, so to avoid some duplicate code.\nClass type  It has inheritance. The classes has additional responsibility for ensuring that all stored properties they inherit are assigned a suitable value during initialization.  Value Type (structures and enumerations)  Without inheritance, it can only delegate to another initializer that they provide themselves. Use self.init to refer to other initializers from the same type in the custom initializer. Once define a custom initializer for a value type, we will no longer have access to the default initializer or the member-wise initializer. Write the custom initializers in an extension when want to use both default initializer and member-wise initializer.  struct Size {  var width = 0.0, height = 0.0 } struct Point {  var x = 0.0, y = 0.0 } struct Rect {  var origin = Point()  var size = Size()  init() {}  init(origin: Point, size: Size) {  self.origin = origin  self.size = size  }  init(center: Point, size: Size) {  let originX = center.x - (size.width / 2)  let originY = center.y - (size.height / 2)  self.init(origin: Point(x: originX, y: originY), size: size)  } } Class Inheritance and Initialization Swift design designated initializers and convenience initializers to ensure all stored properties receive an initial value.\nDesignated Initializers They are the primary initializer for class. Every class must have at least one designated initializer.\nClasses tend to have very few designated initializers, always have only one.\nIt just like the root of a tree , which initialization takes place, and through which the process continues up the superclass chain.\nSyntax:\ninit( parmeters ) {} Convenience Initializers They are secondary supporting initializers for a class.\nIt can call the designated initializer by self.init() .\nOverride the convenience initializers to provide multiple way to create an instance of the class.\nSyntax:\nconvenience init( parmeters ) {} Initializer Delegation for Class Types Rules for delegation calls between initializers:\n A designated initializer must call a designated initializer from its immediate superclass. A convenience initializer must call another initializer from the same class. A convenience initializer must ultimately call a designated initializer.  Two-Phase Initialization The initialization process:\n First phase: each stored property is assigned an initial value. Second phase: each class is given the opportunity to customize its stored properties. Instance ready to use.  Safety Check (Swift check during compile-time):\n A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegate up to a superclass initializer. A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designate initializer assign will be overwritten by the superclass as part of its own initialization. A convenience initializer must delegate to another initializer before assigning a value to any property. If doesn’t, the new value the convenience initializer assign will be overwritten by it own class’s designated initializer. An initializer can’t call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete.  Process the delegate in the subclass:\n First phase of the initialization. Ensure all properties were initialized. Call superclass’s designated initializer. (Initializer Delegation) Assign values to the inherited properties from the superclass.  The call chain: designated init \u0026lt;- convenience init \u0026lt;- convenience init\nclass Cake {  var size: Int  var price: Int  init() {  size = 6  price = 10  }  convenience init(size: Int) {  self.init()  self.size = size  }  convenience init(size: Int, price: Int) {  self.init(size: size) // Convenience init must call another init before properties assigning. // It will ultimately call designated init.  self.price = price  } } class CheeseCake: Cake {  var cheese: Int \t// If subcalss want to customize designated init, it should use \u0026#39;override\u0026#39; together.  override init(){  self.cheese = 10 // Ensure properties\u0026#39; initialization before delegate up.  super.init() // Delegate up  self.cheese = 15 // Assign to property after the delegate up.  self.size = 7 // Assigning to inherited property must after delegate up.  self.price = 22  } } The class instance isn’t fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.\nPhase 1 Convenience initializer -\u0026gt; \u0026hellip; -\u0026gt; Designated initializer -\u0026gt; superclass’s designated initializer\nInitialize own stored properties, and then go to the superclass’s designated initializer to initialize the inherited properties.\n A designated or convenience initializer is called on a class. Allocate memory for new instance, but is not yet initialized. Designated initializer confirm all stored properties and initialize them. The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties. (run superclass initializer) This continues up to the top the chain (the base class’s initializer) Once reach the top of the chain, the base class has ensure that all of its stored properties have a value, the instance is now fully initialized, phase 1 complete.  Phase 2 superclass’s designated initializer -\u0026gt; designated initializer -\u0026gt; \u0026hellip; -\u0026gt; convenience initializer\nFinish the designated initializer and the called convenience initializers.\n Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access self and can modify its properties and call its instance’s method. Finally, any convenience initializers in the chain have the option to customize the instance and work with self .  Initializer Inheritance and Overriding In common, subclasses don’t inherit superclass’s initializers by default. But only in certain circumstances when it’s safe and appropriate to do so.\nclass CheeseCake: Cake {  var cheese: Int = 10 }  var cake = CheeseCake(size: 7, price:22) When the designate initializer matches the superclass’s initializer, it need override.\nclass CheeseCake: Cake {  var cheese: Int   override init(){  self.cheese = 10  super.init()  self.cheese = 15  self.size = 7  self.price = 22  } } When the designate initializer matches the superclass’s initializer, omit the override , it’s overwrite. The code below show the overwriting of convenience initializer from superclass.\nclass CheeseCake: Cake {  var cheese: Int = 10   convenience init(size: Int, price: Int) {  self.init()  self.size = size  self.price = price  self.cheese = 10  } } The implicitly call of super.init() , it works when the superclass has only one initializer init().\nclass CheeseCake: Cake {  var cheese: Int  init(cheese: Int) {  self.cheese = cheese  // super.init() implicitly called here  } \tconvenience init(size: Int, price: Int) {  self.init(cheese: 15)  self.size = size  self.price = price  } }  var cake = CheeseCake(cheese: 15) Automatic Initializer Inheritance Rule 1\n If the subclass doesn’t define any designated initializers, it automatically inherit all of its superclass designated initializer.  Rule 2\n If subclass provides an implementation of all of its superclass designated initializers(include the rule 1). Then it automatically inherits all of the superclass convenience initializers.  Even if the subclass adds further convenience initializers, these rules work.\nThe code below is an example of rule 1.\nclass CheeseCake: Cake {  var cheese: Int = 1 }  var cake = CheeseCake() // It call the init which inherited from the superclass. The code below is an example of rule 2.\nclass CheeseCake: Cake {  var cheese: Int  override init() {  self.cheese = 10  super.init()  }  init(cheese: Int) {  self.cheese = cheese  }  convenience init(size: Int, price: Int) {  self.init(cheese: 15)  self.size = size  self.price = price  } }  var cake = CheeseCake(size: 7) // The initializer \u0026#39;convenience init(size: Int)\u0026#39; is automactically inherited from the superclass.   A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.\nclass Cake {  var size: Int  var price: Int  init() {  size = 6  price = 10  }  init(size: Int, price: Int) {  self.size = size  self.price = price  }  convenience init(size: Int) {  self.init()  self.size = size  } } class CheeseCake: Cake {  var cheese: Int  override init() {  self.cheese = 10  super.init()  }  init(cheese: Int) {  self.cheese = cheese  super.init()  } \t// Implement superclass designated initializer as a subclass convenience  override convenience init(size: Int, price: Int) {  self.init(cheese: 15)  self.size = size  self.price = price  } }  var cake = CheeseCake(size: 7)   Designated and Convenience Initializers in Action Classes don’t have a default member-wise initializer. (Structure )\nclass Food {  var name: String  init(name: String) {  self.name = name  }  convenience init() {  self.init(name: \u0026#34;default\u0026#34;)  } }  class Pie: Food {  var area: Int  override convenience init(name: String) {  self.init(name: \u0026#34;default\u0026#34;, area: 4)  self.name = name // It must call after the super.init  }  init(name: String, area: Int) {  self.area = area  super.init(name: name)  self.name = name  } }  class ApplePie: Pie {  }  var pie = ApplePie() var applePie = ApplePie(name: \u0026#34;pumpPie\u0026#34;) var bigApplePie = ApplePie(name: \u0026#34;pumpPie\u0026#34;, area: 20)  print(\u0026#34;\\(pie.name): \\(pie.area)\u0026#34;) print(\u0026#34;\\(applePie.name): \\(applePie.area)\u0026#34;) print(\u0026#34;\\(bigApplePie.name): \\(bigApplePie.area)\u0026#34;)   Result:\ndefault: 4 pumpPie: 4 pumpPie: 20\n  Fail-able Initializers Place a question mark after the init keyword(init?).\nwe can‘t define a fail-able and a non-fail-able initializer with the same parameter types and names.\nFail-able initializer\n create an optional value of the type it initializes. write return nil within a fail-able initializer to indicate a point at which can trigger initialization failure. (don’t use return keyword to indicate the initialization success)  Example:\n// Int(exactly: ) let num: Double = 22 let pi = 3.1415 if let value = Int(exactly: num) {  print(\u0026#34;\\(num)\\(value)\u0026#34;) } else {  print(\u0026#34;conversion fail\u0026#34;) } // Print: 22.0 22  // The value not match the type int let num: Double = 22.1 let pi = 3.1415 if let value = Int(exactly: num) {  print(\u0026#34;\\(num)\\(value)\u0026#34;) } else {  print(\u0026#34;conversion fail\u0026#34;) } // Print: conversion fail Use a fail-able initializer init a structure and check if the initialization succeeded.\nstruct Animal {  let species: String  init?(species: String) {  if species.isEmpty { return nil}  self.species = species  } } let creature = Animal(species: \u0026#34;Giraffe\u0026#34;)  if let giraffe = creature {  print(\u0026#34;The giraffe init succeeded\u0026#34;) } else {  print(\u0026#34;The giraffe init fail\u0026#34;) } // Print: The giraffe init succeeded  let cat = Animal(species: \u0026#34;\u0026#34;) if let c = cat {  print(\u0026#34;cat inited successful\u0026#34;) } else {  print(\u0026#34;cat init fail\u0026#34;) } // Print: cat init fail  // The empty string has a length of 0, but it\u0026#39;s not a nil.  Fail-able Initializer for Enumerations If the given state is not found in the cases, return nil .\nenum Rank {  case low, midium, high  init?(rank: String) {  switch rank {  case \u0026#34;L\u0026#34;:  self = .low  case \u0026#34;M\u0026#34;:  self = .midium  case \u0026#34;H\u0026#34;:  self = .high  default:  return nil  }  } }  var rank = Rank(rank: \u0026#34;H\u0026#34;) print(rank) // Optional(Page_Contents.Rank.high) var r = Rank(rank: \u0026#34;C\u0026#34;) print(r) // nil Use in rawValue\nenum Rank: String {  case low = \u0026#34;L\u0026#34;, midium = \u0026#34;M\u0026#34;, high = \u0026#34;H\u0026#34;  }  var rank = Rank(rawValue: \u0026#34;H\u0026#34;) print(rank) // Optional(Page_Contents.Rank.high) var r = Rank(rawValue: \u0026#34;C\u0026#34;) print(r) // nil Propagation of Initialization Failure  A fail-able initializer of a class, structure, or enumeration can delegate across to another fail-able initializer from the same class, structure, or enumeration. A subclass fail-able initializer can delegate up to a superclass fail-able initializer. A fail-able initializer can delegate to a non-fail-able initializer.  If delegate to another initializer that cause initialization fail, the entire initialization process fails immediately, and no further initialization code is executed.\nHere is an example that the subclass fail-able initializer delegate to the superclass fail-able initializer:\nclass Product {  let name: String  init?(name: String) {  if name.isEmpty {  print(\u0026#34;Name empty, super class init fail\u0026#34;)  return nil  }  self.name = name  } } class CartItem: Product {  let quantity: Int  init?(name: String, quantity: Int) {  if quantity \u0026lt; 1 {  print(\u0026#34;No Quantity, subclass init fail\u0026#34;)  return nil  }  self.quantity = quantity  super.init(name: name)  } }  var itemNoName = CartItem(name: \u0026#34;\u0026#34;, quantity: 2) var itemNoQuantity = CartItem(name: \u0026#34;Apple\u0026#34;, quantity: 0) var item = CartItem(name:\u0026#34;Pen\u0026#34;, quantity: 3) print(itemNoName) print(itemNoQuantity) print(item)  // Print: // Name empty, super class init fail // No Quantity, subclass init fail // nil // nil // Optional(Page_Contents.CartItem) Overriding a Fail-able Initializer  Override a superclass fail-able initializer in a subclass. Override a superclass fail-able initializer with a subclass non-fail-able initializer. The only way to delegate up to the fail-able initializer is to force-unwrap the result of the fail-able initializer. Can’t override a non-fail-able initializer with a fail-able initializer.  class Doc {  var name: String?  init() {}  init?(name: String) {  if name.isEmpty { return nil}  self.name = name  } \tconvenience init(size: Int, name: String) {  self.init(name: name)! // Delegate up to the fail-able initializer as part of the implementation.  \t// If the name is empty, it will trigger runtime-error.  } }  class FileDoc: Doc {  override init() {  super.init()  self.name = \u0026#34;[Untilted]\u0026#34;  } \t// Override the superclass fail-able initializer with a subclass non-fail-able initializer.  override init(name: String) {  super.init()  if name.isEmpty {  self.name = \u0026#34;[Untitled]\u0026#34;  } else {  self.name = name  }  } } Use forced unwrapping in an initializer to call a fail-able initializer from the superclass as part of the implement of a subclass’s non-fail-able initializer.\nclass FileDoc: Doc {  override init() {  super.init(name: \u0026#34;[Untitled]\u0026#34;)!  } }  class MessageDoc: Doc {  var size: Int  init(size: Int) {  self.size = size  super.init(name: \u0026#34;[Untitled]\u0026#34;)!  } } init! Fail-able Initializer The init! will implicitly unwrapped the optional result.\nclass Doc {  var name: String?  init() {}  init!(name: String) {  if name.isEmpty { return nil}  self.name = name  } }  class FileDoc: Doc {  override init() {  super.init(name: \u0026#34;[Untitled]\u0026#34;)  } } Required Initializers Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer.\nDon’t write the override keyword.\nclass Animal {  required init() {  print(\u0026#34;Fine\u0026#34;)  } }  class Cat: Animal {  required init() {  print(\u0026#34;Cat\u0026#34;)  } } var cat = Cat()  // Print: // Cat // Fine Setting a Default Property Value with a Closure or Function The closure init before the initializer, so we can’t use self within the closure.\nWith parentheses, the closure’s return value (or result) will be assign to the property.\nclass Cake {  var name: String = {  print(\u0026#34;fine\u0026#34;)  return \u0026#34;cake\u0026#34;  }() \t// The parentheses after the closure means that it\u0026#39;s a calling. The closure executed immediately. }  var cake = Cake() // Print: fine print(cake.name) // Print: cake Without parentheses, the closure itself is to assign to the property.\nclass Cake {  var name: () -\u0026gt; String = {  print(\u0026#34;fine\u0026#34;)  return \u0026#34;cake\u0026#34;  } }  var cake = Cake() // Hasn\u0026#39;t called the closure print(cake.name) // Print: (Function) cake.name() Example:\nclass ChessBoard {  var boardColors: [Bool] = {  var isBlack = false  var board: [Bool] = []  for i in 1...8 {  for j in 1...8 {  board.append(isBlack)  isBlack = !isBlack  }  }  return board  }()   func getIsBlack(row: Int, col: Int) -\u0026gt; Bool {  return boardColors[(row * 8) + col]  }  }  var b = ChessBoard() print(b.getIsBlack(row: 2, col: 3)) // Print: true print(b.getIsBlack(row: 4, col: 4)) // Print: false ","permalink":"https://1-1.link/post/language/swift/14initialization/","summary":"The class\u0026rsquo;s initializer set the original state for the object.","title":"Initialization"},{"content":"Class A inherit from class B. Then A is the so call subclass, B is the superclass.\nSubclass can do:\n Access methods, properties, and subscripts belonging to their superclass, Override the methods, properties and subscripts. Extends the functionality of the superclass.  Superclass can do:\n Add property observer to inherited properties. (In order to be notified when the value of property changes)  Usage class Card {  var number: Int?  func changeNumber(number: Int) -\u0026gt; Bool {  self.number = number  return true  } }  // Inherit from Card class StudentCard: Card {  var studentID: Int? }  // Inherit from Card class BankCard: Card {  var account = 0 }  var studentCard = StudentCard() studentCard.number = 123 studentCard.studentID = 220022 print(studentCard.number!) print(studentCard.studentID!)  var bankCard = BankCard() bankCard.changeNumber(number: 124) bankCard.account = 100 print(bankCard.number!) print(bankCard.account) Overriding A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass.\nAccessing Superclass Methods, Properties, and Subscripts Use the super keyword to access the things belong to the superclass.\nOverriding the initialization.\nclass Card {  var number: Int?  var initFee = 0  init(number: Int){  self.number = number  } }  class StudentCard: Card {  var studentID: Int?   // Override the initialization from the superclass  override init(number: Int) {  super.init(number: number) // It need to init the superclass at first, the \u0026#39;super\u0026#39; can\u0026#39;t be omitted here.  super.initFee = 15 // The \u0026#39;super\u0026#39; can be omitted here.   }  }  var studentCard = StudentCard(number: 123)  print(studentCard.initFee) // 15 Overriding Methods class Card {  var number: Int?  var initFee = 0  func setInitFee(fee: Int) {  self.initFee = fee  }  init(number: Int){  self.number = number  } }  class StudentCard: Card {  var studentID: Int?   override func setInitFee(fee: Int) {  super.initFee = fee + 5  } }  var studentCard = StudentCard(number: 123) studentCard.setInitFee(fee: 5) print(studentCard.initFee) // 10 Overriding Properties Regardless of whether the property is stored or computed, override an inherited instance or type property to provide custom getter and setter, or to add property observer for the property.\nThe subclass doesn’t know whether the inherited property is stored or computed.(So must state both the name and the type of the property when override it)\nRead-Write and Read-Only:\n We can override a read-only property to be read-write, by providing getter and setter. We can’t override a read-write property to be read-only. When override the a setter, must override the getter at the same time. Return super.someProperty simply when override getter only.  The code below show how to override a property from superclass.\nclass Card {  var number: Int?  var _desc: String = \u0026#34;\u0026#34; // The setter can\u0026#39;t set to itself, so use \u0026#39;_desc\u0026#39; to store the value.  var desc: String {  get {  return _desc + \u0026#34;Has a number \\(number!). \u0026#34;  }  } }  class StudentCard: Card {  var initFee = 0  override var desc: String {  get { return super.desc + \u0026#34; With a initFee \\(initFee)\u0026#34;}  set {  _desc = \u0026#34;[\u0026#34; + newValue + \u0026#34;]\u0026#34;  }  } }  var studentCard = StudentCard() studentCard.number = 1234 studentCard.initFee = 15 studentCard.desc = \u0026#34;A student\u0026#34;  print(studentCard.desc) // Print: [A student]Has a number 1234. With a initFee 15 Overriding Property Observers  can’t add property observers to inherited constant stored properties or inherited read-only computed properties. can’t provide both overriding setter and overriding property observer for the same property.  The code below show the VipStudentCard inherit from the StudentCard and add an observer to the desc.\nclass Card {  var number: Int?  var _desc: String = \u0026#34;\u0026#34;  var desc: String {  get {  return _desc + \u0026#34;Has a number \\(number!). \u0026#34;  }  } }  class StudentCard: Card {  var initFee = 0  override var desc: String {  get { return super.desc + \u0026#34; With a initFee \\(initFee)\u0026#34;}  set {  _desc = \u0026#34;[\u0026#34; + newValue + \u0026#34;]\u0026#34;  }  } }  class VipStudentCard: StudentCard {  override var desc: String {  didSet {  initFee += 5  } \t } }  var vip = VipStudentCard() vip.number = 12345 vip.initFee = 15 vip.desc = \u0026#34;Vip\u0026#34; print(vip.desc) // Print: [Vip]Has a number 12345. With a initFee 20 Or simply observe any value changes from within the custom setter for the desc in the VipStudentCard .\nclass Card {  var number: Int?  var _desc: String = \u0026#34;\u0026#34;  var desc: String {  get {  return _desc + \u0026#34;Has a number \\(number!). \u0026#34;  }  } }  class StudentCard: Card {  var initFee = 0  override var desc: String {  get { return super.desc + \u0026#34; With a initFee \\(initFee)\u0026#34;}  set {  _desc = \u0026#34;[\u0026#34; + newValue + \u0026#34;]\u0026#34;  }  } }  class VipStudentCard: StudentCard {  override var desc: String {  set{  _desc = \u0026#34;{\u0026#34; + newValue + \u0026#34;}\u0026#34;  initFee += 5  }  get {  return super.desc  }   } }  var vip = VipStudentCard() vip.number = 12345 // The number property is from the base class \u0026#39;Card\u0026#39; vip.initFee = 15 // The initFee vip.desc = \u0026#34;Vip\u0026#34; print(vip.desc) // Print: {Vip}Has a number 12345. With a initFee 20 Preventing Overrides We can prevent the method, property, or subscript from being overridden by marking it with final keyword.\nclass Card {  var number: Int?  var _desc: String = \u0026#34;\u0026#34; \t// Here the desc can\u0026#39;t be overridden, because it\u0026#39;s final.  final var desc: String {  get {  return _desc + \u0026#34;Has a number \\(number!). \u0026#34;  }  set {  _desc = \u0026#34;|\u0026#34; + newValue + \u0026#34;|\u0026#34;  }  } }  class StudentCard: Card {  var initFee = 0  }  class VipStudentCard: StudentCard { }  var vip = VipStudentCard() vip.number = 12345 vip.initFee = 15 vip.desc = \u0026#34;Vip\u0026#34; print(vip.desc) // Print: |Vip|Has a number 12345. If we mark the entire class as final, it can’t be inherited.\nfinal class Card {  var number: Int?  var _desc: String = \u0026#34;\u0026#34;  var desc: String {  get {  return _desc + \u0026#34;Has a number \\(number!). \u0026#34;  }  set {  _desc = \u0026#34;|\u0026#34; + newValue + \u0026#34;|\u0026#34;  }  } }  // class StudentCard: Card {} // Compile-time error. ","permalink":"https://1-1.link/post/language/swift/13inheritance/","summary":"A class inherit another class call super class, and get some ability from super class.","title":"Inheritance"},{"content":"Method Methods are functions that associated with a particular type.\nClasses, structures and enumerations.\n Define instance methods for an instance of the given type. Define type method for the type itself.  Instance Method It is defined in a type. And it can only be called by a specific instance of the type.\nclass Bird {  var energy = 10  \t// Instance method  func sing() {  energy -= 1  }  \t// Instance method  func eatFood(food: Int) {  self.energy += food // self is current instance of the type, it\u0026#39;s the instance who call the current method.  } \t\tfunc setEnergy(energy: Int) {  self.energy = energy // Here must use the \u0026#39;self\u0026#39; to distinguish the property of the instance and the method\u0026#39;s parameter.  } }  var keo = Bird() keo.eatFood(food: 4) print(keo.energy) // 14 keo.sing() print(keo.energy) // 13 Modifying Value Types in the Instance Method Structures and Enumerations are value type, their properties can’t be modified by default.\nHowever, we can use the mutating keyword to enable the method to modify their properties.\nstruct Point {  var x = 0  var y = 0   mutating func moveTo(x: Int, y: Int) {  self.x = x  self.y = y  } }  // Assigning to self Within a Mutating Method, it has the same result as the code above.  struct Point {  var x = 0  var y = 0   mutating func moveTo(x: Int, y: Int) {  self = Point(x: x, y: y)  } }  enum Level {  case off, low, high  mutating func next() {  switch self {  case .off:  self = .low  case .low:  self = .high  case .high:  self = .off  }  } } Type Method  Defined in the type, called by the type. Can be used in classes, structures, enumerations.  Use the static keyword to indicate the function is the type method.\nstruct Boy {  static var count = 0  static func add() {  count += 1  } }  var boy = Boy() Boy.add() var boyB = Boy() Boy.add() print(Boy.count) // 2 Classes can use the class key word instead of the static to allow the subclass to override the method. (Just like a protected keyword in Java)\nclass Shape {  static var count = 0  class func add() {  self.count += 1 // Here the \u0026#39;self\u0026#39; is the type Shape itself, not a instance of type.  } } Example: The player class create a new instance of LevelTracker to track that player’s progress.\nstruct LevelTracker {  static var highestUnlockedLevel = 0  var currentLevel = 0   static func unlock(_ level: Int) {  if level \u0026gt; highestUnlockedLevel {  highestUnlockedLevel = level  }  }   static func isUnlocked(_ level: Int) -\u0026gt; Bool {  return level \u0026lt;= highestUnlockedLevel  }   @discardableResult  mutating func advance(to level: Int) -\u0026gt; Bool {  if LevelTracker.isUnlocked(level) {  currentLevel = level  return true  } else {  return false  }  } }  class Player {  var tracker = LevelTracker()  let playerName: String  func complete(level: Int) {  LevelTracker.unlock(level + 1) // Unlock the next level for all players.  tracker.advance(to: level + 1) // Update current player\u0026#39;s progress to next level.  }   init(name: String) {  playerName = name  } }  var player = Player(name: \u0026#34;Mike\u0026#34;)  player.complete(level: 0) print(player.tracker.currentLevel) // 1 print(LevelTracker.highestUnlockLecel) // 1 ","permalink":"https://1-1.link/post/language/swift/11method/","summary":"The object have some method to provide functionality.","title":"Method"},{"content":"  Stored properties\nOnly provided by classed and structures.\n  Computed properties\nProvide by classes, structures, enumerations.\n  Usually associated with instance of a particular type, can be associated with the type itself(type properties).\nCan define property observers to monitor changes in a property’s value, which can respond to with custom action.\nCan use a property wrapper to reuse code in the getter and setter.\nStored Properties **struct Setting {  var width: Int  let height: Int } var appSetting = Setting(width: 100, height: 200) appSetting.width = 150  let constSetting = Setting(width: 110, height: 210) //constSetting.width = 120 // This will trigger a compile-time error, the struct is of const value type.** Lazy Stored Properties Its initial value isn’t calculated until the first time it’s used.\nLazy stored properties must be a variable, it will be assigned at the first time it’s used.\nConstants can’t be lazy, because it always have a value before initialization completes.\nclass DataImporter {  var fileName = \u0026#34;data.txt\u0026#34;  func readFromFile(path: String) -\u0026gt; String {  return \u0026#34;some \u0026#34; + path  } } class DataManager {  lazy var importer = DataImporter()  var data: [String] = [] } let manager = DataManager() manager.data.append(\u0026#34;Happy\u0026#34;) manager.data.append(\u0026#34;Time\u0026#34;) // Here the manager.importer has not yet been created.  var str = manager.importer.readFromFile(path: manager.data[0]) // Here the manager.importer is created, and then call the function of the manager.importer  print(str) // Print: 「some Happy」  If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property hasn’t yet been initialized, there’s no guarantee that the property will be initialized only once.  Stored Properties and Instance Variable In Objective-C or C++, the definition and initialization of an instance variable are separated in different places.\nSwift cancels the instance variable rules, and use a simple way to declare the propertied of an instance, define the name, type, memory management characteristics in a single location.\nComputed Properties In classes, structures, and enumerations, we provide a getter and setter to retrieve and set properties and values indirectly.\nUsing computed properties, we can compute something else of the class’s from the other properties.\nstruct Bag {  var bookCount: Int = 0  var penCount: Int = 0  var objectCount: Int {  get {  return bookCount + penCount  }  set (count) {  bookCount = Int(Double(count) * 0.8)  penCount = Int(Double(count) * 0.2)  }  } }  var bag = Bag(bookCount: 1, penCount: 2)  print(bag.objectCount) // Here use the getter. Print 「3」  bag.objectCount = 10 // Here use the setter. The temporary parameter \u0026#39;count\u0026#39; is assignes to 10.  print(bag.objectCount) // 10 print(bag.bookCount) // 8 print(bag.penCount) // 2 The setter has a shorter form of declaration. It must use the newValue to grab the temporary parameter.\nset {  bookCount = Int(Double(newValue) * 0.8)  penCount = Int(Double(newValue) * 0.2)  } The getter has a shorter form of declaration. It write the code with one line and as the return expression.\nget { \tbookCount + penCount } Read-Only Computed Properties struct Bag {  var bookCount: Int = 0  var penCount: Int = 0  var objectCount: Int {  get {  bookCount + penCount  }  } } Read-Only in a shorter form:\nstruct Bag {  var bookCount: Int = 0  var penCount: Int = 0  var objectCount: Int {  return bookCount + penCount  } } Omit the return\nstruct Bag {  var bookCount: Int = 0  var penCount: Int = 0  var objectCount: Int {  bookCount + penCount  } } The read-only computed properties are useful for an external user to discover the Bag ’s current status.\nProperty Observers The observer can observe and respond to changes in a property’s value.\nThe observer can’t be provide together with getter or setter.\nOnly can add property in these places:\n  Stored properties that we define.\n  Stored properties that we inherit.\nFor an inherit property, add a property observer by overriding that property in a subclass.\n  Computed properties that we inherit.\nUse property’s setter to observe and responds to value changes, instead of creating an observer.\n  Define either or both of these observers on a property.\n willSet is called before the value is stored. (pass the new property value as a constant, it has a default name of newValue) disSet is called immediately after the new value is stored.(pass the last old property value as a constant, it has a default name of oldValue)  struct Bag {  var bookCount: Int = 0  var penCount: Int = 0  var objectCount: Int {  willSet (newCount) {  print(\u0026#34;Will set the count \\(newCount)\u0026#34;) // 2  }  didSet {  print(\u0026#34;Has set the count, the olValue is \\(oldValue), and add \\(objectCount - oldValue)\u0026#34;) // 0 2  }  } } var bag = Bag(objectCount: 0)  bag.objectCount = 2 // Here trigger the wiilSet and then trigger the didSet. The newValue is 2, and the oldValue is 0. print(\u0026#34;After change, objectCount: \\(bag.objectCount)\u0026#34;) // 2 The observer in the superclass can observe the properties’ action in the subclass.\n The subclass set the superclass’s property after the superclass’s initializer has been called. If the superclass’s initializer hasn’t been called, the observer can not work.  Property Wrappers It can wrap the data and the code together as a code block. Using property wrapper can reduce the repeated codes.\nHere is an example that store a number less than 12 or equals to 12. The wrappedValue must used explicitly.\n@propertyWrapper struct Num {  private var number = 0  var wrappedValue: Int {  get {return number}  set {number = min(newValue, 12)}  } } Using\nstruct Rectangle {  @Num var width: Int // It declares that the var use the rule of the propertyWrapper  @Num var height: Int }  var rect = Rectangle()  print(rect.width) // Call the \u0026#39;get\u0026#39; function  rect.height = 10 // Call the \u0026#39;set\u0026#39; function Another way to use the propertyWrapper\nstruct Rectangle {  private var _height = Num()  private var _width = Num()  var height: Int {  get{ return _height.wrappedValue }  set{ _height.wrappedValue = newValue}  }  var width: Int {  get{ return _width.wrappedValue}  set{ _width.wrappedValue = newValue}  } } Setting Initial Values for Wrapped Properties In default, use the wrppedValue to catch the input implicitly.\nOverride the initial function so to provide several ways to to init a Num .\n@propertyWrapper struct Num {  private var maximum: Int  private var number: Int  var wrappedValue: Int {  get { return number}  set { number = min(newValue, maximum)}  }  init() {  maximum = 12  number = 0  }  init(wrappedValue: Int) {  maximum = 12  number = wrappedValue  }  init(wrappedValue: Int, maximum: Int) {  self.maximum = maximum  number = wrappedValue  } } The initialization without parameter.\nstruct ZeroRectangle {  @Num var width: Int  @Num var height: Int } var zeroRect = ZeroRectangle() The initialization with one default parameter wrappedValue .\nstruct UnitRectangle {  @Num var width: Int = 1 // It call the init  @Num var height: Int = 1 }  var unitRect = UnitRectangle()  // Or in this way  struct UnitRectangle {  @Num(wrappedValue: 1) var width: Int  @Num(wrappedValue: 1) var height: Int }  var unitRect = UnitRectangle() The initialization with two parameters.\nstruct NarrowRectangle {  @Num(wrappedValue: 2, maximum: 5) var width: Int  @Num(wrappedValue: 3, maximum: 4) var height: Int }  var narrowRect = NarrowRectangle()  // Or in this way  struct NarrowRectangle {  @Num(wrappedValue: 2, maximum: 5) var width: Int  @Num(maximum: 4) var height: Int = 3 }  var narrowRect = NarrowRectangle() The default parameter wrappedValue is used to pass input implicitly.\nProject a Value From a Property Wrapper Declare the var name projectedValue in a property wrapper.\nIt can store some information such as track the change of the property, and then the outside caller can get the information from the projectedValue. It can be accessed via the dollar sign $ , when the outside caller has the permission to access.\nstruct Num {  private var number: Int  private(set) var projectedValue: Bool // The projectedValue\u0026#39;s set function is declare as private.  var wrappedValue: Int {  get { return number}  set {  if newValue \u0026gt; 12 {  number = 12  projectedValue = true  } else {  number = newValue  projectedValue = false  }  }  }  init() {  self.projectedValue = false  self.number = 0  } }  struct Rectangle {  @Num var width: Int }  var rect = Rectangle() rect.width = 15 // The number is private, it will be affect via the `set` function.  print(rect.$width) // Use the dollar sign to access the projectedValue.  // rect.$width = false // It can\u0026#39;t work, the outside caller can\u0026#39;t call the projectedValue\u0026#39;s private function \u0026#39;set\u0026#39; Global and Local Variables   Global\nIt is defined outside any function, method, closure, or type context.\nGlobal constants and variables are always lazily.\n  Local\nIt is defined in any function, method, closure, or type context.\nLocal constants and variables are never computed lazily.\n  Stored Variables  provide storage for a value of a certain type and allow that value to be set and retrieved.  Observer is available for the stored variable and computed variable in a global or local scope.\nProperty wrapper can be use to a stored variable, but not to a global variable or a computed variable.\nHere’s a function’s local stored variable (count) use the wrapper property (Num).\nfunc doSomething() {  @Num var count: Int  _count.number = 12 // The \u0026#39;number\u0026#39; requires the wrapper \u0026#39;Num\u0026#39; so it use a underscore to indicate the wrapper.  print(_count.number) } Instance Properties Every time we create a new instance of that type, it has it own set of property values, separate from any other instance.\nType Properties  If we define a property belong to the type itself, it’s called type property. All instance of that type share this one type property. (like static property in Java class) Stored type properties can be variables or constants. Computed type properties are always declared as variable properties, in the same way as computed instance properties. Need default value. Lazily initialized on first access. Be initialized only once, even when accessed by multiple threads simultaneously.  Type Property Syntax Define type property with static keyword.\nIn a class, use class instead the static to override the superclass’s implementation.\nstruct ShortSize {  static var name = \u0026#34;Short\u0026#34;  private static var store: Int = 1  static var size: Int {  get { return store}  set { store = newValue}  } }  enum MediumSize {  static var name = \u0026#34;Medium\u0026#34;  private static var store: Int = 4  static var size: Int {  get { return store }  set { store = newValue}  } }  class LongSize {  static var name = \u0026#34;Long\u0026#34;  private static var store: Int = 4  static var size: Int {  get { return store}  set { store = newValue}  }   class var sizeFromSuper: Int {  get { return store }  set { store = 2 * newValue}  } }  // Use the type properties print(ShortSize.name) print(ShortSize.size) Setting the Type Properties\n  setting\nstruct ShortSize {  static var name = \u0026#34;Short\u0026#34;  private static var store: Int = 1  var size: Int {  get { return ShortSize.store}  set { ShortSize.store = newValue}  } }  var shortSize = ShortSize() var shortSizeAnother = ShortSize()  print(shortSize.size) print(shortSizeAnother.size)  shortSize.size = 15 // It will change the sharing variable \u0026#39;store\u0026#39; (type property) print(shortSize.size) print(shortSizeAnother.size)   Result\n1 1 15 15\n    Use the observer to respond to the change of the variable and to affect the type property.\nstruct Channel {  static let maxLevel: Int = 10  static var maxInput: Int = 0  var currentLevel: Int {  didSet {  if currentLevel \u0026gt; Channel.maxLevel {  currentLevel = Channel.maxLevel // It set the currentLevel, but it doesn\u0026#39;t call the observer again.  } else if currentLevel \u0026gt; Channel.maxInput {  Channel.maxInput = currentLevel  }   }  } }  var channel = Channel(currentLevel: 0) channel.currentLevel += 4 print(Channel.maxInput) ","permalink":"https://1-1.link/post/language/swift/10properties/","summary":"Stored properties\nOnly provided by classed and structures.\n  Computed properties\nProvide by classes, structures, enumerations.\n  Usually associated with instance of a particular type, can be associated with the type itself(type properties).\nCan define property observers to monitor changes in a property’s value, which can respond to with custom action.\nCan use a property wrapper to reuse code in the getter and setter.\nStored Properties **struct Setting {  var width: Int  let height: Int } var appSetting = Setting(width: 100, height: 200) appSetting.","title":"Properties"},{"content":"Structures and classes are the basic building blocks of the program’s code.\nThey have properties and functions.\nWe can define a structure or class in a single file, the external interface of that structure or class is automatically made for other code to use.\nThe common things:  Define properties to store values Define methods to provide functionality Define subscripts to provide access to their values using subscript syntax Define initializers to set up their initial state Be extended to expand their functionality beyond a default implementation Conform to protocols to provide standard functionality of a certain kind  The additional capabilities that classes support:  Inheritance enables one class to inherit the characteristics of another. Type casting enables you to check and interpret the type of a class instance at runtime. Deinitializers enable an instance of a class to free up any resources it has assigned. Reference counting allows more than one reference to a class instance.  Usages Definition struct Cat { \tvar weight = 3 \tvar legCount = 4 }  class Dog { \tvar weight = 5 \tvar legCount = 4 \tvar cloth = Cloth() // Every dog has a cloth in red color. \tvar name = String? }  class Cloth { \tvar color = \u0026#34;red\u0026#34; \tvar width = 15 \tvar length = 45 } Create Instance let cat = Cat()  let dogA = Dog() let dogB = Dog()  let cloth = Cloth() Access Properties print(cat.legCount)  print(dogA.legCount)  print(dogB.cloth.color) Initialize class Dog {  var weight: Int  var legCount: Int  init (){  self.weight = 5  self.legCount = 4  }  init (weight: Int, legCount: Int = 4){  self.weight = weight  self.legCount = legCount  } }  let dog = Dog(weight: 8)  print(dog.weight) // 8 print(dog.legCount) // 4 Structures and Enumerations Are Value Types Value type will be copied the whole value when it’s being assigned.\n  integers, floating-point numbers, Booleans, strings, arrays and dictionaries are value types. They are implemented as structures behind the scenes.\nCollections like String, array, dictionary use an optimization to reduce the performance cost of copying. They aren’t been copied immediately when be assigned. It creates a reference and share the memory of the collection, collection just be copied when the modification occurs.\n  Value Copy let count = 4 let legCount = count // value copy  struct Rect { \tvar width = 20 \tvar height = 10 }  var window = Rect()  // It\u0026#39;s value copy, even the \u0026#39;window\u0026#39; and the \u0026#39;table\u0026#39; has the same width and height, they are two different instance of Rect.  var table = window  table.width = 25 print(table.width) // Print: 「25」 print(window.width) // Print: 「20」. It hasn\u0026#39;t affect the width of the window.  enum Color: Int{  case green = 1, red, blue, white  mutating func toWhite() {  self = .white  } }  var windowColor = Color.blue let tableColor = windowColor // value copy  windowColor.toWhite() print(windowColor) // white print(tableColor) // blue Classes Are Reference Types Swift just copy the reference of the instance when assigned an instance to another one.\nReference Copy class Dog {  var age = 2 }  let labulado = Dog() let pet = labulado // Just copy the reference.  pet.age += 1 // The reference has\u0026#39;t change, just change the property \u0026#39;age\u0026#39; of the instance.  print(labulado.age) // 3 The labulado and pet are different reference, but they share one instance of the Dog .\nIdentity Operators  identical to (===) not identical to (!==)  Use identity operators to check whether two constants or variables refer to the same single instance.\nif labulado === pet { \tprint(\u0026#34;Refer to the same instance\u0026#34;) } else { \tprint(\u0026#34;Refer to different instance\u0026#34;) } Equal Operators  equal to (==) not equal to (!=)  The basic value type can use the equal operators directly.\nvar s = \u0026#34;dd\u0026#34; var a = \u0026#34;dd\u0026#34; print(s == a) We must define the equal function for our own customs classed and structures, before we use the equal operators.\nclass Dog {  var age = 2 \t// The equal function(operator override)  static func == (left: Dog, right: Dog) -\u0026gt; Bool {  return left.age == right.age  } }  let pet = Dog() pet.age += 1  let myPet = Dog() myPet.age = 3  print(pet === myPet) // false, they are refer to different instance of Dog  print(pet == myPet) // true, here use the equal function above to check whether two instances are equal.  Pointer The reference in Swift is similar to a pointer in C, but isn’t a direct pointer to an address in memory.\nThe standard library provides pointer and buffer types that we can use if we want to interact with pointer directly.\n","permalink":"https://1-1.link/post/language/swift/09structures-and-classes/","summary":"The object oriented programming.","title":"Structures and Classes"},{"content":"Syntax enum Direction { \tcase up \tcase down \tcase left \tcase right } Multiple case can appear on a single line, separated by commas:\nenum { \tcase up, down, left, right } Use the Enumeration\nvar dir = Direction.up When we want to modify the var after the initialized, we can use a shorter form of the enumeration.\nvar dir = Direction.up dir = .down // The value\u0026#39;s type has been inferred when the value is in initializing. Matching Enumeration Values with a Switch Statement enum Direction {  case up  case down  case left  case right } var dir = Direction.right switch dir { case .up:  print(\u0026#34;Go up\u0026#34;) case .down:  print(\u0026#34;Go down\u0026#34;) case .left:  print(\u0026#34;Go left\u0026#34;) case .right:  print(\u0026#34;Go right\u0026#34;) } Iterating over Enumeration Cases Conform to the CaseIterable protocol, to make the enumeration’s case be iterable.\nenum Beverage: CaseIterable {  case coffee, tea, juice } let cases = Beverage.allCases for c in cases {  print(c) }   Result:\ncoffee tea juice\n  Associated Values Here has two reference with associated values of type (Int, Int, Int, Int) or (String), use enumeration can choose one of them.\nenum Barcode { \tcase upc(Int, Int, Int, Int) \tcase qrCode(String) } Use the enumeration to create value, choose a type of barcode\nBut They can store only one of them at any given time.\nvar product = Barcode.upc(8, 810, 222, 888) product = .qrCode(\u0026#34;KINGKIYK\u0026#34;) // Assign another type to the same product. Use switch to check the type, and use let or var to extract each associated value.\nswitch product { case .upc(let numberSystem, let manufacturer, let product, let check):  print(\u0026#34;UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\u0026#34;) case .qrCode(let productCode):  print(\u0026#34;QR code: \\(productCode).\u0026#34;) } If all the associated values are extracted as constants or if all are extracted as variable, we can use var or let annotation before the case name, for brevity.\nswitch product { case let .upc(numberSystem, manufacturer, product, check):  print(\u0026#34;UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\u0026#34;) case let .qrCode(productCode):  print(\u0026#34;QR code: \\(productCode).\u0026#34;) } Raw Values As an alternative to associated values, enumeration cases come pre-populated with default values(raw values), which are all of the same type.\nEach raw value must be unique within its enumeration declaration.\nenum somechar: Character { \tcase tab = \u0026#34;\\t\u0026#34; \tcase lineFeed = \u0026#34;\\n\u0026#34; \tcase carriageReturn = \u0026#34;\\r\u0026#34; } In Enumeration:\n Raw values are set by default, choose one to use when we need. Associated values are set before we want to use it.  Implicitly Assigned Raw Values When we define an enumeration that store integer or string raw values, it’s no need to explicitly assign for each case, Swift can infer from the first one case.\n Implicitly assign with integer  enum Day: Int{  case Sunday = 1, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } print(Day.Monday.rawValue) // Print: 「2」   Implicitly assign with string\nenum Direction: String{  case up, down, left, right }  print(Direction.left.rawValue) // Print: 「left」   Initializing from a Raw Value enum Day: Int{  case Sunday = 1, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday }  enum Direction: String{  case up, down, left, right }  let day = Day(rawValue: 3) // \u0026#39;day\u0026#39; is of type \u0026#39;Day?\u0026#39; and equals to Day.Tuesday  let dir = Direction(rawValue: \u0026#34;right\u0026#34;) let other = Day(rawValue: 8) // Not found rawValue, \u0026#39;other\u0026#39; will be \u0026#39;nil\u0026#39;  print(day!) print(dir) print(other)   Result:\nTuesday Optional(Page_Contents.Direction.right) nil\n  Recursive Enumerations Base on the associated values, recursively use the the associated operation.\nUse the indirect keyword to indicate that the associated value will be called recursively.\nThe \u0026lt;T\u0026gt; indicate to use generic type.\nenum Arithmetic\u0026lt;T\u0026gt; {  case num(T)  indirect case add(Arithmetic, Arithmetic)  indirect case multiply(Arithmetic, Arithmetic) } Another way to indicate the indirect :\nindirect enum Arithmetic\u0026lt;T\u0026gt; {  case num(T)  case add(Arithmetic, Arithmetic)  case multiply(Arithmetic, Arithmetic) } Use the recursive, and access the value with recursive function.\nlet five = Arithmetic\u0026lt;Int\u0026gt;.num(5) let nine = Arithmetic\u0026lt;Int\u0026gt;.num(9)  let sum = Arithmetic.add(five, nine) let multiply = Arithmetic.multiply(sum, five)  func evaluate(_ expression: Arithmetic\u0026lt;Int\u0026gt;) -\u0026gt; Int {  switch expression {  case let .num(value): // Here use the value binding to match the expression.  return value  case let .add(first, second):  return evaluate(first) + evaluate(second)  case let .multiply(first, second):  return evaluate(first) * evaluate(second)  } } print(evaluate(sum)) // 5 + 9 == 14 print(evaluate(multiply)) // (5 + 9) * 5 == 70   Result:\n14 70\n  ","permalink":"https://1-1.link/post/language/swift/08enumerations/","summary":"Syntax enum Direction { \tcase up \tcase down \tcase left \tcase right } Multiple case can appear on a single line, separated by commas:\nenum { \tcase up, down, left, right } Use the Enumeration\nvar dir = Direction.up When we want to modify the var after the initialized, we can use a shorter form of the enumeration.\nvar dir = Direction.up dir = .down // The value\u0026#39;s type has been inferred when the value is in initializing.","title":"Enumerations"},{"content":" A shortcut for accessing the member of a collection, list, or sequence. Classes, structures, and enumerations can define subscripts. Get result by square brackets [] . Use the subscript keyword.  We can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript.\nSyntax subscript(index: Int) -\u0026gt; Int { \tget {} \t\tset(newValue) {} }  subscript(index: Index) -\u0026gt; Int { \t// return directly } Example struct TimesTable { \tlet mul: Int \tsubscript(index: Int) -\u0026gt; Int { \treturn mul * index \t} }  let times = TimesTable(mul: 3)  print(times[6]) Usage class Order {  var names: [String] = []  subscript(index: Int) -\u0026gt; String {  assert(index \u0026lt; names.count, \u0026#34;out of index\u0026#34;)  return names[index]  } }  var order = Order() order.names.append(\u0026#34;Mike\u0026#34;) order.names.append(\u0026#34;Amy\u0026#34;) order.names.append(\u0026#34;John\u0026#34;)  print(order[1]) // Amy The Dictionary has implements the subscript. Not all key has value, so the value is optional.\nvar numberOfLegs = [\u0026#34;cat\u0026#34;: 4, \u0026#34;bird\u0026#34;: 2, \u0026#34;dog\u0026#34;: 4]  print(numberOfLegs[\u0026#34;dog\u0026#34;]!) // The result of the subscript is optional, here force unpack. Delete the value by assign it to nil .\nnumberOfLegs[\u0026#34;dog\u0026#34;] = nil Subscript Options Subscript can:\n take any number and any type of input parameters. return a value of any type. take a varying number of parameter and provide default values.  Subscript can’t:\n use in-out parameters.  Subscript Overloading The subscript defined with different count of parameters or different type of parameters.\nstruct Matrix {  let rows: Int, columns: Int  var grid: [Double]  init(rows: Int, columns: Int) {  self.rows = rows  self.columns = columns  grid = Array(repeating: 0.0, count: rows * columns)  }  func indexIsValid(row: Int, column: Int) -\u0026gt; Bool {  return row \u0026gt;= 0 \u0026amp;\u0026amp; row \u0026lt; rows \u0026amp;\u0026amp; column \u0026gt;= 0 \u0026amp;\u0026amp; column \u0026lt; columns  } \t\t// Here is the overloading  subscript(row: Int, column: Int) -\u0026gt; Double {  get {  assert(indexIsValid(row: row, column: column))  return grid[row * columns + column]  }  set {  assert(indexIsValid(row: row, column: column))  grid[row * columns + column] = newValue  }  }  \t// Here is the overloading  subscript(index: Int) -\u0026gt; Double {  get {  assert(index \u0026lt; grid.count)  return grid[index]  }  set {  assert(index \u0026lt; grid.count)  grid[index] = newValue  }  } }  var mat = Matrix(rows: 4, columns: 5) print(mat) mat[1,1] = 2.5 print(mat) mat[5] = 7.7 print(mat) Type Subscripts The subscripts show above are instance subscript. Now let’s learn about the type subscripts.\n Use static keyword to indicate the type subscript within the classes, structures and enumerations. When define type subscript in the class, Use class keyword instead of static to allow the subclass to override the subscripts.  enum Day: Int {  case Monday = 1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday  static subscript(n: Int) -\u0026gt; Day {  return Day(rawValue: n)!  } }  let day = Day[3] print(day) ","permalink":"https://1-1.link/post/language/swift/12subscripts/","summary":"Set subscript(index: Int) in the class to index the data of the instance of the this class.","title":"Subscripts"},{"content":"Closures **are self-contained blocks of functionality that can be passed around and used in your code.\nGlobal and nested functions are special cases of closures.\n Global functions are closures that have name and don’t capture any value. Nested functions are closures that have a name and can capture values from the enclosing function. Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.  The sort() will sort at original array, and sorted() will sort and return a new sorted array.\nUsage   Pass a closure to a function as a tool to do something.\nFor example, pass as a comparator to a sorted function.\n  Pass multiple closure to a function as some handler to deal the different circumstances after the function call.\nFor example, pass a completion and onFailure closure to a loadPicture function, and to do reaction for the picture load complete or fail.\n   Closures’ Syntax {(parameters) -\u0026gt; \treturn type in \tstatements, the closure\u0026#39;s body } Pass a function closure to a function, as a tool to do some work.\nfunc compare(_ s1: String, _ s2: String) -\u0026gt; Bool{ \treturn s1 \u0026gt; s2 }  let names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: compare) // Here we pass a comparator to the sorted method. // Here the sortedNames is [\u0026#34;Ewa\u0026#34;, \u0026#34;Daniella\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;] An easy way to pass a function (or say a comparator) to a sorted method.\nThis is the inline closure.\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted({(_ s1: String, _ s2: String) -\u0026gt; \tBool in \treturn s1 \u0026gt; s2 }) Inferring Type From Context\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: { s1, s2 in return s1 \u0026gt; s2 } ) // The compiler will infer the parameter types and the return value type. Implicit Return in Single-Expression Closures\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: { s1, s2 in s1 \u0026gt; s2 } ) Shorthand Argument Names for Inline Closures\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: { $0 \u0026gt; $1 }) // \u0026#39;$0\u0026#39; means that getting the first parameter to do the comparation.. Operator Methods\n String type has its string-specific implementation of the grater than operator ‘\u0026gt;’ can be a method that has two parameters of type String, and return a value of type Bool.  let names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var sortedNames = names.sorted(by: \u0026gt;) Trailing Closures Without Trailing Closures\nfunc someFunction(closure: () -\u0026gt; void) {  }  someFunction(closure: {  // closure\u0026#39;s body, to do something. })  var sortedNames = names.sorted(by: {$0 \u0026gt;$1}) With Trailing Closures\nsomeFunction() { // Trailing closure\u0026#39;s body}  var sortedNames = names.sorted() {$0 \u0026gt; $1} With Trailing Closures Omitting Parentheses\nvar sortedNames = names.sorted {$0 \u0026gt; $1} Apply a Provided Closure to Each Element of A Map Using the map() method, and give a closure to it. (The map method here omit the parentheses)\nThe closure say that input a Int , output a String , the process of the closure is after the in .\nlet digitNames = [  0: \u0026#34;Zero\u0026#34;, 1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;, 4: \u0026#34;Four\u0026#34;,  5: \u0026#34;Five\u0026#34;, 6: \u0026#34;Six\u0026#34;, 7: \u0026#34;Seven\u0026#34;, 8: \u0026#34;Eight\u0026#34;, 9: \u0026#34;Nine\u0026#34; ] // A dictionary. let numbers = [16, 58, 510]  // The type of number can be omitted, because it can be inferred from the value the map to be mapped. let numbersStr = numbers.map { (number: Int) -\u0026gt; String in  var num = number // The \u0026#39;number\u0026#39; parameter can\u0026#39;t be modified, so we set a \u0026#39;num\u0026#39; to use its value.  var str: String = \u0026#34;\u0026#34;  repeat {  str = digitNames[num % 10]! + str // remainder operate to get the num\u0026#39;s last digit.  num /= 10  } while num \u0026gt; 0  return str } // Now the numbersStr is [\u0026#34;OneSix\u0026#34;, \u0026#34;FiveEight\u0026#34;,\u0026#34;FiveOneZero\u0026#34;] In the above, digitNames[num % 10]! use the exclamation point, because the result from digitNames is optional, it may be not found by num%10 .(The exclamation point is used to force-unwrap the String value)\nFunction Use Multiple Closures func loadPicture(from server: Server, completion: (Picture) -\u0026gt; Void, onFailure: () -\u0026gt; Void) { \tif let picture = download(\u0026#34;photo.jpg\u0026#34;, from: server) { \tcompletion(picture) \t} else { \tonFailure() \t} } When we call the loadPicture function, we should give it a completion and an onFailure closure as two handlers, so that after the network service done the work, with the handler, we can do something when the download complete or fail.\nCapturing Values A closure can capture constants and variables from the surrounding context in which it’s define. It can read those constants and modify those variables, even if the original scope no longer exist.\n  Nested function is a form of closure that can capture values from it outside scope.\nfunc run(count: Int) -\u0026gt; () -\u0026gt; Int{  var a = 5  func wait() -\u0026gt; Int { \t// The function \u0026#39;wait\u0026#39; capture the reference of \u0026#39;a\u0026#39; and \u0026#39;count\u0026#39; from the surrounding function.  a += count  return a  } \tfunc go() -\u0026gt; Int { \ta += count * 2 \treturn a \t}  return wait // It returns a function, not a simple value. }  print(run(count: 4)()) // Print: 9 // Capturing by reference ensures that \u0026#39;a\u0026#39; and \u0026#39;count\u0026#39; don’t disappear when the call to \u0026#39;run\u0026#39; ends, and also ensures that \u0026#39;a\u0026#39; is available the next time the \u0026#39;wait\u0026#39; function is called. // If the value isn\u0026#39;t mutated by a closure, Swift may store a copy of this value instead of capture it. let fun = run(count: 10) print(fun()) print(fun()) Result\n9 15 25\nThe first time use the run(count: 4) , it has a scope for run.\nThe second time use the run(count: 10), it has another scope.\n NOTE If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance. Swift uses capture lists to break these strong reference cycles.\n   Closures Are Reference Types let fun = run(count: 10) print(fun()) print(fun())  let myFun = fun print(myFun()) Result\n15 25 35\nEscaping Closures In order to let the closure to be use in the function caller’s scope, or the closure want to use the content in the function caller’s scope, we should specify the closure parameter with @escaping , otherwise it will cause the compile-time error.\nThe escaping indicate that the closure is store in a value that’s defined outside the function.\nvar handlers: [() -\u0026gt; Void] = [] func addHandle(handle: @escaping () -\u0026gt; Void) {  handlers.append(handle) \tlet han: () -\u0026gt; Void \than = handle // The handle must be specified with @escaping  func run() {  }  addHandle(handle: run) The code follow is not allow, because the handle has’t been defined(create instance) before the addHandle return.\nfunc addHandle(handle: () -\u0026gt; Void) -\u0026gt; () -\u0026gt; Void {  return handle // The closure \u0026#39;handle\u0026#39; can\u0026#39;t be use } Add the @escaping to solve the problem above. It will escape(store in a value outside the function) and then call the reference.\nfunc addHandle(handle: @escaping () -\u0026gt; Void) -\u0026gt; () -\u0026gt; Void {  return handle } Capturing self Capturing self in an escaping closure makes it easy to accidentally create a strong reference cycle.\nWhen we want to use the properties in current instance of the class, must use self explicitly, or include self in the closure’s capture list.\nUse self Explicitly\nclass Person {  var age = 23  func printAge(){  self.age = 24  print(self.age)  }  func printAgeOther(age: Int){  print(self.age)} // Here the self is needed certainly. Otherwise we can\u0026#39;t derferentiate the \u0026#39;age\u0026#39; of the instance and current function. } var person = Person() person.printAgeOther(age: 4) Include the self in Capture List\nfunc doSomething(_ fun: () -\u0026gt; Void){  fun() } class Person {  var age = 23  func printAgeOther(){  [self] // The capture list.  age = 22  print(age) // Here is use the \u0026#39;self.age\u0026#39;  }   func myFunc() {  doSomething(){  [self] in  print(age) // Here is use the \u0026#39;self.age\u0026#39;  }  } }  var person = Person() person.printAgeOther() person.myFunc()   Result\n22 22\nCapture self in structure or enumeration\n Can always refer to self implicitly. But an escaping closure can’t capture a mutable reference to self .  func doSomething(_ fun: () -\u0026gt; Void){  fun() } func doSomethingElse(_ fun: @escaping () -\u0026gt; Void){  fun() } struct Person {  var age = 23  mutating func myFunc(){  doSomething(){  age = 18  print(age)  }  // The follow code, \u0026#39;doSomethingElse\u0026#39; function\u0026#39;s parameter is escaping, it will trigger compiler error. // doSomethingElse(){ // age = 17 // print(age) // }  } }  var person = Person() person.myFunc() Autoclosures When the closure is assigned to a var or a let , it hasn’t been call, just give its function reference to other.\nIt can be use as delays evaluation or overtime judge.\nvar names = [\u0026#34;Mike\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Jhon\u0026#34;] print(names.count) let theRemover = { names.remove(at: 0)} // Get the closure\u0026#39;s reference. print(names.count) print(\u0026#34;Remove element: \\(theRemover())\u0026#34;) // Call the closure, run the closure\u0026#39;s body first time. print(names.count)   Result\n3 3 Remove element: Mike 2\ntheRemover has a type () -\u0026gt; String\n  Also, we can write it in function like below.\nvar names = [\u0026#34;Mike\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Jhon\u0026#34;] print(names.count)  func doSomething(action: () -\u0026gt; String){  print(\u0026#34;Remove elsemet: \\(action())\u0026#34;) }  doSomething(action: {names.remove(at: 0)}) print(names.count) Use the @autoclosure , it has the same result as the code above.\nvar names = [\u0026#34;Mike\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Jhon\u0026#34;] print(names.count)  func doSomething(action: @autoclosure () -\u0026gt; String){  print(\u0026#34;Remove elsemet: \\(action())\u0026#34;) }  doSomething(action: names.remove(at: 0)) print(names.count) Use the @autoclosure and @escaping .\nvar names = [\u0026#34;Mike\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Jhon\u0026#34;] print(names.count) var funs: [() -\u0026gt; String] = []  func doSomething(action: @autoclosure @escaping () -\u0026gt; String){  print(\u0026#34;Remove elsemet: \\(action())\u0026#34;)  funs.append(action) // It need the condition that action is escaping.(maybe because the action is a reference?)) \tname.append(\u0026#34;Jane\u0026#34;) // The \u0026#34;Jane\u0026#34; can be added to name. }  doSomething(action: names.remove(at: 0)) print(names.count) The escaping means that the argument action is allowed to escape the function’s scope.\n  ","permalink":"https://1-1.link/post/language/swift/07closures/","summary":"The closures can cantains something by the curly bracket.","title":"Closures"},{"content":"The function has two way to affect the outside scope\n Use return value to tell the caller. Use the inout with reference to change the the original value outside.  Function Usages Without Parameter and Return Value\nfunc sayHello() { \tprint(\u0026#34;Hello\u0026#34;) }  // Call the function, will print「hello」 sayHello() With Parameter\nfunc greet(name: String) { \tprint(\u0026#34;Hello \\(name)\u0026#34;) }  // Call the function pass the String as the input to the function, will print 「Hello Mike」 greet(name: \u0026#34;Mike\u0026#34;) With Multiple Parameter\nfunc addTwoNum(a: Int, b: Int) { \tvar c = a + b \tprint(c) }  // Call the function, pass two parameter to the function, will print 「11」  addTwoNum(a: 5, b: 6) With Return Value\nonce defined the return type of a function, it must have a return operation when the function logic end.\nfunc addTwoNum(a: Int, b: Int) -\u0026gt; Int { \tvar c = a + b \treturn c }  // The res will be assigned as 「12」 var res = addTwoNum(a: 3, b: 9)  // The return value can be ignored. addTwoNum(a: 4, b: 9) With Multiple Return Value\n// Return as a tuple func getTwoNum() -\u0026gt; (Int, Int) { \tvar a = 2 \tvar b = 4 \treturn (a, b) }  var nums = getTwoNum()  // Return as a optional dictionary  func getThreeNum() -\u0026gt; (a: Int, b: Int, c: Int)? { \tvar a = 2 \tvar b = 4 \tvar c = 3 \treturn (a, b, c) } With Multiple Parameter and Multiple Return Value\nfunc minMax(array: Int[]) -\u0026gt; (min: Int, max: Int)? { \tif array.isEmpty {return nil} \tvar curMin = array[0] \tvar curMax = array[0] \tfor value in array[1..\u0026lt;array.count] { \tif value \u0026lt; curMin { \tcurMin = value \t} \tif value \u0026gt; curMax { \tcurMax = value \t} \t} \treturn (curMin, curMax) }  // Use optional binding to check  if let bound = minMax(array: [3, 5, 5, 6, 22, 13, 16, 24, 11]) { \tprint(\u0026#34;Min: \\(bound.min)\u0026#34;) \tprint(\u0026#34;Max: \\(bound.max)\u0026#34;) } With Implicit Return\n It only allow the first one sentence to implicit return.  // It will return the result of a + b func sum(a: Int, b: Int) -\u0026gt; Int{ \ta + b }  // It will not return a value func sum(a: Int, b: Int) { \ta + b }  // This can\u0026#39;t work!!! It will trige compile-time error. func getTwoNum() -\u0026gt; Int {  var a = 2  var b = 4  a + b \t// Here not allow to implicit return value \t// The implicit return only allow the first one sentence }  // This can work, because the getTwoNum only use first one sentence to return func get() -\u0026gt; (Int, Int) {  var a = 5  return (5, 6) } func getTwoNum() -\u0026gt; (Int, Int) {  get() // The implicit return can work. } Parameter Parameter Names and Argument Labels // Argument Labels func greet(person: String, from hometown: String) -\u0026gt; String { \t// The \u0026#39;person\u0026#39; and \u0026#39;hometown\u0026#39; are parameter names. \t// The \u0026#39;from\u0026#39; is a argument label of th second parameter. \treturn \u0026#34;\\(person)is come from \\(hometown).\u0026#34; } print(greet(person: \u0026#34;Mike\u0026#34;, from: \u0026#34;New York\u0026#34;)) Omitting Argument Labels Use the underscore to omit the label\nfunc readFromFile(_ path: String) { \tprint(path) }  readFromFile(\u0026#34;./music/one.mp3\u0026#34;) Default Parameter Values func drawRect(x: Int, y: Int, w: Int, h: Int, color: (Int, Int, Int) = (0, 0, 0)) { \t// Here the color has default value (0, 0, 0) } Variadic Parameter  The values passed will be made as as an array. For example, the Double... passed will be made as [Double]  func average(_ nums: Double...) -\u0026gt; Double{ \tvar total: Double = 0 \tfor num in nums { \ttotal += num \t} \treturn total / Double(nums.count) } print(average(3.3, 2.9, 4.6))   To make it unambiguous between the variadic parameter and normal parameters. The first parameter that comes after a variadic parameter must have an apparent argument label.\nfunc getOne(_ nums: Double..., cut cutLen: Int) -\u0026gt; Double{  \treturn 1.0 } print(getOne(3.3, 2.9, 4.6, cut: 3))  // Another way func getAnotherOne(_ nums: Double..., cutLen: Int) -\u0026gt; Double{ \treturn 1.0 } print(getAnotherOne(3.3, 2.9, 4.6, cutLen: 3))   In-Out Parameters Function parameters are constants by default.\nTo modify the parameter’s value and let the changes persist after the function call, we can use the inout keyword.\n(Using the inout keyword, we can change the origin value via the function call)\nThe inout value can’t have a default value, variadic parameters can’t be marked as inout .\n  Without inout\n func swap(_ a: Int, _ b: Int) { \tvar temp = a \ta = b // It will trigger the compile-time error.  \tb = temp // The parameters are constant. }  var x = 2 var y = 3 swap(x, y) print(\u0026#34;x = \\(x), y = \\(y)\u0026#34;   With inout\nfunc swap(_ a: inout Int, _ b: inout Int) { \tvar temp = a \ta = b \tb = temp }  var x = 2 var y = 3 swap(\u0026amp;x, \u0026amp;y) // Here should use the reference sign so that the funtion can konw where to change the value of the original variable. print(\u0026#34;x = \\(x), y = \\(y)\u0026#34;) // It will print 「x = 3, y = 2」   Function Types To describe a function’s input and output.\nSuch as (Int, Int) -\u0026gt; Int or () -\u0026gt; Void .\nfunc addTwoInts(_ a: Int, _ b: Int) -\u0026gt; Int {  return a + b }  var mathFunction: (Int, Int) -\u0026gt; Int = addTwoInts Function Types as Parameter Type\nfunc addTwoInts(_ a: Int, _ b: Int) -\u0026gt; Int {  return a + b }  func printResult(_ mathFunc: (Int, Int) -\u0026gt; Int, _ a: Int, _ b: Int) { \tprint(\u0026#34;Result: \\(mathFunc(a, b))\u0026#34;) }  printResult(addTwoInts, 2, 7) // Print 「Result: 9」 Function Types as Return Types\nfunc stepForward(_ input: Int) -\u0026gt; Int {  return input + 1 } func stepBackward(_ input: Int) -\u0026gt; Int {  return input - 1 }  // Return a function type func chooseStepFunction(backward: Bool) -\u0026gt; (Int) -\u0026gt; Int { \treturn backward ? stepBackward : stepForward }  var cur = 3 let moveNearToZero = chooseStepFunction(backward: cur \u0026gt; 0) // So the moveNearToZero will refers to the stepBackward() function.  while cur != 0 { \tprint(\u0026#34;Cur: \\(cur)\u0026#34;) \tcur = moveNearToZero(cur) }   result:\ncur: 3 cur: 2 cur: 1\n  Nested Function Hidden from the outside world by default.\nOnly when the nested function be returned, it can be used in the caller’s scope.\nfunc chooseStepFunction(backward: Bool) -\u0026gt; (Int) -\u0026gt; Int {  func stepForward(input: Int) -\u0026gt; Int { return input + 1 }  func stepBackward(input: Int) -\u0026gt; Int { return input - 1 }  return backward ? stepBackward : stepForward }  var cur = -4 let moveNearToZero = chooseStepFunction(backward: cur \u0026gt; 0) // moveNearToZero now is refers tyo the nested stepForward() cur = moveNearToZero(cur) ","permalink":"https://1-1.link/post/language/swift/06function/","summary":"Call the function(method) to do something detail.","title":"Function"},{"content":" loop  while for-in repeat while   condition branch   if\n  switch\nwhere\n  guard\n   control transfer statements  break continue fallthrough return throw     Loop For-In Loops var pets = [\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;] for pet in pets {  print(pet) } for index in 0..\u0026lt;2 { \tprint(pets[index]) }  // if we don\u0026#39;t need the value from the 0..\u0026lt;2, use the underscore to ignore the value. var n = 1 for _ in 0..\u0026lt;2 { \tprint(n) \tn += 1 }  var words = [11: \u0026#34;fine\u0026#34;, 2: \u0026#34;happiness\u0026#34;] for (key, word) in words { \tprint(\u0026#34;\\(key): \\(word)\u0026#34;) } Stride Function\nlet minutes = 60 let interval = 5 for tickMark in stride(from: 0, to: minutes, by: interval) { \t// render the mark every 5 minutes.  \t// 0, 5, 10, ... , 50, 55 }  // closed range for tickMark in stride(from: 0, through: minutes, by: inerval { \t// render the mark every 5 minutes. \t// 0, 5, 10, ... , 50, 55, 60 } The for-in can be only use to the object which conform to the Sequence protocol.\nWhile var a = 0 while a \u0026lt; 10 { \tprint(a) // 0 to 9 \ta += 1 } Repeat While The content that repeat while enclose with {} will run at least once.\nvar a = 0 while a \u0026lt; 0 { \tprint(a) \ta += 1 } // will not print  repeat { \tprint(a) \ta += 1 }while a \u0026lt; 0 // will print 0  Condition If var a = 4 if a \u0026lt; 5 { \t// smaller than 5 } else if a \u0026gt; 5 { \t// bigger than 5 } else { \t// equal to 5 } Switch The body of each case must contain at least one executable statement.\nNo Implicit Fallthrough: no need to write ‘break’ in each case, switch do only one case.\nvar s: String = \u0026#34;as\u0026#34; switch s { \tcase \u0026#34;aa\u0026#34;, \u0026#34;AA\u0026#34;: \tprint(\u0026#34;not the target\u0026#34;) \tcase \u0026#34;as\u0026#34;: \tprint(\u0026#34;yes\u0026#34;) \tdefault: \tprint(\u0026#34;I don\u0026#39;t know\u0026#34;) } Interval Matching\nvar a = 40 var amount: String? switch a { \tcase ..\u0026lt;0: \tamount = nil \tcase 0: \tamount = \u0026#34;no\u0026#34; \tcase 1...10: \tamount = \u0026#34;few\u0026#34; \tcase 11..\u0026lt;50: \tamount = \u0026#34;some\u0026#34; \tcase 50..\u0026lt;100: \tamount = \u0026#34;many\u0026#34; \tdefault: \tamount = \u0026#34;much\u0026#34; } Tuples\n Use underscore as a wildcard pattern. The point (0, 0) would match case (0, 0) first, and so all other matching cases would be ignored.  let point = (1, 1) switch point { case (0, 0):  print(\u0026#34;It\u0026#39;s origin\u0026#34;) case (_, 0):  print(\u0026#34;It\u0026#39;s on x axis\u0026#34;) case (0, _):  print(\u0026#34;It\u0026#39;s on y axis\u0026#34;) case (-2...2, -2...2):  print(\u0026#34;It\u0026#39;s in the box\u0026#34;) default:  print(\u0026#34;Out of box\u0026#34;) } Value Bindings\n The case can name value or values from the matched test, for use in the body of the case. In this way, we can choose a matched pattern to do specific work.  let point = (2, 0) switch point { case (let x, 0):  print(\u0026#34;(\\(x),0) is on x axis\u0026#34;) case (0, let y):  print(\u0026#34;(0, \\(y)is on y axis\u0026#34;) case let(x, y):  print(\u0026#34;(\\(x), \\(y)) not on axis\u0026#34;) } Where\n Add a condition for the value or values from the test.  let point = (2, -2) switch point { case let(x, y) where x == y:  print(\u0026#34;(\\(x), \\(y)) is on the line y = x\u0026#34;) case let(x, y) where x == -y:  print(\u0026#34;(\\(x), \\(y)is on the line y = -x\u0026#34;) case let(x, y):  print(\u0026#34;(\\(x), \\(y)) others\u0026#34;) } Compound Cases\n Multiple cases can compounded into one. The pattern can be written over multiple lines.  let c = \u0026#34;a\u0026#34; switch c { case \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;:  print(\u0026#34;It\u0026#39;s a vowel.\u0026#34;) case \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;:  print(\u0026#34;It\u0026#39;s a consonant.\u0026#34;) default:  print(\u0026#34;It\u0026#39;s not an alphabet.\u0026#34;) }   Compound with tuple binding\nEvery pattern in a case must include the temporary object(distance), so the code in the body of the case can always access a value for distance.\nlet point = (1, 0) switch point { case (0, let distance), (let distance, 0):  print(\u0026#34;point is on the axis, distance \\(distance)\u0026#34;) default:  print(\u0026#34;point isn\u0026#39;t on the axis\u0026#34;) }  Control Transfer Statements Continue Tells a loop to stop what it’s doing and start again at the beginning of the next iteration through the loop.\nvar nums: [Int] = [] for n in 1...10 {  if n % 2 == 0 {  continue  }  nums.append(n) } print(nums)   resule\n[1, 3, 5, 7, 9]\n  Break var nums: [Int] = [] for n in 1...10 {  if n == 5 {  break  }  nums.append(n) } print(nums)   result\n[1, 2, 3, 4]\n  Break in a switch\n comments aren’t statement, use a break when the case body is empty.  let n = 5 switch n { case 1:  print(\u0026#34;one\u0026#34;) case 2:  print(\u0026#34;I want to break\u0026#34;)  break \tprint(\u0026#34;two\u0026#34;) // it won\u0026#39;t do this case 3:  print(\u0026#34;three\u0026#34;) default:  break }   Fallthrough In Swift , oneswitch only execute one case . If we want to execute multiple cases, use the fallthrough .\nlet n = 5 switch n { case 5:  print(\u0026#34;five\u0026#34;)  fallthrough // go on the code in the switch default:  print(\u0026#34;believe it or not\u0026#34;)  break } Labeled Statements The break and continue can only affect the current for, while, switch, repeat while. So when we want to break or continue the outside loop or switch, we can use the labeled statements.\n  break\nvar a = 1 var sum = 0 aLoop: while a \u0026lt; 10 {  while a \u0026lt; 5 {  if a == 3 { \ta += 5  break aLoop  }  a += 1  print(\u0026#34;add a: \\(a)\u0026#34;)  }  print(a) \ta += 1 }   result\nadd a: 2 add a: 3\n    continue\nvar a = 1 var sum = 0 aLoop: while a \u0026lt; 10 {  while a \u0026lt; 5 {  if a == 3 {  a+=5 // now the a is 8  continue aLoop  }  a += 1  print(\u0026#34;add a: \\(a)\u0026#34;)  }  print(a)  a += 1 }   result\nadd a: 2 add a: 3 8 9\nIt continue the outside while loop.\n   Early Exit A guard must have else clause after it. It’s to exit early.\nfunc play(ball: String?) {  guard let str = ball else {  print(\u0026#34;no ball\u0026#34;)  return // the guard\u0026#39;s else can\u0026#39;t fall through, here we use the return to end the excution.  } \tprint(str) // it\u0026#39;s available after the guard\u0026#39;s statement. }  play(ball: nil) Checking API Availability if #available(iOS 10, macOS 10.12, *) {  } else { \t// Fall back to earlier iOS and macOS APIs }   ","permalink":"https://1-1.link/post/language/swift/05control-flow/","summary":"loop, condition branch, control transfer.","title":"Control Flow"},{"content":" array set dictionary  collection type use are generic, the type of element is specific.\n Array  With ordering. Access by subscript. Variable-length.  var someInts: [Int] = [] someInts.append(2) someInts = [] // Empty the array Create by class\nvar someDoubles = Array(repeating: 0.0, count: 3) print(someDoubles) var otherDoubles = Array(repeating: 2.5, count: 3) print(otherDoubles) var addedDoubles = someDoubles + otherDoubles // concatenate two array into one print(addedDoubles)   result:\n[0.0, 0.0, 0.0] [2.5, 2.5, 2.5] [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]\n  Create By Array Literal\nvar shoppingList = [\u0026#34;tomato\u0026#34;, \u0026#34;milk\u0026#34;] // Appending shoppingList.append(\u0026#34;noodles\u0026#34;) shoppingList += [\u0026#34;rice\u0026#34;] shoppingList += [\u0026#34;apple\u0026#34;, \u0026#34;juice\u0026#34;]  // Now the array is [\u0026#34;tomato\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;noodles\u0026#34;, \u0026#34;rice\u0026#34;, \u0026#34;apples\u0026#34;, \u0026#34;juice\u0026#34;] Accessing\nprint(\u0026#34;Count of stuff: \\(shoppingList.count)\u0026#34;) // the \u0026#39;count\u0026#39; property is read-only. if shoppingList.isEmpty { \tprint(\u0026#34;Nothing to buy.\u0026#34;) } else { \tprint(\u0026#34;Have something to buy.\u0026#34;) } // Accessing var oneStuff = shoppingList[2] // get the \u0026#34;noodles\u0026#34; Modifying\n// Modifying shoppingList[2] = \u0026#34;dumplings\u0026#34; // Modifying a range of value shoppingList[3...5] = [\u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;banana\u0026#34;] shoppingList[3...5] = [\u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;] // it will remove the element from 3 to 5 and just insert with two new element at position 3. //shoppingList[3...5] = [\u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;bread\u0026#34;, \u0026#34;cookie\u0026#34;] the 5 is out of array\u0026#39;s bound now, so it will trigger a run-time error. shoppingList[3...4] = [\u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;peach\u0026#34;] // it can work, just replace two element shoppingList[3] and shoppingList[4] with three new elenment.  // now the array is [\u0026#34;tomato\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;dumpings\u0026#34;, \u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;peach\u0026#34;]  // insert(_:at:) shoppingList.insert(\u0026#34;drink\u0026#34;, at: 0) // now the shoppingList is: [\u0026#34;drink\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;dumpings\u0026#34;, \u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;peach\u0026#34;]  // remove(at:) let thing = shoppingList.remove(at: 1) // The \u0026#34;thing\u0026#34; is assiged to be \u0026#34;tomato\u0026#34; // Any gaps in an array are closed when an item is removed. // So after the removing, the shoppingList is: [\u0026#34;drink\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;dumpings\u0026#34;, \u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;peach\u0026#34;]  let last = shoppingList.removeLast() // remove the \u0026#34;peach\u0026#34;  var str = shoppingList[0] str.append(\u0026#34;s\u0026#34;) // this will not affect the string in the shoppingList, because the String is value type, it will be copied when be passed (assigned).  shoppingList[0].append(\u0026#34;s\u0026#34;)// this will affect the string in the shoppingList.  // now the array is [\u0026#34;drinks\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;dumpings\u0026#34;, \u0026#34;pie\u0026#34;, \u0026#34;cherry\u0026#34;] Iterating Over an Array\nfor item in shoppingList { \tprint(item) } for (i, value) in shoppingList.enumerated() { \tprint(\u0026#34;Item \\(i): \\(value)\u0026#34; } // here the \u0026#39;i\u0026#39; is a subscript of the array.  Sets  With no defined ordering. An item only appears once.  A type must be hashable in order to be stored in a set—that is, the type must provide a way to compute a hash value for itself. if two objects’ hash values are equal, they are equally.\nAll of Swift’s basic types are hashable by default. (String, Int, Double, Bool, Enumeration)\nCreate a set   create by an Array literal\nvar words: Set\u0026lt;Character\u0026gt; = [\u0026#34;d\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;e\u0026#34;] print(words) print(words.count)   result\n[\u0026ldquo;d\u0026rdquo;, \u0026ldquo;i\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;v\u0026rdquo;] 4\n  In a shorter form\nvar words: Set = [\u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]   create an instance of class Set\nvar letter = Set\u0026lt;Character\u0026gt;() letter.insert(\u0026#34;H\u0026#34;) letter.insert(\u0026#34;e\u0026#34;) letter.insert(\u0026#34;a\u0026#34;) letter.insert(\u0026#34;r\u0026#34;) print(letter) print(letter.count)   result\n[\u0026ldquo;a\u0026rdquo;, \u0026ldquo;r\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;H\u0026rdquo;] 4\n    Accessing var words: Set = [\u0026#34;hide\u0026#34;, \u0026#34;ice\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;big\u0026#34;] print(words.count) // it\u0026#39;s read-only if words.isEmpty { \tprint(\u0026#34;words is empty.\u0026#34;) } Modifying words.insert(\u0026#34;book\u0026#34;)  var wordGet = words.remove(\u0026#34;ice\u0026#34;) // if words doesn\u0026#39;t contain \u0026#34;ice\u0026#34;, the removing will be invalid and the wordGet will be nil. Iterating Over a Set for word in words { \tprint(word) } Iterating in a specific order\nfor word in words.sorted() { \tprint(word) } Set Operations    intersection(_: ) create a new set with only the values common to both sets     symmetricDiffierence(_: ) create a new set with values in either set, but not both   union(_: ) create a new sew with values with all of the values in both sets   subtracting(_: ) create a new set with values not in the ‘b’ set    var a: Set = [1, 2, 5, 6] var b: Set\u0026lt;Int\u0026gt; = [1, 3, 5]  var intersection = a.intersection(b) // a \u0026amp; b var difference = a.symmetricDifference(b) // !a \u0026amp; !b var union = a.union(b) // a or b var subtract = a.subtracting(b) // a - b  print(intersection) print(difference) print(union) print(subtract)   result:\n[5, 1] [2, 6, 3] [3, 2, 1, 6, 5] [6, 2]\n  Membership and Equality   ==\n  isSubset(of: )\n  isSuperset(of: )\n  isStrictSubset(of: )\nIt’s a subset but not equal to.\n  isStrictSuperset(of: )\nIt’s a superset but not equal to.\n  isDisjoint(with: )\nTwo set has no values in common. They are independent with each other.\nlet all: Set = [\u0026#34;😂\u0026#34;, \u0026#34;😎\u0026#34;, \u0026#34;😺\u0026#34;, \u0026#34;🙋🏼‍♂️\u0026#34;] let me: Set = [\u0026#34;🙋🏼‍♂️\u0026#34;] let emoj: Set = [\u0026#34;😂\u0026#34;, \u0026#34;😎\u0026#34;] let other: Set = [\u0026#34;😂\u0026#34;, \u0026#34;😎\u0026#34;, \u0026#34;😺\u0026#34;, \u0026#34;🙋🏼‍♂️\u0026#34;] print(\u0026#34;\u0026#39;me\u0026#39; is subset of \u0026#39;all\u0026#39;: \u0026#34; + String(me.isSubset(of: all))) print(\u0026#34;\u0026#39;all\u0026#39; is superset of \u0026#39;emoj\u0026#39;: \u0026#34; + String(all.isSuperset(of: emoj)))  print(\u0026#34;\u0026#39;all\u0026#39; is superset of \u0026#39;other\u0026#39;: \u0026#34; + String(all.isSuperset(of: other))) print(\u0026#34;\u0026#39;all\u0026#39; is subset of \u0026#39;other\u0026#39;: \u0026#34; + String(all.isSubset(of: other))) print(\u0026#34;\u0026#39;all\u0026#39; is strict superset of \u0026#39;other\u0026#39;: \u0026#34; + String(all.isStrictSuperset(of: other))) print(\u0026#34;\u0026#39;all\u0026#39; is strict subset of \u0026#39;other\u0026#39;: \u0026#34; + String(all.isStrictSuperset(of: other)))  print(\u0026#34;\u0026#39;other\u0026#39; is superset of \u0026#39;all\u0026#39;: \u0026#34; + String(other.isSuperset(of: all))) print(\u0026#34;\u0026#39;other\u0026#39; is subset of \u0026#39;all\u0026#39;: \u0026#34; + String(other.isSubset(of: all)))   result:\n\u0026lsquo;me\u0026rsquo; is subset of \u0026lsquo;all\u0026rsquo;: true \u0026lsquo;all\u0026rsquo; is superset of \u0026rsquo;emoj\u0026rsquo;: true \u0026lsquo;all\u0026rsquo; is superset of \u0026lsquo;other\u0026rsquo;: true \u0026lsquo;all\u0026rsquo; is subset of \u0026lsquo;other\u0026rsquo;: true \u0026lsquo;all\u0026rsquo; is strict superset of \u0026lsquo;other\u0026rsquo;: false \u0026lsquo;all\u0026rsquo; is strict subset of \u0026lsquo;other\u0026rsquo;: false \u0026lsquo;other\u0026rsquo; is superset of \u0026lsquo;all\u0026rsquo;: true \u0026lsquo;other\u0026rsquo; is subset of \u0026lsquo;all\u0026rsquo;: true\n     Dictionary  keys have same type, values have same type with no ordering each value is associated with a unique key key is unique, values may be same   Swift’s Dictionary type is bridged to Foundation’s NSDictionaryclass. The key must conform to the Hashable protocol.\n Create a dictionary\n  by class\nvar pet = Dictionary\u0026lt;Int, String\u0026gt;() pet[11] = \u0026#34;dog\u0026#34; // adding key-value pair pet[23] = \u0026#34;bear\u0026#34;   by literal\nvar pet = [11: \u0026#34;dog\u0026#34;, 23: bear]   properties\n  print(pet.count) print(pet.isEmpty)  if pet[23] != nil {  print(pet) }   result\n2 false\n  Updating\npet[11] = \u0026#34;cat\u0026#34; // update the value  if let oldValue = pet.updateValue(\u0026#34;deer\u0026#34;, forKey: 23) {  // now the pet is: [11: \u0026#34;cat\u0026#34;, 23: \u0026#34;deer\u0026#34;], and the oldValue is bear(optional). } else {  print(\u0026#34;oldValue is nil\u0026#34;) } Removing\n pet[11] = nil // remove a key-value pair.  pet.removeValue(forKey: 23) // remove a key-value pair.  pet = [11: \u0026#34;cat\u0026#34;, 23: \u0026#34;dog\u0026#34;] pet.removeAll() pet = [11: \u0026#34;cat\u0026#34;, 23: \u0026#34;dog\u0026#34;] pet = [:] // clear all Iterating Over a Dictionary\n  by key and value\nfor (key, value) in pet {  print(\u0026#34;\\(key): \\(value)\u0026#34;, terminator: \u0026#34;\\t\u0026#34;) }   result\n23: dog 11: cat\n    by key or value\nvar pet = [11: \u0026#34;cat\u0026#34;, 23: \u0026#34;dog\u0026#34;] print() for key in pet.keys {  print(\u0026#34;\\(key)\u0026#34;, terminator: \u0026#34; \u0026#34;) } print()  for value in pet.values {  print(\u0026#34;\\(value)\u0026#34;, terminator: \u0026#34; \u0026#34;) }   result\n11 23 cat dog\n    Get an Array from key or value\n   ```swift let keys = [Int](pet.keys) ```     ```swift let values = [String](pet.values) ```    get in order by calling sorted(), the object who call the sorted should implements the Comparable.\nlet keys = [Int](pet.keys.sorted())   the pet.sorted(using: ) need a Comparator to sort the dictionary.\n   Summary   Creating\n  Array\nvar pet: [String] = [\u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;]\n  Set\nvar pet: Set\u0026lt;String\u0026gt; = [\u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;]\nvar pet: Set = [\u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;]\n  Dictionary\nvar pet: Dictionary\u0026lt;Int, String\u0026gt; = Dictionary\u0026lt;Int, String\u0026gt;()\nvar pet = [:]\nvar pet: Dictionary\u0026lt;Int, String\u0026gt; = [23: \u0026quot;dog\u0026quot;, 11: \u0026quot;cat\u0026quot;]\nvar pet = [23: \u0026quot;dog\u0026quot;, 11: \u0026quot;cat\u0026quot;]\n    Accessing and Modifying\nthe Array and Dictionary can access by [someKey]directly , but the Set access by insert() and remove() .\n  For-in\n  Array\nfor word in words {}   Set\nfor word in words {}   Dictionary\nfor (key, value) in words {}     Operation\nTo generate new set, Set has some operations between two sets.\n  ","permalink":"https://1-1.link/post/language/swift/04collection-type/","summary":"The array, set, and dictionary.","title":"Collection Type"},{"content":"String type is bridged with Foundation’s NSString. Foundation extends String to expose methods defines by NSString. If import Foundation, you can access those NSString methods on String without casting.\nString Literals // \u0026#34;Hello World!\u0026#34; is a String literal.  let sentence = \u0026#34;Hello World!\u0026#34;  // Multiline let story = \u0026#34;\u0026#34;\u0026#34; There are some people in the room. They are having a party. Because today is the Christmas. \u0026#34;\u0026#34;\u0026#34; // every line has the line breaks. // the start and end sign(\u0026#34;\u0026#34;\u0026#34;) must take a single line.  // backlash(\\), it means that the string is not broken. Then line breaks not to be part of the string\u0026#39;s value. let content = \u0026#34;\u0026#34;\u0026#34; In a happy atmos\\ phere. We start the conversation \u0026#34;\u0026#34;\u0026#34; print(content) // result: In a happy atmosphere. We start the conversation.  // Alignment of quotation marks in the multiline string. let desc = \u0026#34;\u0026#34;\u0026#34; Ha it\u0026#39;s so funny. \u0026#34;\u0026#34;\u0026#34; print(desc) // result: Ha its so funny.  let desc = \u0026#34;\u0026#34;\u0026#34; Ha it\u0026#39;s so funny. \u0026#34;\u0026#34;\u0026#34; print(desc) // result: Ha its so funny.  let desc = \u0026#34;\u0026#34;\u0026#34; Ha it\u0026#39;s so funny. \u0026#34;\u0026#34;\u0026#34; print(desc) // result: Ha its so funny. Special Character in String Literals\n   \\0 null character     \\ backslash   \\t horizontal tab   \\n line feed   \\r carriage return   \\” double quotation mark   ' single quotation mark   \\u{n} n is a 1-8 digit hexadecimal    let dollarSign = \u0026#34;\\u{24}\u0026#34; // $  let blackHeart = \u0026#34;\\u{2665}\u0026#34; // ♥  let redHeart = \u0026#34;\\u{1f496}\u0026#34; // 💖  // Because multiline string literals use three double quotation marks, one double quotation can be used in multiline string litral without escaping it. // And should escape the three double quotation which inside the multiline string literal.  let marks = \u0026#34;\u0026#34;\u0026#34; Escaping the first quotation mark \\\u0026#34;\u0026#34;\u0026#34; Escaping all three quotation \\\u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34;\u0026#34;\u0026#34;  // Abosultly string // use the #\u0026#34;\u0026#34;\u0026#34; and \u0026#34;\u0026#34;\u0026#34;# to include a absultly pure string. let words = #\u0026#34;\u0026#34;\u0026#34; It sounds very good.\u0026#34;\u0026#34;\u0026#34;  \u0026#34;\u0026#34;\u0026#34;# print(words) // result: It sounds very good.\u0026#34;\u0026#34;\u0026#34;  // use the #\u0026#34; and \u0026#34;# to include a absultly pure string. let words = #\u0026#34;It sounds \u0026#34;\u0026#34;\u0026#34; very good.\u0026#34;# print(words) // result: It sounds \u0026#34;\u0026#34;\u0026#34; very good.  // So it has no need to add escaping character(\\).  // If we want to cancel the effect of \u0026#39;#\u0026#39; in a string, use another \u0026#39;#\u0026#39; near the character. let otherWords = #\u0026#34;hello \\#rworld\u0026#34;# print(otherWords) // result:   // If we want to cancel the effect of \u0026#39;#\u0026#39; in a multiline string, use another \u0026#39;#\u0026#39; near the character. let otherWords = #\u0026#34;\u0026#34;\u0026#34; hello \\###rworld \u0026#34;\u0026#34;\u0026#34;# print(otherWords) // result: hello world  Initializing an Empty String\n// They are all empty, they are equivalent to each other. var myName = \u0026#34;\u0026#34; var hisName = String()  // Find out if the string is empty. if myName.isEmpty {  print(\u0026#34;It\u0026#39;s empty.\u0026#34;) } String Mutability var a = \u0026#34;Horse \u0026#34; var b = \u0026#34;carriage\u0026#34; b = a + b // it willf create a new String and assign to b  let str = \u0026#34;he\u0026#34; str += \u0026#34;ran\u0026#34; // it will trigger the compile-time error. // constant string cannot be modified. Strings Are Value type If we create a String value, that String value is copied when it passed to a function or method. When it’s passed, it’s not the original version.\nYou can be confident that the string you are passed won’t be modified unless you modify it yourself.\nSwift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary.\nCharacter for character in \u0026#34;dog!\u0026#34; {  print(character) }  let c : Character = \u0026#34;!\u0026#34;  let characters : [Character] = [\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;s\u0026#34;] let str = String(characters)  // concatenation  str.append(c)  let pet = \u0026#34;dog \u0026#34; + \u0026#34;cat\u0026#34;  var name = \u0026#34;Mike \u0026#34; name += \u0026#34;Amy\u0026#34;  // multiline string let start = \u0026#34;\u0026#34;\u0026#34; one two \u0026#34;\u0026#34;\u0026#34; let end = \u0026#34;\u0026#34;\u0026#34; three \u0026#34;\u0026#34;\u0026#34; let goodStart = \u0026#34;\u0026#34;\u0026#34; one two \u0026#34;\u0026#34;\u0026#34;  print(start + end) // result:  // one // twothree  print(goodStart + end) // result: // one  // two // three String Interpolation let value = 3 let message = \u0026#34;The value is \\(value). Four times is \\(value * 4). \\(\u0026#34;It\u0026#39;s \u0026#34; + \u0026#34;fine.\u0026#34;)\u0026#34; print(message) // result: the value is 3. Four times is 12. It\u0026#39;s fine.  print(#\u0026#34;It\u0026#39;s a \\(value).\u0026#34;#) // It will print the literal string without escaping the \u0026#39;value\u0026#39;. // It\u0026#39;s a \\(value).  print(#\u0026#34;It\u0026#39;s a \\#(value).\u0026#34;#) // It will escape the value. // It\u0026#39;s a 3. Unicode print(\u0026#34;\\u{E9}\u0026#34;) // é print(\u0026#34;\\u{65}\\u{301} // é // two character compound into one character automatically. print(\u0026#34;\\u{1f425}\u0026#34;) // 🐥 let c = \u0026#34;\\u{1F1E8}\\u{1F1F3}\u0026#34; print(c + String(c.count) // 🇨🇳1 // two character compound into one. cn = c + n Counting Character let str = \u0026#34;chick\\u{1f425}\u0026#34; print(str + String(str.count)) // result: chick🐥6  var word = \u0026#34;cafe\u0026#34; word += \u0026#34;\\u{301}\u0026#34; print(word + String(word.count)) // result: café4 Accessing and Modifying a String Accessing\n  str.startIndex\nThe startIndex is 0.\n  str.endIndex\nThe endIndex is equals to count, it points to the next to the last element.\n  Index is a class. It’s special, just like a pointer. It often not start at 0.\n str.index(before : String.Index) str.index(at : String.Index) str.index(after : String.Index)  var str = \u0026#34;peak\u0026#34; str[str.startIndex] = \u0026#34;g\u0026#34; // not allowed, can not assign through subscript print(str[str.startIndex] // subscript is get-only, the result is : p print(str[str.index(before: str.endIndex)]) // result: k print(str[str.index(after: str.startIndex)]) // result: e print(str[str.index(str.startIndex, offsetBy:2)])// result: a  for c in str.indices { \tprint(\u0026#34;\\(str[c])\u0026#34;, terminator: \u0026#34;\u0026#34;) // set terminator empty to cancel the line feed. } // result: p e a k Inserting and removing\n word.insert(_: Character, at: String.Index) word.remove(at: String.Index) message.insert(contentsOf: Collection, at: String.Index) message.removeSubrange(_: Range\u0026lt;String.Index\u0026gt;)  // Insert and remove single character var word = \u0026#34;world\u0026#34; word.insert(\u0026#34;k\u0026#34;, at: word.index(word.endIndex, offsetBy: -2)) word.remove(at: word.index(word.startIndex, offsetBy: 4)) word.remove(at: word.index(before: word.endIndex)) print(word) // result: work  // Insert and remove a substring var message = \u0026#34;we\u0026#34; message.insert(contentsOf : \u0026#34;lcome to here\u0026#34;, at : message.endIndex) print(message) //print: welcome to here   message.removeSubrange(message.index(message.startIndex, offsetBy: 7)..\u0026lt;message.endIndex)  print(message) //print: welcome Substrings\nString is value type, it’s stable but not efficient when cut the string to get substring.\nSubstring is a type. Just to reference the Substring inside the whole String.\nvar str = \u0026#34;Hello, World!\u0026#34; let index = str.firstIndex(of: \u0026#34;,\u0026#34;) ?? str.endIndex var sub = str[..\u0026lt;index] // It doesn\u0026#39;t has a whole copy of String, just create a new type \u0026#39;Substring\u0026#39; to reference the part we cut. print(sub)  sub.remove(at: sub.startIndex) print(sub) // print: ello print(str) // It doesn\u0026#39;t affect the origin String, because \u0026#39;sub\u0026#39; is a independent Substring instance.  let newString = String(sub)// Create an instance of String. Transform a subString to String for long term keep. Comparing Strings var a = String(\u0026#34;word\u0026#34;) var b = String(\u0026#34;word\u0026#34;) print(a == b) // print: true  var str = String(\u0026#34;Hello, world!\\u{E9}\u0026#34;) var quote = String(\u0026#34;Hello, world!\\u{65}\\u{301}\u0026#34;) if str == quote {  print(\u0026#34;Equal\u0026#34;)  // The combine result of \u0026#39;quote\u0026#39; is same as in str. So the these two Strings are equal.  // e + ́ = é } // print: equal  // Single character var c = String(\u0026#34;\\u{41}\u0026#34;) var d = String(\u0026#34;\\u{041}\u0026#34;) print(c == d) // print: true  var c = String(\u0026#34;\\u{41}\u0026#34;) var d = String(\u0026#34;\\u{0410}\u0026#34;) print(c == d) // print: false Prefix and Suffix Equality The hasPrefix(_:) and hasSuffix(_:) methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string.(character one by one compare)\nvar sentences = [  \u0026#34;Hello, world!\u0026#34;,  \u0026#34;Hello, friend!\u0026#34;,  \u0026#34;Hi,Hello, friends all!\u0026#34;,  \u0026#34;Welcome, friend!\u0026#34;,  \u0026#34;Welcome, friends all!\u0026#34; ] for sentence in sentences {  if sentence.hasPrefix(\u0026#34;Hello\u0026#34;) {  print(sentence)  } } // Hello, world! // Hello, friend!  for sentence in sentences { \tif sentence.hasSuffix(\u0026#34;friend!\u0026#34;) {  print(\u0026#34;[\u0026#34; + sentence + \u0026#34;]\u0026#34;)  } } // [Hello, friend!] // [Welcome, friend!]  Unicode Scalar Representation Unicode \\u{1F436} each character has 20bit. 0—1048575\nUTF-16 each character has 16bit, 2Byte. 0—65535\nUTF-8 each character has 8bit, 1Byte. 0—255\nlet word = \u0026#34;dog!!\\u{1F436}\u0026#34;  print(word) print(\u0026#34;UTF-8:\u0026#34;, terminator: \u0026#34; \u0026#34;) for c in word.utf8 {  print(\u0026#34;\\(c)\u0026#34;, terminator : \u0026#34; \u0026#34;) } print(\u0026#34;\\nUTF-16\u0026#34;,terminator: \u0026#34; \u0026#34;) for c in word.utf16 {  print(\u0026#34;\\(c)\u0026#34;, terminator: \u0026#34; \u0026#34;) } print(\u0026#34;\\nUnicode:\u0026#34;, terminator: \u0026#34; \u0026#34;) for c in word.unicodeScalars {  print(\u0026#34;\\(c.value)\u0026#34;, terminator: \u0026#34; \u0026#34;) } print() print(word.count) The execute result\ndog!!🐶 UTF-8: 100 111 103 33 33 240 159 144 182 UTF-16 100 111 103 33 33 55357 56374 Unicode: 100 111 103 33 33 128054 6\n","permalink":"https://1-1.link/post/language/swift/03strings-and-characters/","summary":"String type is bridged with Foundation’s NSString. Foundation extends String to expose methods defines by NSString. If import Foundation, you can access those NSString methods on String without casting.\nString Literals // \u0026#34;Hello World!\u0026#34; is a String literal.  let sentence = \u0026#34;Hello World!\u0026#34;  // Multiline let story = \u0026#34;\u0026#34;\u0026#34; There are some people in the room. They are having a party. Because today is the Christmas. \u0026#34;\u0026#34;\u0026#34; // every line has the line breaks.","title":"Strings and Characters"},{"content":"Terminology  Unary operator (such as -a) Binary operator(such as 2 + 3) Ternary operator(such as a ? b : c)  The values that operators affect are operands. Prefix, infix, suffix\nAssignment Operator\n// Assignment let b = 10 var a = 5 a = b  // tuple assignment let (x, y) = (1, 2)  // not allowed, it is to prevent miss use when the equal operator(==) is actually intended. if x = y { \t// This isn\u0026#39;t valid, because x = y doesn\u0026#39;t return a value. } Arithmetic Operators\n   Addition +     Subtraction -   Multiplication *   Division /    1 + 1 5 - 3 2 * 3 10.0 / 2.5  \u0026#34;hello, \u0026#34; + \u0026#34;world\u0026#34; // Addition operator is also supported for String concatenation  Remainder Operator\nb = (a x some multiplier) + remainder\n// 9 = 4 + 4 + 1 9 / 4 // it equals to 2 9 % 4 // it equals to 1  // Calculate method // a % b  // b = (a x some multiplier) + remainder -9 % 4 // it equals to -1 // -9 = (4 x -2) + -1  // The sign of \u0026#39;b\u0026#39; is ignored. // a % b and a % -b always give the same answer. Compound Assignment Operators\na += 2 // it equals a = a + 2 b -= 3 c *= 2 d /= 2  // The compound assignment operators don\u0026#39;t return a value.  // let b = a += 2 is illegal Comparison Operator\n   Equal to a == b     Not equal to a != b   Greater than a \u0026gt; b   Less than a \u0026lt; b   Greater than or equal to a \u0026gt;= b   Less than or equal to a \u0026lt;= b    // Compare the tuples // from left to right (1, \u0026#34;zebra\u0026#34;) \u0026lt; (2, \u0026#34;apple\u0026#34;) // true (3, \u0026#34;apple\u0026#34;) \u0026lt; (3, \u0026#34;bird\u0026#34;) // true (4, \u0026#34;dog\u0026#34;) == (4, \u0026#34;dog\u0026#34;) // true  // The element in the tuple should be comparable, so that the tuple can be comparable (String, Int) \u0026lt; (String, Int) // It\u0026#39;s ok (String, Boolean) \u0026lt; (String, Int) // Error, Boolean can\u0026#39;t be compared Ternary Operator\nvar a = 3 var b = 4 c = a \u0026gt; b ? 2 : 1  // The code equals to var a = 3 var b = 4 if a \u0026gt; b { \tc = 2 } else { \tc = 1 } Nil-Coalescing Operator Only optional type can use nil-coalescing operator\n // unwrap an optional \u0026#39;a\u0026#39; if it contains a value, or return a default value \u0026#39;b\u0026#39; if \u0026#39;a\u0026#39; is nil. a ?? b  // The code equals to a != nil ? a! : b  // Usage let defaultColorName = \u0026#34;red\u0026#34; var userDefinedColorName : String? // It\u0026#39;s assign with nil in default.  var colorNameToUse = userDefinedColorName ?? defaultColorName // it\u0026#39;s red  userDefinedColorName = \u0026#34;Green\u0026#34; colorNameToUse = userDefinedColorName ?? defaultColorName // it\u0026#39;s green Range Operator Closed Range Operator\n// From 1 to 5, include 1 and 5 for i in 1...5 { \t} Half-Open Range Operator\n// From 1 to 5, include 1 but not 5 for i in 1..\u0026lt;5 { \t} // it\u0026#39;s useful in array traversal One-Side Range\nfor name in names[2...] { \t// from 2 to the end, include 2 }  for name in names[...2] { \t// from 0 to 2, include 2 }  for name in names[..\u0026lt;2] { \t// from 0 to 2, not include 2 }  // One-side operator can be used in other contexts, not just in subscripts. let range = ...5 range.contains(7) range.contains(5) range.cantains(-3) Logical Operator    Logical NOT !a     Logical AND a \u0026amp;\u0026amp; b   Logical OR a    Combining Logical Operators\nThe compound expression are left-associative.\nif enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan || hasDoorKey || knowsOverridePassword { \tprint(\u0026#34;Welcome!\u0026#34;) } else { \tprint(\u0026#34;Access Denied\u0026#34;) } Explicit Parentheses Add a pair of parentheses to make it easier to read.s\nif (enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword { \tprint(\u0026#34;Welcome!\u0026#34;) } else { \tprint(\u0026#34;Access Denied\u0026#34;) } ","permalink":"https://1-1.link/post/language/swift/02basic-operators/","summary":"Basic usage of the operators.","title":"Basic Operators"},{"content":"Syntax\n// variable var number = 6 var title: String? // const value, should be initialized before use it, can\u0026#39;t be changed after its definition let speed = 200 let name: String? = nil  // array var str: [Character] = [\u0026#34;d\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;g\u0026#34;]  Base data type    Type Desc     UInt8 UInt8.min is 0, UInt8.max is 255   Int On the 32-bit platform, it’s as Int32; On the 64-bit platform, it’s as Int64.   Uint On the 32-bit platform, it’s as UInt32; On the 64-bit platform, it’s as UInt64.   Double 64-bit floating-point number   Float 32-bit floating-point number   Boolean true or false    Numeric\n/* Numeric Literals */ // They are the same number, in another word, their values are the same.  let decimalInteger = 17 let binaryInteger = 0b10001 let octalInteger = 0o21 let hexadecimalInteger = 0x11  // Optional exponent (exp) 1.25e2 1.25e-2  // pad with extra zeros and underscores to make them easier to read. let paddedDouble = 000123.456 let oneMillion = 1_000_000 let justOverOneBillion = 1_000_000.000_000_1  /* Numeric Type Conversion */ // Type automatic convert let a: UInt16 = 2000 let b: UInt8 = 1 // Different type can\u0026#39;t be sum together let c = a + b // Here, system use b to create a new UInt16 object, so this new object can sum with a.  // Type force convert let three = 3 let num = 0.14159 let pi = Double(three) + num // conversions between integer and floating-point numeric types must be made explict.  // Truncate let integerPi = Int(pi)  // The rules for combining numeric constants and variable are different from the rules for numeric literals. // Number literals don’t have an explicit type in and of themselves. Type Aliases\ntypealias MyInt16 = UInt16  var num: MyInt16 = MyInt16.min // it\u0026#39;s actually calls the UInt16.min Tuples\nlet http404Error = (404, \u0026#34; Not Found\u0026#34;) // compose a tuple   let (statusCode, statusMessage) = http404Error // decompose a tuple  let (justTheStatusCode, _) = http404Error // use a underscore(_) to ignore other values  let statusCodeByIndex = http404Error.0 // get the tuple\u0026#39;s individual element value by index, start at 0  // name the tuple\u0026#39;s individual element let http200Status = (statusCode : 200, description : \u0026#34;OK\u0026#34;)  let status200 = http200Status.statusCode let description200 = http200Status.description Optional : variable can be a value or nil. Just add a ? after the variable’s type. nilmeaning “the absence of a valid object.”\nonly optional type can be nil.\nconst value should not be nil, it has no specific meaning in application.\nvar name: String? = \u0026#34;Hello\u0026#34;  // Because the initializer might be fail, it returns an optional Int (Int?), rather than an Int.  let num = Int(\u0026#34;123\u0026#34;)  var answer: Int? // the answer is automatically set to nil.  // In Objective-C, nil is a pointer to a nonexistent object.  // In Swift, nil isn’t a pointer—it’s the absence of a value of a certain type.  // Include multiple condition // If any of the values in the optional bindings are nil or any Boolean condition evaluates to false, the whole if statement’s condition is considered to be false. if let firstNum = Int(\u0026#34;4\u0026#34;), let secondNum = Int(\u0026#34;5\u0026#34;), firstNum \u0026lt; secondNum \u0026amp;\u0026amp; secondNum \u0026lt; 100 { \tprint(\u0026#34;\\(firstNum)\u0026lt; \\(secondNum)\u0026lt; 100\u0026#34;) }  let hobby: String? // ordinary optional let myHobby = hobby! // must require a exclaimation point to unwrap the object.  // An implicitly unwrapped optional as giving permission for the optional to be force-unwrapped if needed let address: String! // implicitly option. the name can be accessed when it is nil and without exclaimation point. let hisAddress = address // it is permitted, no need for an exclaimation point.  // we are recommanded to use the ordinary optional in development. // because the implicitly optional can easily be out of control.  // ######## error ######### // this will trigger a runtime error var str: String! = nil print(str.count) // this will trigger a runtime error var bag: String? print(str!.count). // \u0026#39;str!\u0026#39; is nil, so it can\u0026#39;t be accessed.   // this will trigger a compiler error var pack: String? print(str.count) // str is an ordinary option, need an unwrap(!). // #######################  Function’s argument and its label   use parameter label\nfunc addTwo(arg1 a : Int, arg2 b : Int) -\u0026gt; Int {  let c = a + b  return c } let sum = addTwo(arg1: 4, arg2: 28)   Tell parameter’s name apparently(Recommended when the method has multi-parameter)\nfunc addTwo(a : Int, b : Int) -\u0026gt; Int {  let c = a + _b  return c } let sum = addTwo(a: 4, b: 28)   use [ _ ] to pass over the label (Recommended when the method has only one parameter)\nfunc addTwo(_ a : Int, _ b : Int) -\u0026gt; Int {  let c = a + b  return c } let sum = addTwo(4, 28)   Function’s define and invoke no need to be sequenced. It can be invoked before its define.\n// invoke function  goToSchool( //function definition func goToSchool() {  print(\u0026#34;I go to school.\u0026#34;) }    Object Oriented Class\nclass Person {  var name = \u0026#34;neo\u0026#34;  var age = 0   init () {}  init (_ name: String, _ age: Int) {  self.name = name  self.age = age  } } // use different init function to create object. var a = Person() var b = Person(\u0026#34;Mike\u0026#34;, 26) print(a.name + \u0026#34; \u0026#34; + String(a.age)) print(b.name + \u0026#34; \u0026#34; + String(b.age)) Optional\nclass BlogPost {  // title can be String or nil  var title : String?  } let post = BlogPost() print(post.body + \u0026#34; hello!\u0026#34;)  //post.title = \u0026#34;yo\u0026#34;  // Optional Binding if let actualTitle = post.title {  print(actualTitle + \u0026#34; Hey\u0026#34;) } else { \tprint(\u0026#34;post.title is \\(post.title)\u0026#34;) }  // Testting for nil if post.title != nil {  print(post.title! + \u0026#34; not nil\u0026#34;) // exclaimation \u0026#39;!\u0026#39; means force unbox  } if post.title == nil {  print(\u0026#34;It\u0026#39;s nil\u0026#34;) }  // Implicity optional var name: String! = \u0026#34;Amy\u0026#34; // \u0026#39;!\u0026#39; means that implicity optional if name != nil { \t// no need to use \u0026#39;!\u0026#39; \tprint(name + \u0026#34; not nil\u0026#34;) } Initializer\n  The rule of initializer\n  A designated initializer must call the designated initializer from the immediately superclass.\nclass Worker: Person {  override init () {  super.init()  print(\u0026#34;subclass\u0026#39;s designated initializer\u0026#34;)  } \t// it has no conflict with the superclass\u0026#39;s convenience method.   init (customName: String, age: Int) { \t// designated initializer call the designated initializer from superclass. \tsuper.init(name: customName) \tself.age = age  print(\u0026#34;subclass\u0026#39;s designated initializer with two parameters\u0026#34;)  } }  class Person {  var name = \u0026#34;neo\u0026#34;  var age = 0   init () {  age = 3  name = \u0026#34;ha\u0026#34;  } \tinit (name: String) {  self.name = name  } \tconvenience init (customName: String, age: Int) {  self.init(name: customName)  self.age = age  } }   A convenience initializer must call another designated initializer from the same class.\n  A convenience initializer must ultimately call a designated initializer.\n    designated initializer\ninit () {  age = 3  name = \u0026#34;ha\u0026#34;  } init(_ name: String, _ age: Int) { \tself.name = name \tself.age = age }   convenience initializer\nif we want to invoke the designated initializer self.init() in a newly init method, we should add a keyword ‘convenience’ to decorate this newly method. (The reason why we use the ‘convenience’ keyword)\nconvenience init(name: String) { \tself.init() // rule 3 of the rules we talk before.  self.name = name }   Inheritance\nSwift only permit single inheritance\nclass Car {  var topSpeed = 200  func drive() {  print(\u0026#34;Drive at \\(topSpeed)\u0026#34;)  } }  // inheritance class FutureCar: Car() { \t// the method belong to current class \tfunc fly() {  print(\u0026#34;Fly at \\(topSpeed + 20)\u0026#34;) \t} } let myRide = Car() // create an instance from the class \u0026#39;Car\u0026#39;. myRide.drive() let hisCar = FutureCar() hisCar.fly() // method create by the subclass.   Polymorphism\n  Override\nThe method has the same name but the arguments’ type or count are different.\nIf we call with different types or count of arguments , the phenomenons(results) are different.\nclass Car {  var speed = 200  func drive() {  print(\u0026#34;Drive at \\(speed)\u0026#34;) // the \u0026#39;speed\u0026#39; can be use in this class \u0026#39;Car\u0026#39;  }  func drive(_ speed: Int) {  print(\u0026#34;Drive at \\(speed)\u0026#34;) // the \u0026#39;speed\u0026#39; can be only used in this func  } } let myCar = Car() myCar.drive() myCar.drive(160) // another case goToSchool() goToSchool(\u0026#34;Mike\u0026#34;) goToSchool(\u0026#34;Micle\u0026#34;, \u0026#34;Jhon\u0026#34;) goToSchool(15) func goToSchool() {  print(\u0026#34;I go to school.\u0026#34;) } func goToSchool(_ peoleA: String) {  print(\u0026#34;I go to school with \\(peoleA).\u0026#34;) } func goToSchool(_ peopleA: String, _ peopleB: String) {  print(\u0026#34;I go to school with \u0026#34; + peopleA + \u0026#34; and \u0026#34; + peopleB + \u0026#34;.\u0026#34;) } func goToSchool(_ speed: Int) {  print(\u0026#34;I go to school in a speed of \\(speed).\u0026#34;) } The subclass define a same method already in the superclass, but the implement of this method is different from that implemented in the superclass. Use the key word ‘override’\nclass Car {  var speed = 200  func drive() {  print(\u0026#34;Drive at \\(speed)\u0026#34;)  } }  // inheritance class FutureCar: Car() {  // override the method from the superclass. \toverride func drive() { \tprint(\u0026#34;Drive at \\(speed + 5)\u0026#34;) \t} } let myRide = Car()//create an instance from the class \u0026#39;Car\u0026#39;. myRide.drive() let hisCar = FutureCar() hisCar.drive() //method override by the subclass.     Error Handling Two way to solve the error on runtime\n  throws\nfunc doSomething() throws { \t// Here may or may not throw an error }   do try catch\ndo the right things to face the error.\ndo { \ttry makeSandwich() \t// no error was thrown \teatSandwich() } catch SandwichError.outOfCleanDishes { \t// an error was thrown  washDish() } catch SandwichError.missingIngredients(let ingredients) { \t// an error was thrown  buyGroceries(ingredients) } catch { \t// catch other errors } Assertion \u0026amp; Precondition A assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.\n// Assertion let age = -3 assert(age \u0026gt;= 0, \u0026#34;Age can\u0026#39;t be less than 0\u0026#34;) // (the condition, the message to be shown when the condition is false) assert(age \u0026gt;= 0) // omit the message, it\u0026#39;s ok. if age \u0026lt; 0 { \tassertionFailure(\u0026#34;Age can\u0026#39;t be less than 0\u0026#34;) // when the code already check the failure, use the assertionFailure to show message directly. }  // Precondition let index = -1 precondition(index \u0026gt;= 0, \u0026#34;Index must be greater than 0\u0026#34;) precondition(index \u0026gt;= 0)  preconditionFailure(\u0026#34;Index must be greater than 0\u0026#34;) // If you compile in unchecked mode (-Ounchecked), preconditions aren’t checked.But the assertion still check. // Assertion check in debug environment, not check in realease environment. // Precondition check in debug environment and release environment.  // Use fatalError(_ :file:line:) to halt execution // During prototyping and early development to create stubs for functionality that hasn’t been implemented yet, write a fatalError as the stub implementation. // if the code use the functionality which hasn\u0026#39;t been implemented, that will result in a fatal error. It will remind us to implement the function or method. fatalError(\u0026#34;Unimplemented\u0026#34;)   ","permalink":"https://1-1.link/post/language/swift/01basic/","summary":"Basic usage of the swift syntax.","title":"Basic"}]