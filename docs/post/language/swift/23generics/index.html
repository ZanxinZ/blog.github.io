<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Generics | CodePaper</title>
<meta name=keywords content="编程语言">
<meta name=description content="Define a class with template type , then should illustract the type when use the class.">
<meta name=author content>
<link rel=canonical href=https://1-1.link/post/language/swift/23generics/>
<link crossorigin=anonymous href=/assets/css/stylesheet.ea5f2fd568f688f106fb918bfebdccb965b2f6ecb642824b56e5e0a12f25311c.css integrity="sha256-6l8v1Wj2iPEG+5GL/r3MuWWy9uy2QoJLVuXgoS8lMRw=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://1-1.link/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://1-1.link/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://1-1.link/favicon-32x32.png>
<link rel=apple-touch-icon href=https://1-1.link/apple-touch-icon.png>
<link rel=mask-icon href=https://1-1.link/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Generics">
<meta property="og:description" content="Define a class with template type , then should illustract the type when use the class.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://1-1.link/post/language/swift/23generics/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-06-05T16:00:40+08:00">
<meta property="article:modified_time" content="2022-06-05T16:00:40+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Generics">
<meta name=twitter:description content="Define a class with template type , then should illustract the type when use the class.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"Generics","item":"https://1-1.link/post/language/swift/23generics/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generics","name":"Generics","description":"Define a class with template type , then should illustract the type when use the class.","keywords":["编程语言"],"articleBody":"Write code in a more abstract way. It make the code flexible and more reusable.\nArray and Dictionary types are both generic collections.\nThe Problem That Generics Solve If the code with no generics:\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) { let tmp = a a = b b = tmp } func swapTwoStrings(_ a: inout String, _ b: inout String) { let tmp = a a = b b = tmp } func swapTwoDoubles(_ a: inout Double, _ b: inout Double) { let tmp = a a = b b = tmp } // Use the function var aInt = 3, bInt = 4 var aString = \"Mike\", bString = \"Amy\" var aDouble = 1.1, bDouble = 2.5 swapTwoInts(\u0026aInt, \u0026bInt) swapTwoStrings(\u0026aString, \u0026bString) swapTwoDoubles(\u0026aDouble, \u0026bDouble) print(aInt, bInt) print(aString, bString) print(aDouble, bDouble) // Print: // 4 3 // Amy Mike // 2.5 1.1 Once the code use generics:\n// The  means that this function will use a generic and the type is T. func swapTwoObj(_ a: inout T, _ b: inout T) { let tmp = a a = b b = tmp } // Use the function var aInt = 3, bInt = 4 var aString = \"Mike\", bString = \"Amy\" var aDouble = 1.1, bDouble = 2.5 swapTwoObj(\u0026aInt, \u0026bInt) swapTwoObj(\u0026aString, \u0026bString) swapTwoObj(\u0026aDouble, \u0026bDouble) print(aInt, bInt) print(aString, bString) print(aDouble, bDouble) // Print: // 4 3 // Amy Mike // 2.5 1.1 So the generics can clearly reduce the duplicated code when the code do the similar things.\nType Parameters We can define more than one generic types in the angle brackets.\nfunc swapTwoObj(_ a: inout T, _ b: inout T, _ c: C, _ d: D) { let tmp = a a = b b = tmp } Generic Types The generics can be applied to classes, structures and enumerations.\nAn example that write a generic stack : First In First Out\nclass Stack { var store: [T] = [] func push(_ element: T) { store.append(element) } func pop() - T? { if store.count  0 { var t = store[store.count - 1] store.remove(at: store.count - 1) return t } return nil } func isEmpty() - Bool { return store.count  0 } } let stack = Stack() stack.push(4) stack.push(22) stack.push(6) while !stack.isEmpty() { if let e = stack.pop() { print(e) } else { print(\"e is nil\") } } // Print:  // 6 // 22 // 4 Extending a Genetic Type extension Stack { var topItem: T? { return store.isEmpty ? nil : store[store.count - 1] } } stack.push(5) stack.push(8) if let top = stack.topItem { print(top) // 8 } Type Constraints Here we constrain the genetic types that they should conform to the specific protocol.\nfunc someFunction(someT: T, someU: U) { // function body goes here } Example:\nThe T: Equatable define that the T must conform to the Equatable protocol so that the T can be compared with ==.\nfunc findIndex(of target: T, in array: [T]) - Int? { for (index, value) in array.enumerated() { if value == target { return index } } return nil } let strings = [\"cat\", \"dog\", \"llama\", \"parakeet\", \"terrapin\"] if let foundIndex = findIndex(of: \"dog\", in: strings) { print(\"Index: \\(foundIndex)\") } // Print: // Index: 1 Associated Type The actual type to use for that associated type isn’t specified until the protocol is adopted.\n// The conforming type must provide these three requirements. protocol Container { associatedtype Item // The actual type will be infered when the append method is implemented. mutating func append(_ item: Item) var count: Int { get } subscript(i: Int) - Item { get } } The IntStack implementation\nstruct IntStack: Container { var items: [Int] = [] // It demonstrates the associatedtype. typealias Item = Int mutating func push(_ item: Int) { items.append(item) } mutating func pop() - Int { return items.removeLast() } mutating func append(_ item: Int) { push(item) } var count: Int { items.count } subscript(i: Int) - Int { items[i] } } The generic stack conform to the container.\nstruct Stack: Container { var items: [Element] = [] mutating func push(_ item: Element) { items.append(item) } mutating func pop() - Element{ return items.removeLast() } // It implements the appen(_: ) requirement, Swift can therefore infer that Element is the associatedtype for the contaioner. mutating func append(_ item: Element) { push(item) } var count: Int { items.count } subscript(i: Int) - Element { return items[i] } } Extending an Existing Type to Specify an Associated Type Swift’s Array type already provides append(_: ), count, subscript. This means that we can extend Array to conform the Container protocol.\nextension Array: Container {} Adding Constraints to an Associated Type protocol Container { associatedtype Item: Equatable // Here the Item conform to the Equatable is a constraints mutating func append(_ item: Item) var count: Int { get } subscript(i: Int) - Item { get } } Using a Protocol in its Associated Type’s Constraints Here using the custom protocol SuffixableContainer in its constraints.\nprotocol SuffixableContainer: Container { // It defines an associatedtype named Suffix and its Item type must be the same as the container's Item type. associatedtype Suffix: SuffixableContainer *where* Suffix.Item == Item // Use　the protocol suffixableContainer to constrain the associated type.  func suffix(_ size: Int) - Suffix } // The extension  extension Stack: SuffixableContainer { // It implement the method, and Swift infer that Suffix is Stack. func suffix(_ size: Int) - Stack{ var result = Stack() for index in (count - size)..self[index]) } return result } } var stackOfInt = Stack() stackOfInt.push(3) stackOfInt.push(6) stackOfInt.push(9) let suffix = stackOfInt.suffix(2) print(suffix) // Print: // Stack(items: [6, 9]) Generic Where Clauses A generic where clause require that an associated type must conform to a certain protocol, or that the certain type parameters and associated types must be the same.\nfunc allItemMatch(_ container: C1, _ anotherContainer: C2) - Bool where C1.Item == C2.Item, C1.Item: Equatable { // Check if two container's count equal. if container.count != anotherContainer.count { return false } // Check each item pairs to see if they are equivalent. for i in 0..if container[i] != anotherContainer[i] { return false } } return true } We already extends the array with the code **extension** Array: Container {} before, now both the Stack and Array are conform to the Container, so they can be the parameter for the method allItemMatch.\nvar stackOfStrings = Stack() stackOfStrings.push(\"uno\") stackOfStrings.push(\"dos\") stackOfStrings.push(\"tree\") var arrayOfStrings = [\"uno\", \"dos\", \"tree\"] // Now C1 is Stack and C2 is Array if allItemMatch(stackOfStrings, arrayOfStrings) { print(\"Matched\") } else { print(\"Not match\") } Extension with a Generic Where Clause It means that the extension have some condition to be valid. If the stack whose elements aren’t equatable and it try to call the isTop(_ :) , it will trigger a compile-time error.\nvar stackOfStrings = Stack() stackOfStrings.push(\"uno\") stackOfStrings.push(\"dos\") stackOfStrings.push(\"tree\") // The extension only be vaild where the element conform to the Equatable protocol. extension Stack where Element: Equatable { func isTop(_ item: Element) - Bool { guard let topItem = items.last else { return false } return topItem == item } } print(stackOfStrings.isTop(\"tree\")) We can also use generic where clause with extension to a protocol.\nextension Container where Item: Equatable { func startWith(_ item: Item) - Bool { return count = 1 \u0026\u0026 self[0] == item } } We can also constrain the extension’s generic type must be a specific type. Only when the condition is satisfied, the extension can be valid.\nextension Container where Item == Double { func average() - Double { var sum = 0.0 for i in 0..+= self[i] } return sum / Double(count) } } print([11.2, 5.3, 3.2].average()) // 6.566666666666666 Contextual Where Clauses Use the condition to constrain only the method. These method only be available when the condition is satisfied.\nextension Container { func average() - Double where Item == Int { var sum = 0.0 for i in 0..+= Double(self[i]) } return sum / Double(count) } func endsWith(_ item: Item) - Bool where Item: Equatable{ return count = 1 \u0026\u0026 self[count - 1] == item } } The same behavior implemented in another way. Moving those requirement in different extensions.\nextension Container where Item == Int { func average() - Double { var sum = 0.0 for index in 0..+= Double(self[index]) } return sum / Double(count) } } extension Container where Item: Equatable { func endsWith(_ item: Item) - Bool { return count = 1 \u0026\u0026 self[count-1] == item } } Two way to do the where clause above have the same behavior. They activate the specific requirements when the condition is satisfied. However, the contextual where clause only need one extension, and the extensions’ generic where clause will require one extension for per requirement.\nAssociated Type with a Generic Where Clause Here we define the Iterator conform to the IteratorProtocol where the type Iterator.Element is the same as Item.\nprotocol Container { associatedtype Item mutating func append(_ item: Item) var count: Int { get } subscript(i: Int) - Item { get } associatedtype Iterator: IteratorProtocol where Iterator.Element == Item func makeIterator() - Iterator } We can add a constraint to an inherited associated type by including the generic where clause in the protocol declaration.\nprotocol ComparableContainer: Container where Item: Comparable {} Generic Subscripts Use the where to constrain.\nextension Container { subscript(indices: Indices) - [Item] where Indices.Iterator.Element == Int{ var result: [Item] = [] for i in indices { result.append(self[i]) } return result } } ","wordCount":"1594","inLanguage":"en","datePublished":"2022-06-05T16:00:40+08:00","dateModified":"2022-06-05T16:00:40+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://1-1.link/post/language/swift/23generics/"},"publisher":{"@type":"Organization","name":"CodePaper","logo":{"@type":"ImageObject","url":"https://1-1.link/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://1-1.link accesskey=h title="CodePaper (Alt + H)">CodePaper</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://1-1.link/archive/ title=📦档案>
<span>📦档案</span>
</a>
</li>
<li>
<a href=https://1-1.link/categories/ title=📖类别>
<span>📖类别</span>
</a>
</li>
<li>
<a href=https://1-1.link/tags/ title=🏷️标签>
<span>🏷️标签</span>
</a>
</li>
<li>
<a href=https://1-1.link/search/ title="🔎搜索 (Alt + /)" accesskey=/>
<span>🔎搜索</span>
</a>
</li>
<li>
<a href=https://1-1.link/about/ title=🧑‍💻关于我>
<span>🧑‍💻关于我</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://1-1.link>Home</a></div>
<h1 class=post-title>
Generics
</h1>
<div class=post-meta><span title="2022-06-05 16:00:40 +0800 CST">June 5, 2022</span>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#the-problem-that-generics-solve aria-label="The Problem That Generics Solve">The Problem That Generics Solve</a></li>
<li>
<a href=#type-parameters aria-label="Type Parameters">Type Parameters</a></li>
<li>
<a href=#generic-types aria-label="Generic Types">Generic Types</a></li>
<li>
<a href=#extending-a-genetic-type aria-label="Extending a Genetic Type">Extending a Genetic Type</a></li>
<li>
<a href=#type-constraints aria-label="Type Constraints">Type Constraints</a></li>
<li>
<a href=#associated-type aria-label="Associated Type">Associated Type</a><ul>
<li>
<a href=#extending-an-existing-type-to-specify-an-associated-type aria-label="Extending an Existing Type to Specify an Associated Type">Extending an Existing Type to Specify an Associated Type</a></li>
<li>
<a href=#adding-constraints-to-an-associated-type aria-label="Adding Constraints to an Associated Type">Adding Constraints to an Associated Type</a></li>
<li>
<a href=#using-a-protocol-in-its-associated-types-constraints aria-label="Using a Protocol in its Associated Type’s Constraints">Using a Protocol in its Associated Type’s Constraints</a></li></ul>
</li>
<li>
<a href=#generic-where-clauses aria-label="Generic Where Clauses">Generic Where Clauses</a></li>
<li>
<a href=#extension-with-a-generic-where-clause aria-label="Extension with a Generic Where Clause">Extension with a Generic Where Clause</a></li>
<li>
<a href=#contextual-where-clauses aria-label="Contextual Where Clauses">Contextual Where Clauses</a></li>
<li>
<a href=#associated-type-with-a-generic-where-clause aria-label="Associated Type with a Generic Where Clause">Associated Type with a Generic Where Clause</a></li>
<li>
<a href=#generic-subscripts aria-label="Generic Subscripts">Generic Subscripts</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>Write code in a more abstract way. It make the code flexible and more reusable.</p>
<p><code>Array</code> and <code>Dictionary</code> types are both generic collections.</p>
<h2 id=the-problem-that-generics-solve>The Problem That Generics Solve<a hidden class=anchor aria-hidden=true href=#the-problem-that-generics-solve>#</a></h2>
<p>If the code with no generics:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>swapTwoInts</span>(<span style=color:#66d9ef>_</span> a: <span style=color:#66d9ef>inout</span> Int, <span style=color:#66d9ef>_</span> b: <span style=color:#66d9ef>inout</span> Int) {
    <span style=color:#66d9ef>let</span> tmp = a
    a = b
    b = tmp
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>swapTwoStrings</span>(<span style=color:#66d9ef>_</span> a: <span style=color:#66d9ef>inout</span> String, <span style=color:#66d9ef>_</span> b: <span style=color:#66d9ef>inout</span> String) {
    <span style=color:#66d9ef>let</span> tmp = a
    a = b
    b = tmp
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>swapTwoDoubles</span>(<span style=color:#66d9ef>_</span> a: <span style=color:#66d9ef>inout</span> Double, <span style=color:#66d9ef>_</span> b: <span style=color:#66d9ef>inout</span> Double) {
    <span style=color:#66d9ef>let</span> tmp = a
    a = b
    b = tmp
}

<span style=color:#75715e>// Use the function</span>
<span style=color:#66d9ef>var</span> aInt = <span style=color:#ae81ff>3</span>, bInt = <span style=color:#ae81ff>4</span>
<span style=color:#66d9ef>var</span> aString = <span style=color:#e6db74>&#34;Mike&#34;</span>, bString = <span style=color:#e6db74>&#34;Amy&#34;</span>
<span style=color:#66d9ef>var</span> aDouble = <span style=color:#ae81ff>1.1</span>, bDouble = <span style=color:#ae81ff>2.5</span>

swapTwoInts(&amp;aInt, &amp;bInt)
swapTwoStrings(&amp;aString, &amp;bString)
swapTwoDoubles(&amp;aDouble, &amp;bDouble)

print(aInt, bInt)
print(aString, bString)
print(aDouble, bDouble)

<span style=color:#75715e>// Print:</span>
<span style=color:#75715e>// 4 3</span>
<span style=color:#75715e>// Amy Mike</span>
<span style=color:#75715e>// 2.5 1.1</span>
</code></pre></div><p>Once the code use generics:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#75715e>// The &lt;T&gt; means that this function will use a generic and the type is T.</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>swapTwoObj</span>&lt;T&gt;(<span style=color:#66d9ef>_</span> a: <span style=color:#66d9ef>inout</span> T, <span style=color:#66d9ef>_</span> b: <span style=color:#66d9ef>inout</span> T) {
    <span style=color:#66d9ef>let</span> tmp = a
    a = b
    b = tmp
}

<span style=color:#75715e>// Use the function</span>
<span style=color:#66d9ef>var</span> aInt = <span style=color:#ae81ff>3</span>, bInt = <span style=color:#ae81ff>4</span>
<span style=color:#66d9ef>var</span> aString = <span style=color:#e6db74>&#34;Mike&#34;</span>, bString = <span style=color:#e6db74>&#34;Amy&#34;</span>
<span style=color:#66d9ef>var</span> aDouble = <span style=color:#ae81ff>1.1</span>, bDouble = <span style=color:#ae81ff>2.5</span>

swapTwoObj(&amp;aInt, &amp;bInt)
swapTwoObj(&amp;aString, &amp;bString)
swapTwoObj(&amp;aDouble, &amp;bDouble)

print(aInt, bInt)
print(aString, bString)
print(aDouble, bDouble)

<span style=color:#75715e>// Print:</span>
<span style=color:#75715e>// 4 3</span>
<span style=color:#75715e>// Amy Mike</span>
<span style=color:#75715e>// 2.5 1.1</span>
</code></pre></div><p>So the generics can clearly reduce the duplicated code when the code do the similar things.</p>
<h2 id=type-parameters>Type Parameters<a hidden class=anchor aria-hidden=true href=#type-parameters>#</a></h2>
<p>We can define more than one generic types in the angle brackets.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>swapTwoObj</span>&lt;T, C, D&gt;(<span style=color:#66d9ef>_</span> a: <span style=color:#66d9ef>inout</span> T, <span style=color:#66d9ef>_</span> b: <span style=color:#66d9ef>inout</span> T, <span style=color:#66d9ef>_</span> c: C, <span style=color:#66d9ef>_</span> d: D) {
    <span style=color:#66d9ef>let</span> tmp = a
    a = b
    b = tmp
}
</code></pre></div><h2 id=generic-types>Generic Types<a hidden class=anchor aria-hidden=true href=#generic-types>#</a></h2>
<p>The generics can be applied to classes, structures and enumerations.</p>
<p>An example that write a generic <code>stack</code> : First In First Out</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stack</span>&lt;T&gt; {
    <span style=color:#66d9ef>var</span> store: [T] = []
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>_</span> element: T) {
        store.append(element)
    }
    
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pop</span>() -&gt; T? {
        <span style=color:#66d9ef>if</span> store.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#66d9ef>var</span> t = store[store.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
            store.remove(at: store.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
            <span style=color:#66d9ef>return</span> t
        }
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    }
    
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isEmpty</span>() -&gt; Bool {
        <span style=color:#66d9ef>return</span> store.count <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>
    }
}

<span style=color:#66d9ef>let</span> stack = Stack&lt;Int&gt;()
stack.push(<span style=color:#ae81ff>4</span>)
stack.push(<span style=color:#ae81ff>22</span>)
stack.push(<span style=color:#ae81ff>6</span>)

<span style=color:#66d9ef>while</span> <span style=color:#f92672>!</span>stack.isEmpty() {
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> e = stack.pop() {
        print(e)
    } <span style=color:#66d9ef>else</span> {
        print(<span style=color:#e6db74>&#34;e is nil&#34;</span>)
    }
}

<span style=color:#75715e>// Print: </span>
<span style=color:#75715e>// 6</span>
<span style=color:#75715e>// 22</span>
<span style=color:#75715e>// 4</span>
</code></pre></div><h2 id=extending-a-genetic-type>Extending a Genetic Type<a hidden class=anchor aria-hidden=true href=#extending-a-genetic-type>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Stack</span> {
    <span style=color:#66d9ef>var</span> topItem: T? {
        <span style=color:#66d9ef>return</span> store.isEmpty ? <span style=color:#66d9ef>nil</span> : store[store.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
    }
}
stack.push(<span style=color:#ae81ff>5</span>)
stack.push(<span style=color:#ae81ff>8</span>)
<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> top = stack.topItem {
    print(top) <span style=color:#75715e>// 8</span>
}
</code></pre></div><h2 id=type-constraints>Type Constraints<a hidden class=anchor aria-hidden=true href=#type-constraints>#</a></h2>
<p>Here we constrain the genetic types that they should conform to the specific protocol.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    <span style=color:#75715e>// function body goes here</span>
}
</code></pre></div><p>Example:</p>
<p>The <code>T: Equatable</code> define that the T must conform to the Equatable protocol so that the T can be compared with <code>==</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findIndex</span>&lt;T: Equatable&gt; (of target: T, <span style=color:#66d9ef>in</span> array: [T]) -&gt; Int? {
    <span style=color:#66d9ef>for</span> (index, value) <span style=color:#66d9ef>in</span> array.enumerated() {
        <span style=color:#66d9ef>if</span> value == target {
            <span style=color:#66d9ef>return</span> index
        }
    }
    <span style=color:#66d9ef>return</span>  <span style=color:#66d9ef>nil</span>
}

<span style=color:#66d9ef>let</span> strings = [<span style=color:#e6db74>&#34;cat&#34;</span>, <span style=color:#e6db74>&#34;dog&#34;</span>, <span style=color:#e6db74>&#34;llama&#34;</span>, <span style=color:#e6db74>&#34;parakeet&#34;</span>, <span style=color:#e6db74>&#34;terrapin&#34;</span>]

<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> foundIndex = findIndex(of: <span style=color:#e6db74>&#34;dog&#34;</span>, <span style=color:#66d9ef>in</span>: strings) {
    print(<span style=color:#e6db74>&#34;Index: </span><span style=color:#e6db74>\(</span>foundIndex<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
}

<span style=color:#75715e>// Print:</span>
<span style=color:#75715e>// Index: 1</span>
</code></pre></div><h2 id=associated-type>Associated Type<a hidden class=anchor aria-hidden=true href=#associated-type>#</a></h2>
<p>The actual type to use for that associated type isn’t specified until the protocol is adopted.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#75715e>// The conforming type must provide these three requirements.</span>
<span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Container</span> {
    associatedtype Item   <span style=color:#75715e>// The actual type will be infered when the append method is implemented.</span>
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>append</span>(<span style=color:#66d9ef>_</span> item: Item)
    <span style=color:#66d9ef>var</span> count: Int { <span style=color:#66d9ef>get</span> }
    <span style=color:#66d9ef>subscript</span>(i: Int) -&gt; Item { <span style=color:#66d9ef>get</span> }
}
</code></pre></div><p>The IntStack implementation</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IntStack</span>: Container {
    <span style=color:#66d9ef>var</span> items: [Int] = []
    <span style=color:#75715e>// It demonstrates the associatedtype.</span>
    <span style=color:#66d9ef>typealias</span> Item = Int
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>_</span> item: Int) {
        items.append(item)
    }
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pop</span>() -&gt; Int {
        <span style=color:#66d9ef>return</span> items.removeLast()
    }
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>append</span>(<span style=color:#66d9ef>_</span> item: Int) {
        push(item)
    }
    
    <span style=color:#66d9ef>var</span> count: Int {
        items.count
    }
    
    <span style=color:#66d9ef>subscript</span>(i: Int) -&gt; Int {
        items[i]
    }
    
}
</code></pre></div><p>The generic stack conform to the container.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Stack</span>&lt;Element&gt;: Container {
    <span style=color:#66d9ef>var</span> items: [Element] = []
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>_</span> item: Element) {
        items.append(item)
    }
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pop</span>() -&gt; Element{
        <span style=color:#66d9ef>return</span> items.removeLast()
    }
    
    <span style=color:#75715e>// It implements the appen(_: ) requirement, Swift can therefore infer that Element is the associatedtype for the contaioner.</span>
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>append</span>(<span style=color:#66d9ef>_</span> item: Element) {
        push(item)
    }
    <span style=color:#66d9ef>var</span> count: Int {
        items.count
    }
    <span style=color:#66d9ef>subscript</span>(i: Int) -&gt; Element {
        <span style=color:#66d9ef>return</span> items[i]
    }
}
</code></pre></div><h3 id=extending-an-existing-type-to-specify-an-associated-type>Extending an Existing Type to Specify an Associated Type<a hidden class=anchor aria-hidden=true href=#extending-an-existing-type-to-specify-an-associated-type>#</a></h3>
<p>Swift’s <code>Array</code> type already provides <code>append(_: )</code>, <code>count</code>, <code>subscript</code>. This means that we can extend <code>Array</code> to conform the Container protocol.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Array</span>: Container {}
</code></pre></div><h3 id=adding-constraints-to-an-associated-type>Adding Constraints to an Associated Type<a hidden class=anchor aria-hidden=true href=#adding-constraints-to-an-associated-type>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Container</span> {
    associatedtype Item: Equatable <span style=color:#75715e>// Here the Item conform to the Equatable is a constraints</span>
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>append</span>(<span style=color:#66d9ef>_</span> item: Item)
    <span style=color:#66d9ef>var</span> count: Int { <span style=color:#66d9ef>get</span> }
    <span style=color:#66d9ef>subscript</span>(i: Int) -&gt; Item { <span style=color:#66d9ef>get</span> }
}
</code></pre></div><h3 id=using-a-protocol-in-its-associated-types-constraints>Using a Protocol in its Associated Type’s Constraints<a hidden class=anchor aria-hidden=true href=#using-a-protocol-in-its-associated-types-constraints>#</a></h3>
<p>Here using the custom protocol <code>SuffixableContainer</code> in its constraints.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>SuffixableContainer</span>: Container {
    <span style=color:#75715e>// It defines an associatedtype named Suffix and its Item type must be the same as the container&#39;s Item type.</span>
    associatedtype Suffix: SuffixableContainer <span style=color:#f92672>*</span><span style=color:#66d9ef>where</span><span style=color:#f92672>*</span> Suffix.Item == Item  <span style=color:#75715e>// Use　the protocol suffixableContainer to constrain the associated type. </span>
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>suffix</span>(<span style=color:#66d9ef>_</span> size: Int) -&gt; Suffix
}

<span style=color:#75715e>// The extension </span>
<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Stack</span>: SuffixableContainer {
    <span style=color:#75715e>// It implement the method, and Swift infer that Suffix is Stack.</span>
    <span style=color:#66d9ef>func</span>  <span style=color:#a6e22e>suffix</span>(<span style=color:#66d9ef>_</span> size: Int) -&gt; Stack{
        <span style=color:#66d9ef>var</span> result = Stack()
        <span style=color:#66d9ef>for</span> index <span style=color:#66d9ef>in</span> (count <span style=color:#f92672>-</span> size)..&lt;count {
            result.append(<span style=color:#66d9ef>self</span>[index])
        }
        <span style=color:#66d9ef>return</span> result
    }
}

<span style=color:#66d9ef>var</span> stackOfInt = Stack&lt;Int&gt;()
stackOfInt.push(<span style=color:#ae81ff>3</span>)
stackOfInt.push(<span style=color:#ae81ff>6</span>)
stackOfInt.push(<span style=color:#ae81ff>9</span>)
<span style=color:#66d9ef>let</span> suffix = stackOfInt.suffix(<span style=color:#ae81ff>2</span>)
print(suffix)

<span style=color:#75715e>// Print:</span>
<span style=color:#75715e>// Stack&lt;Int&gt;(items: [6, 9])</span>
</code></pre></div><h2 id=generic-where-clauses>Generic Where Clauses<a hidden class=anchor aria-hidden=true href=#generic-where-clauses>#</a></h2>
<p>A generic <code>where</code> clause require that an associated type must conform to a certain protocol, or that the certain type parameters and associated types must be the same.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>allItemMatch</span>&lt;C1: Container, C2: Container&gt;(<span style=color:#66d9ef>_</span> container: C1, <span style=color:#66d9ef>_</span> anotherContainer: C2) -&gt; Bool <span style=color:#66d9ef>where</span> C1.Item == C2.Item, C1.Item: Equatable {
    <span style=color:#75715e>// Check if two container&#39;s count equal.</span>
    <span style=color:#66d9ef>if</span> container.count <span style=color:#f92672>!=</span> anotherContainer.count {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
    }
    <span style=color:#75715e>// Check each item pairs to see if they are equivalent.</span>
    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;container.count {
        <span style=color:#66d9ef>if</span> container[i] <span style=color:#f92672>!=</span> anotherContainer[i] {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
        }
    }
    
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
</code></pre></div><p>We already extends the array with the code **<code>extension** Array: Container {}</code> before, now both the <code>Stack&lt;String></code> and <code>Array</code>  are conform to the <code>Container</code>, so they can be the parameter for the method <code>allItemMatch</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>var</span> stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push(<span style=color:#e6db74>&#34;uno&#34;</span>)
stackOfStrings.push(<span style=color:#e6db74>&#34;dos&#34;</span>)
stackOfStrings.push(<span style=color:#e6db74>&#34;tree&#34;</span>)

<span style=color:#66d9ef>var</span> arrayOfStrings = [<span style=color:#e6db74>&#34;uno&#34;</span>, <span style=color:#e6db74>&#34;dos&#34;</span>, <span style=color:#e6db74>&#34;tree&#34;</span>]

<span style=color:#75715e>// Now C1 is Stack&lt;String&gt; and C2 is Array</span>
<span style=color:#66d9ef>if</span> allItemMatch(stackOfStrings, arrayOfStrings) {
    print(<span style=color:#e6db74>&#34;Matched&#34;</span>)
} <span style=color:#66d9ef>else</span> {
    print(<span style=color:#e6db74>&#34;Not match&#34;</span>)
}
</code></pre></div><h2 id=extension-with-a-generic-where-clause>Extension with a Generic Where Clause<a hidden class=anchor aria-hidden=true href=#extension-with-a-generic-where-clause>#</a></h2>
<p>It means that the extension have some condition to be valid. If the stack whose elements aren’t equatable and it try to call the <code>isTop(_ :)</code> , it will trigger a compile-time error.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>var</span> stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push(<span style=color:#e6db74>&#34;uno&#34;</span>)
stackOfStrings.push(<span style=color:#e6db74>&#34;dos&#34;</span>)
stackOfStrings.push(<span style=color:#e6db74>&#34;tree&#34;</span>)

<span style=color:#75715e>// The extension only be vaild where the element conform to the Equatable protocol.</span>
<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Stack</span> <span style=color:#66d9ef>where</span> Element: Equatable {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isTop</span>(<span style=color:#66d9ef>_</span> item: Element) -&gt; Bool {
        <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> topItem = items.last <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
        }
        <span style=color:#66d9ef>return</span> topItem == item
    }
}

print(stackOfStrings.isTop(<span style=color:#e6db74>&#34;tree&#34;</span>))
</code></pre></div><p>We can also use generic <code>where</code> clause with extension to a protocol.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Container</span> <span style=color:#66d9ef>where</span> Item: Equatable {
    <span style=color:#66d9ef>func</span>  <span style=color:#a6e22e>startWith</span>(<span style=color:#66d9ef>_</span> item: Item) -&gt; Bool {
        <span style=color:#66d9ef>return</span> count <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>self</span>[<span style=color:#ae81ff>0</span>] == item
    }
}
</code></pre></div><p>We can also constrain the extension’s generic type must be a specific type. Only when the condition is satisfied, the extension can be valid.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Container</span> <span style=color:#66d9ef>where</span> Item == Double {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>average</span>() -&gt; Double {
        <span style=color:#66d9ef>var</span> sum = <span style=color:#ae81ff>0.0</span>
        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;count {
            sum <span style=color:#f92672>+=</span> <span style=color:#66d9ef>self</span>[i]
        }
        <span style=color:#66d9ef>return</span>  sum <span style=color:#f92672>/</span> Double(count)
    }
    
}

print([<span style=color:#ae81ff>11.2</span>, <span style=color:#ae81ff>5.3</span>, <span style=color:#ae81ff>3.2</span>].average()) <span style=color:#75715e>// 6.566666666666666</span>
</code></pre></div><h2 id=contextual-where-clauses>Contextual Where Clauses<a hidden class=anchor aria-hidden=true href=#contextual-where-clauses>#</a></h2>
<p>Use the condition to constrain only the method. These method only be available when the condition is satisfied.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Container</span> {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>average</span>() -&gt; Double <span style=color:#66d9ef>where</span> Item == Int {
        <span style=color:#66d9ef>var</span> sum = <span style=color:#ae81ff>0.0</span>
        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;count {
            sum <span style=color:#f92672>+=</span> Double(<span style=color:#66d9ef>self</span>[i])
        }
        <span style=color:#66d9ef>return</span>  sum <span style=color:#f92672>/</span> Double(count)
    }
    
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>endsWith</span>(<span style=color:#66d9ef>_</span> item: Item) -&gt; Bool <span style=color:#66d9ef>where</span> Item: Equatable{
        <span style=color:#66d9ef>return</span> count <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>self</span>[count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] == item
    }
}
</code></pre></div><p>The same behavior implemented in another way. Moving those requirement in different extensions.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Container</span> <span style=color:#66d9ef>where</span> Item == Int {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>average</span>() -&gt; Double {
        <span style=color:#66d9ef>var</span> sum = <span style=color:#ae81ff>0.0</span>
        <span style=color:#66d9ef>for</span> index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.&lt;count {
            sum <span style=color:#f92672>+=</span> Double(<span style=color:#66d9ef>self</span>[index])
        }
        <span style=color:#66d9ef>return</span> sum <span style=color:#f92672>/</span> Double(count)
    }
}
<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Container</span> <span style=color:#66d9ef>where</span> Item: Equatable {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>endsWith</span>(<span style=color:#66d9ef>_</span> item: Item) -&gt; Bool {
        <span style=color:#66d9ef>return</span> count <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>self</span>[count<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] == item
    }
}
</code></pre></div><p>Two way to do the <code>where</code> clause above have the same behavior. They activate the specific requirements when the condition is satisfied. However, the contextual <code>where</code> clause only need one extension, and the extensions’ generic <code>where</code> clause will require one extension for per requirement.</p>
<h2 id=associated-type-with-a-generic-where-clause>Associated Type with a Generic Where Clause<a hidden class=anchor aria-hidden=true href=#associated-type-with-a-generic-where-clause>#</a></h2>
<p>Here we define the <code>Iterator</code> conform to the <code>IteratorProtocol</code> where the type <code>Iterator.Element</code> is the same as <code>Item</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>protocol</span>  <span style=color:#a6e22e>Container</span> {
    associatedtype Item
    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>append</span>(<span style=color:#66d9ef>_</span> item: Item) 
    <span style=color:#66d9ef>var</span> count: Int { <span style=color:#66d9ef>get</span> }
    <span style=color:#66d9ef>subscript</span>(i: Int) -&gt; Item { <span style=color:#66d9ef>get</span> }
    associatedtype Iterator: IteratorProtocol <span style=color:#66d9ef>where</span> Iterator.Element == Item
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeIterator</span>() -&gt; Iterator
}
</code></pre></div><p>We can add a constraint to an inherited associated type by including the generic <code>where</code>
 clause in the protocol declaration.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>protocol</span>  <span style=color:#a6e22e>ComparableContainer</span>: Container <span style=color:#66d9ef>where</span> Item: Comparable {}
</code></pre></div><h2 id=generic-subscripts>Generic Subscripts<a hidden class=anchor aria-hidden=true href=#generic-subscripts>#</a></h2>
<p>Use the <code>where</code> to constrain.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Container</span> {
    <span style=color:#66d9ef>subscript</span>&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item] <span style=color:#66d9ef>where</span> Indices.Iterator.Element == Int{
        <span style=color:#66d9ef>var</span> result: [Item] = []
        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> indices {
            result.append(<span style=color:#66d9ef>self</span>[i])
        }
        <span style=color:#66d9ef>return</span>  result
    }
}
</code></pre></div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://1-1.link/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://1-1.link/post/language/swift/24opaque-type/>
<span class=title>« Prev</span>
<br>
<span>Opaque Type</span>
</a>
<a class=next href=https://1-1.link/post/language/swift/16optional-chaining/>
<span class=title>Next »</span>
<br>
<span>Optional Chaining</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics on twitter" href="https://twitter.com/intent/tweet/?text=Generics&url=https%3a%2f%2f1-1.link%2fpost%2flanguage%2fswift%2f23generics%2f&hashtags=%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f1-1.link%2fpost%2flanguage%2fswift%2f23generics%2f&title=Generics"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Generics on telegram" href="https://telegram.me/share/url?text=Generics&url=https%3a%2f%2f1-1.link%2fpost%2flanguage%2fswift%2f23generics%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=https://1-1.link>CodePaper</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>