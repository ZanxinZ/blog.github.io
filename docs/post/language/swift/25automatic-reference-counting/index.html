<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Automatic Reference Counting | CodePaper</title>
<meta name=keywords content="编程语言">
<meta name=description content="Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.
Reference counting applies only to instance of classes.
Reference:
 strong: retain the obj. (default) weak: don’t retain the object referred to, track the object referred to. unowned: don’t retain the object referred to, don’t tract the object referred to.  How ARC Work Allocate a chunk of memory to store information about that instance">
<meta name=author content>
<link rel=canonical href=https://1-1.link/post/language/swift/25automatic-reference-counting/>
<link crossorigin=anonymous href=/assets/css/stylesheet.ea5f2fd568f688f106fb918bfebdccb965b2f6ecb642824b56e5e0a12f25311c.css integrity="sha256-6l8v1Wj2iPEG+5GL/r3MuWWy9uy2QoJLVuXgoS8lMRw=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://1-1.link/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://1-1.link/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://1-1.link/favicon-32x32.png>
<link rel=apple-touch-icon href=https://1-1.link/apple-touch-icon.png>
<link rel=mask-icon href=https://1-1.link/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Automatic Reference Counting">
<meta property="og:description" content="Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.
Reference counting applies only to instance of classes.
Reference:
 strong: retain the obj. (default) weak: don’t retain the object referred to, track the object referred to. unowned: don’t retain the object referred to, don’t tract the object referred to.  How ARC Work Allocate a chunk of memory to store information about that instance">
<meta property="og:type" content="article">
<meta property="og:url" content="https://1-1.link/post/language/swift/25automatic-reference-counting/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-06-12T16:00:40+08:00">
<meta property="article:modified_time" content="2022-06-12T16:00:40+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Automatic Reference Counting">
<meta name=twitter:description content="Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.
Reference counting applies only to instance of classes.
Reference:
 strong: retain the obj. (default) weak: don’t retain the object referred to, track the object referred to. unowned: don’t retain the object referred to, don’t tract the object referred to.  How ARC Work Allocate a chunk of memory to store information about that instance">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"Automatic Reference Counting","item":"https://1-1.link/post/language/swift/25automatic-reference-counting/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Automatic Reference Counting","name":"Automatic Reference Counting","description":"Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.\nReference counting applies only to instance of classes.\nReference:\n strong: retain the obj. (default) weak: don’t retain the object referred to, track the object referred to. unowned: don’t retain the object referred to, don’t tract the object referred to.  How ARC Work Allocate a chunk of memory to store information about that instance","keywords":["编程语言"],"articleBody":"Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.\nReference counting applies only to instance of classes.\nReference:\n strong: retain the obj. (default) weak: don’t retain the object referred to, track the object referred to. unowned: don’t retain the object referred to, don’t tract the object referred to.  How ARC Work Allocate a chunk of memory to store information about that instance\n type of the instance values of any stored properties associated with that instance.  To make sure that instance don’t disappear while they’re needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance.\nTo make this possible, whenever assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance. The “strong” reference keeps a firm hold on that instance, and doesn’t allow it to be deallocated for as long as that strong reference remains.\nARC in Action Here we define a class name Person. Then we define three variables of type Person?, they’re automatically initialized with a value of nil, and don’t currently reference a Person instance.\nclass Person { let name: String init(name: String) { self.name = name print(\"Person build: \\(name)\") } deinit { print(\"Person deallocated: \\(name)\") } } var p1: Person? var p2: Person? var p3: Person? And we can create a new Person instance and assign it one of these three variables.\np1 = Person(name: \"Mile\") // Now it starts the initializor, and prints the content. // Print: Person build: Mile We can set other reference to p1\np2 = p1 // The assign of reference don't call the initializer. p3 = p1 // now there are three strong reference to the single Person instance. If assign other two reference with nil, the instance still has one strong reference (p1), the instance isn’t deallocated.\np1 = nil p2 = nil // The instance isn't deallocated yet. If the only one last reference is broken, the instance will be deallocated.\np3 = nil // Print: Person deallocated: Mile // Now the instacne has no reference, and it's deallocated (When the instance is forgot by all of others, it will leave forever) Resolving Strong Reference Cycle Between Class Instance If two class instance hold a strong reference to each other, it’s called strong reference cycle. The solution of the strong reference cycle is to define the reference as weak or unowned.\nProblem In the function test(), the instance obj has a strong reference of type B, and the instance anotherObj has a strong reference of type A. Normally, after the obj and the anotherObj are assigned as nil, the instance A() and B() built should be recycle when the reference count is zero. But in fact, they are not be recycle (The de-initializer of them haven’t been called). They hold on the reference of each other and can not be deallocated by ARC.\nclass A { var b: B? deinit { print(\"Deinit A\") } } class B { var a: A? deinit { print(\"Deinit B\") } } var obj: A? = A() var anotherObj: B? = B() obj!.b = anotherObj anotherObj!.a = obj obj = nil anotherObj = nil // Two instance haven't been deallocated yet. Solution Change the one of the strong reference to be weak reference.\nclass A { var b: B? deinit { print(\"Deinit A\") } } class B { weak var a: A? deinit { print(\"Deinit B\") } } // So with the code below, the instances of A and B will be deallocated. var obj: A? = A() var anotherObj: B? = B() obj!.b = anotherObj anotherObj!.a = obj obj = nil anotherObj = nil // Print:  // Deinit A // Deinit B Solution with Unowned Reference  Weak references must be typed as Optional; they do not retain the object referred to, but they track the object referred to, and revert to nil if that object goes out of existence. Unowned references do not retain the object referred to and do not track the object referred to, so it’s up to you to prevent that object from going out of existence or you may end up with a dangling pointer and a crash.  class A { var b: B? deinit { print(\"Deinit A\") } } class B { unowned var a: A? deinit { print(\"Deinit B\") } } Unowned References and Implicitly Unwrapped Optional Properties class Country { let name: String var capitalCity: City! init(name: String, capitalName: String) { self.name = name self.capitalCity = City(name: capitalName, country: self) } } class City { let name: String unowned let country: Country init(name: String, country: Country) { self.name = name self.country = country } } // Now we can access the capital name of the country directly. var country = Country(name: \"Canada\", capitalName: \"Ottawa\") print(\"\\(country.name)capital : \\(country.capitalCity.name)\") // Print: Canada capital : Ottawa Strong Reference Cycles for Closures When assign a closure to a property, we are assigning a reference to that closure. So if we use both strong references, the class instance and a closure will keep each other alive.\nThe more Elegant Solution: Closure Capture List Here the asHTML is a closure property rather than an instance method, we can replace the default value of it with a custom closure.\nclass HTMLElement { let name: String let text: String? // Using the lazy, makes the closure can use the \"self\" // The lazy property will not be accessed until  //after initialization has been complete and \"self\" is konwn. lazy var asHTML: () - String = { if let text = self.text { return \"\\(self.name)\\(text)\\(self.name)\" } else { return \"\\(self.name)/\" } } init(name: String, text: String? = nil) { self.name = name self.text = text } deinit { print(\"\\(name)is being deinitialized\") } } let heading = HTMLElement(name: \"h1\") let defaultText = \"Some default text\" // Pass a custom closure to set the asHTML property. heading.asHTML = { return \"\\(heading.name)\\(heading.text ?? defaultText)\\(heading.name)\" } print(heading.asHTML()) // Some default text Test the strong reference circle.\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"Hello world!\") print(paragraph!.asHTML()) paragraph = nil // Now the instance that paragraph hasn't beem deallocated (The meassage of deinit isn't print),  // because of the strong reference circle between the instance of HTMLElement and the closure . Resolving Strong Reference Cycles for Closures Solution: defining a capture list as part of the closure’s definition. Declare each captured reference to be a weak or unowned reference rather than a strong reference.\nA capture list defines the rules to use when capturing one or more reference types within the closure’s body.\nCapture list definition\nlazy var someClosure = { [unowned self, weak delegate = self.delegate] (index: Int, stringToProcess: String) - String in // closure body goes here } // If the closure hasn't specific parameter lazy var someClosure = { [unowned self, weak delegate = self.delegate] in // closure body goes here } Correct the HTMLElement by capture list [unowned self]\nclass HTMLElement { let name: String let text: String? lazy var asHTML: () - String = { [unowned self] in if let text = self.text { return \"\\(self.name)\\(text)\\(self.name)\" } else { return \"\\(self.name)/\" } } init(name: String, text: String? = nil) { self.name = name self.text = text } deinit { print(\"\\(name)is being deinitialized\") } } var paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"Hello world!\") print(paragraph!.asHTML()) paragraph = nil // Print:  // Hello world!\n // p is being deinitialized // Up to here, now the instance of type HTMLElement is deallocated. The relationship between the HTMLElement and closure is just like the hen and the egg. If they both hold the strong reference, it’s hard to say which one has the priority to destroy the hen. And with the capture list, the HTMLElement (hen) has a strong reference link to the closure, and the closure (egg) just have a unowned reference link to the hen.\n","wordCount":"1324","inLanguage":"en","datePublished":"2022-06-12T16:00:40+08:00","dateModified":"2022-06-12T16:00:40+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://1-1.link/post/language/swift/25automatic-reference-counting/"},"publisher":{"@type":"Organization","name":"CodePaper","logo":{"@type":"ImageObject","url":"https://1-1.link/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://1-1.link accesskey=h title="CodePaper (Alt + H)">CodePaper</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://1-1.link/archive/ title=档案>
<span>档案</span>
</a>
</li>
<li>
<a href=https://1-1.link/categories/ title=类别>
<span>类别</span>
</a>
</li>
<li>
<a href=https://1-1.link/tags/ title=标签>
<span>标签</span>
</a>
</li>
<li>
<a href=https://1-1.link/search/ title="搜索 (Alt + /)" accesskey=/>
<span>搜索</span>
</a>
</li>
<li>
<a href=https://1-1.link/about/ title=关于我>
<span>关于我</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://1-1.link>Home</a></div>
<h1 class=post-title>
Automatic Reference Counting
</h1>
<div class=post-meta><span title="2022-06-12 16:00:40 +0800 CST">June 12, 2022</span>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#how-arc-work aria-label="How ARC Work">How ARC Work</a></li>
<li>
<a href=#arc-in-action aria-label="ARC in Action">ARC in Action</a></li>
<li>
<a href=#resolving-strong-reference-cycle-between-class-instance aria-label="Resolving Strong Reference Cycle Between Class Instance">Resolving Strong Reference Cycle Between Class Instance</a><ul>
<li>
<a href=#problem aria-label=Problem>Problem</a></li>
<li>
<a href=#solution aria-label=Solution>Solution</a></li>
<li>
<a href=#solution-with-unowned-reference aria-label="Solution with Unowned Reference">Solution with Unowned Reference</a></li>
<li>
<a href=#unowned-references-and-implicitly-unwrapped-optional-properties aria-label="Unowned References and Implicitly Unwrapped Optional Properties">Unowned References and Implicitly Unwrapped Optional Properties</a></li></ul>
</li>
<li>
<a href=#strong-reference-cycles-for-closures aria-label="Strong Reference Cycles for Closures">Strong Reference Cycles for Closures</a><ul>
<li>
<a href=#the-more-elegant-solution-closure-capture-list aria-label="The more Elegant Solution: Closure Capture List">The more Elegant Solution: Closure Capture List</a></li>
<li>
<a href=#resolving-strong-reference-cycles-for-closures aria-label="Resolving Strong Reference Cycles for Closures">Resolving Strong Reference Cycles for Closures</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>Swift use ARC to track and manage the app’s memory usage. ARC frees up the memory used by class instances when those instances are no longer needed.</p>
<p>Reference counting <strong>applies only to instance of classes.</strong></p>
<p>Reference:</p>
<ul>
<li>strong: retain the obj. (default)</li>
<li>weak: don’t retain the object referred to, track the object referred to.</li>
<li>unowned: don’t retain the object referred to, don’t tract the object referred to.</li>
</ul>
<h2 id=how-arc-work>How ARC Work<a hidden class=anchor aria-hidden=true href=#how-arc-work>#</a></h2>
<p>Allocate a chunk of memory to store information about that instance</p>
<ul>
<li>type of the instance</li>
<li>values of any stored properties associated with that instance.</li>
</ul>
<p>To make sure that instance don’t disappear while they’re needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance.</p>
<p>To make this possible, whenever assign a class instance to a property, constant, or variable, that property, constant, or variable makes a <em>strong reference</em> to the instance. The “strong” reference <strong>keeps a firm hold</strong> on that instance, and doesn’t allow it to be deallocated for as long as that strong reference remains.</p>
<h2 id=arc-in-action>ARC in Action<a hidden class=anchor aria-hidden=true href=#arc-in-action>#</a></h2>
<p>Here we define a class name Person. Then we define three variables of type <code>Person?</code>, they’re automatically initialized with a value of <code>nil</code>, and don’t currently reference a <code>Person</code> instance.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>init</span>(name: String) {
        <span style=color:#66d9ef>self</span>.name = name
        print(<span style=color:#e6db74>&#34;Person build: </span><span style=color:#e6db74>\(</span>name<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
    }
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;Person deallocated: </span><span style=color:#e6db74>\(</span>name<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
    }
}

<span style=color:#66d9ef>var</span> p1: Person?
<span style=color:#66d9ef>var</span> p2: Person?
<span style=color:#66d9ef>var</span> p3: Person?
</code></pre></div><p>And we can create a new <code>Person</code> instance and assign it one of these three variables.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>p1 = Person(name: <span style=color:#e6db74>&#34;Mile&#34;</span>) <span style=color:#75715e>// Now it starts the initializor, and prints the content.</span>
<span style=color:#75715e>// Print: Person build: Mile</span>
</code></pre></div><p>We can set other reference to <code>p1</code></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>p2 = p1 <span style=color:#75715e>// The assign of reference don&#39;t call the initializer.</span>
p3 = p1

<span style=color:#75715e>// now there are three strong reference to the single Person instance.</span>
</code></pre></div><p>If assign other two reference with <code>nil</code>, the instance still has one strong reference (<code>p1</code>), the instance isn’t deallocated.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>p1 = <span style=color:#66d9ef>nil</span>
p2 = <span style=color:#66d9ef>nil</span>
<span style=color:#75715e>// The instance isn&#39;t deallocated yet.</span>
</code></pre></div><p>If the only one last reference is broken, the instance will be deallocated.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>p3 = <span style=color:#66d9ef>nil</span>
<span style=color:#75715e>// Print: Person deallocated: Mile</span>

<span style=color:#75715e>// Now the instacne has no reference, and it&#39;s deallocated (When the instance is forgot by all of others, it will leave forever)</span>
</code></pre></div><h2 id=resolving-strong-reference-cycle-between-class-instance>Resolving Strong Reference Cycle Between Class Instance<a hidden class=anchor aria-hidden=true href=#resolving-strong-reference-cycle-between-class-instance>#</a></h2>
<p>If two class instance hold a strong reference to each other, it’s called <em>strong reference cycle</em>. The solution of the strong reference cycle is to define the reference as <code>weak</code> or <code>unowned</code>.</p>
<h3 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h3>
<p>In the function <code>test()</code>, the instance <code>obj</code> has a strong reference of type <code>B</code>, and the instance <code>anotherObj</code> has a strong reference of type <code>A</code>. Normally, after the obj and the anotherObj are assigned as <code>nil</code>, the instance <code>A()</code> and <code>B()</code> built should be recycle when the reference count is zero. But in fact, they are not be recycle (The de-initializer of them haven’t been called). They hold on the reference of each other and can not be deallocated by ARC.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
    <span style=color:#66d9ef>var</span> b: B?
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;Deinit A&#34;</span>)
    }
}
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
    <span style=color:#66d9ef>var</span> a: A?
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;Deinit B&#34;</span>)
    }
}

<span style=color:#66d9ef>var</span> obj: A? = A()
<span style=color:#66d9ef>var</span> anotherObj: B? = B()

obj!.b = anotherObj
anotherObj!.a = obj

obj = <span style=color:#66d9ef>nil</span>
anotherObj = <span style=color:#66d9ef>nil</span>

<span style=color:#75715e>// Two instance haven&#39;t been deallocated yet.</span>
</code></pre></div><h3 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h3>
<p>Change the one of the strong reference to be <code>weak</code> reference.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
    <span style=color:#66d9ef>var</span> b: B?
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;Deinit A&#34;</span>)
    }
}
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
    <span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>var</span> a: A?
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;Deinit B&#34;</span>)
    }
}

<span style=color:#75715e>// So with the code below, the instances of A and B will be deallocated.</span>
<span style=color:#66d9ef>var</span> obj: A? = A()
<span style=color:#66d9ef>var</span> anotherObj: B? = B()

obj!.b = anotherObj
anotherObj!.a = obj

obj = <span style=color:#66d9ef>nil</span>
anotherObj = <span style=color:#66d9ef>nil</span>

<span style=color:#75715e>// Print: </span>
<span style=color:#75715e>// Deinit A</span>
<span style=color:#75715e>// Deinit B</span>
</code></pre></div><h3 id=solution-with-unowned-reference>Solution with Unowned Reference<a hidden class=anchor aria-hidden=true href=#solution-with-unowned-reference>#</a></h3>
<ul>
<li>Weak references must be typed as Optional; they do not retain the object referred to, but they <strong>track the object referred to</strong>, and revert to <code>nil</code> if that object goes out of existence.</li>
<li>Unowned references do not retain the object referred to and <strong>do not track the object referred to</strong>, so it&rsquo;s up to you to prevent that object from going out of existence or you may end up with a dangling pointer and a crash.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
    <span style=color:#66d9ef>var</span> b: B?
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;Deinit A&#34;</span>)
    }
}
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
    <span style=color:#66d9ef>unowned</span> <span style=color:#66d9ef>var</span> a: A?
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;Deinit B&#34;</span>)
    }
}
</code></pre></div><h3 id=unowned-references-and-implicitly-unwrapped-optional-properties>Unowned References and Implicitly Unwrapped Optional Properties<a hidden class=anchor aria-hidden=true href=#unowned-references-and-implicitly-unwrapped-optional-properties>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Country</span> {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>var</span> capitalCity: City!
    <span style=color:#66d9ef>init</span>(name: String, capitalName: String) {
        <span style=color:#66d9ef>self</span>.name = name
        <span style=color:#66d9ef>self</span>.capitalCity = City(name: capitalName, country: <span style=color:#66d9ef>self</span>)
    }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>City</span> {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>unowned</span> <span style=color:#66d9ef>let</span> country: Country
    <span style=color:#66d9ef>init</span>(name: String, country: Country) {
        <span style=color:#66d9ef>self</span>.name = name
        <span style=color:#66d9ef>self</span>.country = country
    }
}

<span style=color:#75715e>// Now we can access the capital name of the country directly.</span>
<span style=color:#66d9ef>var</span> country = Country(name: <span style=color:#e6db74>&#34;Canada&#34;</span>, capitalName: <span style=color:#e6db74>&#34;Ottawa&#34;</span>)
print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>country.name<span style=color:#e6db74>)</span><span style=color:#e6db74> capital : </span><span style=color:#e6db74>\(</span>country.capitalCity.name<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>) 
<span style=color:#75715e>// Print: Canada capital : Ottawa</span>
</code></pre></div><h2 id=strong-reference-cycles-for-closures>Strong Reference Cycles for Closures<a hidden class=anchor aria-hidden=true href=#strong-reference-cycles-for-closures>#</a></h2>
<p>When assign a closure to a property, we are assigning a <em>reference</em> to that closure. So if we use both strong references, the class instance and a closure will keep each other alive.</p>
<h3 id=the-more-elegant-solution-closure-capture-list>The more Elegant Solution: Closure Capture List<a hidden class=anchor aria-hidden=true href=#the-more-elegant-solution-closure-capture-list>#</a></h3>
<p>Here the asHTML is a closure property rather than an instance method, we can replace the default value of it with a custom closure.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HTMLElement</span> {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>let</span> text: String?

		<span style=color:#75715e>// Using the lazy, makes the closure can use the &#34;self&#34;</span>
		<span style=color:#75715e>// The lazy property will not be accessed until </span>
    <span style=color:#75715e>//after initialization has been complete and &#34;self&#34; is konwn.</span>
    <span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> asHTML: () -&gt; String = {
        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> text = <span style=color:#66d9ef>self</span>.text {
            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&lt;</span><span style=color:#e6db74>\(</span><span style=color:#66d9ef>self</span>.name<span style=color:#e6db74>)</span><span style=color:#e6db74>&gt;</span><span style=color:#e6db74>\(</span>text<span style=color:#e6db74>)</span><span style=color:#e6db74>&lt;/</span><span style=color:#e6db74>\(</span><span style=color:#66d9ef>self</span>.name<span style=color:#e6db74>)</span><span style=color:#e6db74>&gt;&#34;</span>
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&lt;</span><span style=color:#e6db74>\(</span><span style=color:#66d9ef>self</span>.name<span style=color:#e6db74>)</span><span style=color:#e6db74>/&gt;&#34;</span>
        }
    }
    
    <span style=color:#66d9ef>init</span>(name: String, text: String? = <span style=color:#66d9ef>nil</span>) {
        <span style=color:#66d9ef>self</span>.name = name
        <span style=color:#66d9ef>self</span>.text = text
    }
    
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>name<span style=color:#e6db74>)</span><span style=color:#e6db74> is being deinitialized&#34;</span>)
    }
}

<span style=color:#66d9ef>let</span> heading = HTMLElement(name: <span style=color:#e6db74>&#34;h1&#34;</span>)
<span style=color:#66d9ef>let</span> defaultText = <span style=color:#e6db74>&#34;Some default text&#34;</span>

<span style=color:#75715e>// Pass a custom closure to set the asHTML property.</span>
heading.asHTML = {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&lt;</span><span style=color:#e6db74>\(</span>heading.name<span style=color:#e6db74>)</span><span style=color:#e6db74>&gt;</span><span style=color:#e6db74>\(</span>heading.text ?? defaultText<span style=color:#e6db74>)</span><span style=color:#e6db74>&lt;/</span><span style=color:#e6db74>\(</span>heading.name<span style=color:#e6db74>)</span><span style=color:#e6db74>&gt;&#34;</span>
}

print(heading.asHTML())  <span style=color:#75715e>// &lt;h1&gt;Some default text&lt;/h1&gt;</span>
</code></pre></div><p>Test the strong reference circle.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>var</span> paragraph: HTMLElement? = HTMLElement(name: <span style=color:#e6db74>&#34;p&#34;</span>, text: <span style=color:#e6db74>&#34;Hello world!&#34;</span>)

print(paragraph!.asHTML())

paragraph = <span style=color:#66d9ef>nil</span>
<span style=color:#75715e>// Now the instance that paragraph hasn&#39;t beem deallocated (The meassage of deinit isn&#39;t print), </span>
<span style=color:#75715e>// because of the strong reference circle between the instance of HTMLElement and the closure .</span>
</code></pre></div><h3 id=resolving-strong-reference-cycles-for-closures>Resolving Strong Reference Cycles for Closures<a hidden class=anchor aria-hidden=true href=#resolving-strong-reference-cycles-for-closures>#</a></h3>
<p>Solution: defining a <em>capture list</em> as part of the closure’s definition. Declare each captured reference to be a <code>weak</code> or <code>unowned</code> reference rather than a strong reference.</p>
<p>A capture list defines the rules to use when capturing one or more reference types within the closure’s body.</p>
<p>Capture list definition</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> someClosure = {
    [<span style=color:#66d9ef>unowned</span> <span style=color:#66d9ef>self</span>, <span style=color:#66d9ef>weak</span> delegate = <span style=color:#66d9ef>self</span>.delegate]
    (index: Int, stringToProcess: String) -&gt; String <span style=color:#66d9ef>in</span>
    <span style=color:#75715e>// closure body goes here</span>
}

<span style=color:#75715e>// If the closure hasn&#39;t specific parameter</span>
<span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> someClosure = {
    [<span style=color:#66d9ef>unowned</span> <span style=color:#66d9ef>self</span>, <span style=color:#66d9ef>weak</span> delegate = <span style=color:#66d9ef>self</span>.delegate] <span style=color:#66d9ef>in</span>
    <span style=color:#75715e>// closure body goes here</span>
}
</code></pre></div><p>Correct the <code>HTMLElement</code> by capture list <code>[unowned self]</code></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HTMLElement</span> {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>let</span> text: String?
    <span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> asHTML: () -&gt; String = {
        [<span style=color:#66d9ef>unowned</span> <span style=color:#66d9ef>self</span>] <span style=color:#66d9ef>in</span>
        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> text = <span style=color:#66d9ef>self</span>.text {
            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&lt;</span><span style=color:#e6db74>\(</span><span style=color:#66d9ef>self</span>.name<span style=color:#e6db74>)</span><span style=color:#e6db74>&gt;</span><span style=color:#e6db74>\(</span>text<span style=color:#e6db74>)</span><span style=color:#e6db74>&lt;/</span><span style=color:#e6db74>\(</span><span style=color:#66d9ef>self</span>.name<span style=color:#e6db74>)</span><span style=color:#e6db74>&gt;&#34;</span>
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&lt;</span><span style=color:#e6db74>\(</span><span style=color:#66d9ef>self</span>.name<span style=color:#e6db74>)</span><span style=color:#e6db74>/&gt;&#34;</span>
        }
    }
    
    <span style=color:#66d9ef>init</span>(name: String, text: String? = <span style=color:#66d9ef>nil</span>) {
        <span style=color:#66d9ef>self</span>.name = name
        <span style=color:#66d9ef>self</span>.text = text
    }
    
    <span style=color:#66d9ef>deinit</span> {
        print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>name<span style=color:#e6db74>)</span><span style=color:#e6db74> is being deinitialized&#34;</span>)
    }
}

<span style=color:#66d9ef>var</span> paragraph: HTMLElement? = HTMLElement(name: <span style=color:#e6db74>&#34;p&#34;</span>, text: <span style=color:#e6db74>&#34;Hello world!&#34;</span>)

print(paragraph!.asHTML())

paragraph = <span style=color:#66d9ef>nil</span>

<span style=color:#75715e>// Print: </span>
<span style=color:#75715e>// &lt;p&gt;Hello world!&lt;/p&gt;</span>
<span style=color:#75715e>// p is being deinitialized</span>

<span style=color:#75715e>// Up to here, now the instance of type HTMLElement is deallocated.</span>
</code></pre></div><p>The relationship between the <code>HTMLElement</code> and closure is just like the hen and the egg. If they both hold the strong reference, it’s hard to say which one has the priority to destroy the hen. And with the capture list, the <code>HTMLElement</code> (hen) has a strong reference link to the closure, and the closure (egg) just have a <code>unowned</code> reference link to the hen.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://1-1.link/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Automatic Reference Counting on twitter" href="https://twitter.com/intent/tweet/?text=Automatic%20Reference%20Counting&url=https%3a%2f%2f1-1.link%2fpost%2flanguage%2fswift%2f25automatic-reference-counting%2f&hashtags=%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Automatic Reference Counting on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f1-1.link%2fpost%2flanguage%2fswift%2f25automatic-reference-counting%2f&title=Automatic%20Reference%20Counting"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Automatic Reference Counting on telegram" href="https://telegram.me/share/url?text=Automatic%20Reference%20Counting&url=https%3a%2f%2f1-1.link%2fpost%2flanguage%2fswift%2f25automatic-reference-counting%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=https://1-1.link>CodePaper</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>