<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CodePaper</title><meta name=keywords content><meta name=description content="Memory Safety Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.
Here we are talking about the situation that happen on a single thread.
Memory Access var one = 1 // write access to the memory one is stored. print(&#34;\(one)&#34;) // read access from the memory one is stored."><meta name=author content><link rel=canonical href=http://example.org/post/language/swift/25memory-safety/><link crossorigin=anonymous href=/assets/css/stylesheet.6e97a6b79be998515e8c86c68e32a9f7a90e6917f550d2af32568b717f5ca785.css integrity="sha256-bpemt5vpmFFejIbGjjKp96kOaRf1UNKvMlaLcX9cp4U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://example.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://example.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://example.org/favicon-32x32.png><link rel=apple-touch-icon href=http://example.org/apple-touch-icon.png><link rel=mask-icon href=http://example.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content><meta property="og:description" content="Memory Safety Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.
Here we are talking about the situation that happen on a single thread.
Memory Access var one = 1 // write access to the memory one is stored. print(&#34;\(one)&#34;) // read access from the memory one is stored."><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/post/language/swift/25memory-safety/"><meta property="article:section" content="post"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Memory Safety Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.
Here we are talking about the situation that happen on a single thread.
Memory Access var one = 1 // write access to the memory one is stored. print(&#34;\(one)&#34;) // read access from the memory one is stored."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"","item":"http://example.org/post/language/swift/25memory-safety/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Memory Safety Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.\nHere we are talking about the situation that happen on a single thread.\nMemory Access var one = 1 // write access to the memory one is stored. print(\u0026#34;\\(one)\u0026#34;) // read access from the memory one is stored.","keywords":[],"articleBody":"Memory Safety Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.\nHere we are talking about the situation that happen on a single thread.\nMemory Access var one = 1 // write access to the memory one is stored. print(\"\\(one)\") // read access from the memory one is stored. The conflicting access to memory can occur when different part of the code are trying to access the same location in memory at the same time.\nCharacteristics of Memory Access A conflict occurs if two access that meet all of the following conditions:\n At least one is a write access or a nonatomic access. They access the same location in memory. Their duration overlap.  The different between a read and write access is obvious: a write access changes the location in memory, but a read access doesn’t.\nAn operation is atomic if it use only C atomic operation; otherwise it’s nonatomic.\nMost memory access is instantaneous.\nExample: all the read and write accesses in the code below are instantaneous\nfunc addOne(_ number: Int) - Int {  return number + 1 } var num = 2 num = addOne(num) print(num) The different way to access memory:\n instantaneous access: as the code shown below. long-term access: other code can run after a long-term access but before it ends, which is call overlap. A long-term access can overlap with other long-term accesses and instantaneous access.  The situation that overlap appear:\n in-out parameters in functions. mutating methods of a structure.  Conflicting Access to In-Out Parameters A function has long-term write access to all of its in-out parameters. The write access for an in-out parameter starts after all of the non-in-out parameters have been evaluate and lasts for the entire duration of that function call. The in-out write access start in the same order as the parameter appear.\nLong-term write access to in-out parameter   One consequence\nFor long-term write access, we can’t access the original variable that was passed as in-out, even if scoping rules and access control permit it.\nvar step = 1 func increment(_ number: inout Int) { \t// It want to read step and write number  number += step // Here has a read and write overlap, the number and step refer to the same location in memory.  }  increment(\u0026step) // Error conflicting access to \"step\" One way to solve the conflict above is to make a copy of step.\nvar copyOfStep = step // Copy from original. increment(\u0026copyOfStep)// Call function with the copy. step = copyOfStep // Update the original.   Another consequence\nPassing a single variable as the argument for multiple in-out parameter of the same function produces a conflict.\nfunc balance(_ x: inout Int, _ y: inout Int) {  let sum = x + y  x = sum / 2  y = sum / 2 } var a = 20 var b = 10  balance(\u0026a, \u0026b) // It's Ok, there are two write access overlap in time but access different location. balance(\u0026a, \u0026a) // It's conflict, it pass \"a\" to the two in-out parameter, there will be two write access overlap in time and memory.   Conflicting Access to self in Methods A mutating method on a structure has write access to self for the duration of the method call.\nfunc balance(_ x: inout Int, _ y: inout Int) {  var sum = x + y  x = sum / 2  y = sum / 2 }  struct Player {  var name: String  var health: Int  var energy: Int  static let maxHealth = 100  mutating func restorehealth() {  health = Player.maxHealth // Here access the \"self.health\"  }   mutating func shareHealth(with teammate: inout Player) {  balance(\u0026teammate.health, \u0026health)  } }  var oscar = Player(name: \"Oscar\", health: 100, energy: 90) var maria = Player(name: \"Maria\", health: 60, energy: 90) oscar.shareHealth(with: \u0026maria) // It's Ok, different write access to different memory.  oscar.shareHealth(with: \u0026oscar) // Error: conflicting accesses to the same memory (the memory that oscar's health refer to). Conflicting Access to Properties Types like structures, tuples and enumerations are value type, mutating any piece of the value will mutate the whole value, meaning read or write access to one of the properties requires read or write access to the whole value.\nvar holly = Player(name: \"Holly\", health: 10, energy: 10) balance(\u0026holly.health, \u0026holly.energy) // Error, \"holly\" refers to an entire value type, health an energy are two peice of that value,  // the two in-out of the function can't write accees to the overlap memory. However, if the holly in the above example is changed to a local variable instead of a global variable, it can be safe.\nfunc someFunc() {  var holly = Player(name: \"Holly\", health: 10, energy: 10)  balance(\u0026holly.health, \u0026holly.energy) \t// The compiler can prove that memory access is safety because the two stored properties don't interact in any way. }  someFunc() // It's OK. The overlapping access to properties of a structure isn’t always necessary to preserve memory safety. Exclusive access is a stricter requirement than memory safety.\nIt can prove that overlapping access to properties of a structure is safe if the following condition apply:\n Accessing only stored properties of an instance, not computed or class properties. The structure is a local variable, not a global variable. The structure is not capture by any closures, or its captured only by non-escaping closures.  If the compiler can’t prove the access is safe, it doesn’t allow the access.\n","wordCount":"918","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.org/post/language/swift/25memory-safety/"},"publisher":{"@type":"Organization","name":"CodePaper","logo":{"@type":"ImageObject","url":"http://example.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://example.org/ accesskey=h title="CodePaper (Alt + H)">CodePaper</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://example.org/archive/ title=档案><span>档案</span></a></li><li><a href=http://example.org/categories/ title=类别><span>类别</span></a></li><li><a href=http://example.org/tags/ title=标签><span>标签</span></a></li><li><a href=http://example.org/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://example.org/>Home</a></div><h1 class=post-title></h1><div class=post-meta></div></header><div class=post-content><h1 id=memory-safety>Memory Safety<a hidden class=anchor aria-hidden=true href=#memory-safety>#</a></h1><p>Most of the time we don’t have to think about accessing memory, but it’s important to understand where potential conflicts can occur, so we can avoid writing code that has conflicting access to memory.</p><p>Here we are talking about the situation that happen on a single thread.</p><h2 id=memory-access>Memory Access<a hidden class=anchor aria-hidden=true href=#memory-access>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> one = <span style=color:#ae81ff>1</span>     <span style=color:#75715e>// write access to the memory one is stored.</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>one<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>) <span style=color:#75715e>// read access from the memory one is stored.</span>
</span></span></code></pre></div><p>The conflicting access to memory can occur when different part of the code are trying to access the same location in memory at the same time.</p><h3 id=characteristics-of-memory-access>Characteristics of Memory Access<a hidden class=anchor aria-hidden=true href=#characteristics-of-memory-access>#</a></h3><p>A conflict occurs if two access that meet all of the following conditions:</p><ul><li>At least one is a write access or a nonatomic access.</li><li>They access the same location in memory.</li><li>Their duration overlap.</li></ul><p>The different between a read and write access is obvious: a write access changes the location in memory, but a read access doesn’t.</p><p>An operation is <em>atomic</em> if it use only <code>C</code> atomic operation; otherwise it’s nonatomic.</p><p>Most memory access is instantaneous.</p><p>Example: all the read and write accesses in the code below are instantaneous</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addOne</span>(<span style=color:#66d9ef>_</span> number: Int) -&gt; Int {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>  number <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> num = <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>num = addOne(num)
</span></span><span style=display:flex><span>print(num)
</span></span></code></pre></div><p>The different way to access memory:</p><ul><li>instantaneous access: as the code shown below.</li><li>long-term access: other code can run after a long-term access but before it ends, which is call <em>overlap.</em> A long-term access can overlap with other long-term accesses and instantaneous access.</li></ul><p>The situation that overlap appear:</p><ul><li>in-out parameters in functions.</li><li>mutating methods of a structure.</li></ul><h2 id=conflicting-access-to-in-out-parameters>Conflicting Access to In-Out Parameters<a hidden class=anchor aria-hidden=true href=#conflicting-access-to-in-out-parameters>#</a></h2><p>A function has long-term write access to all of its in-out parameters. The write access for an in-out parameter starts after all of the non-in-out parameters have been evaluate and lasts for the entire duration of that function call. The in-out write access start in the same order as the parameter appear.</p><h3 id=long-term-write-access-to-in-out-parameter>Long-term write access to in-out parameter<a hidden class=anchor aria-hidden=true href=#long-term-write-access-to-in-out-parameter>#</a></h3><ul><li><p>One consequence</p><p>For long-term write access, we can’t access the original variable that was passed as in-out, even if scoping rules and access control permit it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> step = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>increment</span>(<span style=color:#66d9ef>_</span> number: <span style=color:#66d9ef>inout</span> Int) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// It want to read step and write number</span>
</span></span><span style=display:flex><span>    number <span style=color:#f92672>+=</span> step  <span style=color:#75715e>// Here has a read and write overlap, the number and step refer to the same location in memory. </span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>increment(&amp;step) <span style=color:#75715e>// Error conflicting access to &#34;step&#34;</span>
</span></span></code></pre></div><p>One way to solve the conflict above is to make a copy of step.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> copyOfStep = step <span style=color:#75715e>// Copy from original.</span>
</span></span><span style=display:flex><span>increment(&amp;copyOfStep)<span style=color:#75715e>// Call function with the copy.</span>
</span></span><span style=display:flex><span>step = copyOfStep     <span style=color:#75715e>// Update the original.</span>
</span></span></code></pre></div></li><li><p>Another consequence</p><p>Passing a single variable as the argument for multiple in-out parameter of the same function produces a conflict.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>balance</span>(<span style=color:#66d9ef>_</span> x: <span style=color:#66d9ef>inout</span> Int, <span style=color:#66d9ef>_</span> y: <span style=color:#66d9ef>inout</span> Int) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sum = x <span style=color:#f92672>+</span> y
</span></span><span style=display:flex><span>    x = sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    y = sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> a = <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> b = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>balance(&amp;a, &amp;b)  <span style=color:#75715e>// It&#39;s Ok, there are two write access overlap in time but access different location.</span>
</span></span><span style=display:flex><span>balance(&amp;a, &amp;a)  <span style=color:#75715e>// It&#39;s conflict, it pass &#34;a&#34; to the two in-out parameter, there will be two write access overlap in time and memory.</span>
</span></span></code></pre></div></li></ul><h2 id=conflicting-access-to-self-in-methods>Conflicting Access to self in Methods<a hidden class=anchor aria-hidden=true href=#conflicting-access-to-self-in-methods>#</a></h2><p>A mutating method on a structure has write access to <code>self</code> for the duration of the method call.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>balance</span>(<span style=color:#66d9ef>_</span> x: <span style=color:#66d9ef>inout</span> Int, <span style=color:#66d9ef>_</span> y: <span style=color:#66d9ef>inout</span> Int) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> sum = x <span style=color:#f92672>+</span> y
</span></span><span style=display:flex><span>    x = sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    y = sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Player</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> name: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> health: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> energy: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> maxHealth = <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>restorehealth</span>() {
</span></span><span style=display:flex><span>        health = Player.maxHealth <span style=color:#75715e>// Here access the &#34;self.health&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>shareHealth</span>(with teammate: <span style=color:#66d9ef>inout</span> Player) {
</span></span><span style=display:flex><span>        balance(&amp;teammate.health, &amp;health)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> oscar = Player(name: <span style=color:#e6db74>&#34;Oscar&#34;</span>, health: <span style=color:#ae81ff>100</span>, energy: <span style=color:#ae81ff>90</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> maria = Player(name: <span style=color:#e6db74>&#34;Maria&#34;</span>, health: <span style=color:#ae81ff>60</span>, energy: <span style=color:#ae81ff>90</span>)
</span></span><span style=display:flex><span>oscar.shareHealth(with: &amp;maria) <span style=color:#75715e>// It&#39;s Ok, different write access to different memory.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>oscar.shareHealth(with: &amp;oscar) <span style=color:#75715e>// Error: conflicting accesses to the same memory (the memory that oscar&#39;s health refer to).</span>
</span></span></code></pre></div><h2 id=conflicting-access-to-properties>Conflicting Access to Properties<a hidden class=anchor aria-hidden=true href=#conflicting-access-to-properties>#</a></h2><p>Types like structures, tuples and enumerations are value type, mutating any piece of the value will mutate the whole value, meaning read or write access to one of the properties requires read or write access to the whole value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> holly = Player(name: <span style=color:#e6db74>&#34;Holly&#34;</span>, health: <span style=color:#ae81ff>10</span>, energy: <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>balance(&amp;holly.health, &amp;holly.energy)    
</span></span><span style=display:flex><span><span style=color:#75715e>// Error, &#34;holly&#34; refers to an entire value type, health an energy are two peice of that value, </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// the two in-out of the function can&#39;t write accees to the overlap memory.</span>
</span></span></code></pre></div><p>However, if the <code>holly</code> in the above example is changed to a local variable instead of a global variable, it can be safe.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>someFunc</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> holly = Player(name: <span style=color:#e6db74>&#34;Holly&#34;</span>, health: <span style=color:#ae81ff>10</span>, energy: <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>    balance(&amp;holly.health, &amp;holly.energy)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The compiler can prove that memory access is safety because the two stored properties don&#39;t interact in any way.</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>someFunc()  <span style=color:#75715e>// It&#39;s OK.</span>
</span></span></code></pre></div><p>The overlapping access to properties of a structure isn’t always necessary to preserve memory safety. <strong>Exclusive access</strong> is a stricter requirement than memory safety.</p><p>It can prove that overlapping access to properties of a structure is <strong>safe</strong> if the following condition apply:</p><ul><li>Accessing only stored properties of an instance, not computed or class properties.</li><li>The structure is a local variable, not a global variable.</li><li>The structure is not capture by any closures, or its captured only by non-escaping closures.</li></ul><p>If the compiler can’t prove the access is safe, it doesn’t allow the access.</p></div><footer class=post-footer><ul class=post-tags></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share  on twitter" href="https://twitter.com/intent/tweet/?text=&url=http%3a%2f%2fexample.org%2fpost%2flanguage%2fswift%2f25memory-safety%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share  on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fexample.org%2fpost%2flanguage%2fswift%2f25memory-safety%2f&title="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share  on telegram" href="https://telegram.me/share/url?text=&url=http%3a%2f%2fexample.org%2fpost%2flanguage%2fswift%2f25memory-safety%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://example.org/>CodePaper</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>